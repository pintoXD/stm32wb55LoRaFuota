
SECoreBin.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .SE_CallGate_Code 00000100  08000200  08000200  00000200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .SE_Key_Data  000000cc  08000400  08000400  00000400  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .SE_Startup_Code 00000010  08000500  08000500  00000500  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00002950  08000600  08000600  00000600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .RamFunc      00000030  08002f50  08002f50  00002f50  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .isr_vector   000001c0  08002f80  08002f80  00002f80  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .rodata       00000238  08003140  08003140  00003140  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .ARM.extab    00000000  08003378  08003378  00010419  2**0
                  CONTENTS
  8 .ARM          00000000  08003378  08003378  00010419  2**0
                  CONTENTS
  9 .preinit_array 00000000  08003378  08003378  00010419  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 10 .init_array   00000008  08003378  08003378  00003378  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .fini_array   00000008  08003380  08003380  00003380  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000008  20000400  08003388  00010400  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 SYSTEM_DRIVER_CONTEXT 00000011  20000408  08003390  00010408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 14 .bss          000001e8  2000041c  080033a1  0001041c  2**2
                  ALLOC
 15 .ARM.attributes 0000002e  00000000  00000000  00010419  2**0
                  CONTENTS, READONLY
 16 MAPPING_TABLE 00000028  20030000  20030000  00020000  2**2
                  ALLOC
 17 MB_MEM1       000000ac  20030028  20030028  00020000  2**2
                  ALLOC
 18 MB_MEM2       00000324  200300d4  200300d4  00020000  2**2
                  ALLOC
 19 .debug_info   0001ea99  00000000  00000000  00010447  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_abbrev 0000448c  00000000  00000000  0002eee0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_aranges 00000be0  00000000  00000000  00033370  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_ranges 00000fd0  00000000  00000000  00033f50  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_macro  0002a9b8  00000000  00000000  00034f20  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 24 .debug_line   0001be0a  00000000  00000000  0005f8d8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_str    000ffc6e  00000000  00000000  0007b6e2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 26 .comment      000000d2  00000000  00000000  0017b350  2**0
                  CONTENTS, READONLY
 27 .debug_frame  00002014  00000000  00000000  0017b424  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 28 .debug_loc    0000ab85  00000000  00000000  0017d438  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .SE_CallGate_Code:

08000200 <SE_CallGate-0x4>:
 8000200:	00000000 	andeq	r0, r0, r0

08000204 <SE_CallGate>:
  * @param eID: Secure Engine protected function ID.
  * @param peSE_Status: Secure Engine Status.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_CallGate(SE_FunctionIDTypeDef eID, SE_StatusTypeDef *const peSE_Status, uint32_t PrimaskParam, ...)
{
 8000204:	b40c      	push	{r2, r3}
 8000206:	b580      	push	{r7, lr}
 8000208:	b086      	sub	sp, #24
 800020a:	af00      	add	r7, sp, #0
 800020c:	6078      	str	r0, [r7, #4]
 800020e:	6039      	str	r1, [r7, #0]
  LR = __get_LR();
#elif defined(__ARMCC_VERSION)
  __asm volatile("MOV %0, LR\n" : "=r"(LR));
#elif defined(__GNUC__)
  register unsigned lr asm("lr");
  LR = lr;
 8000210:	4673      	mov	r3, lr
 8000212:	60fb      	str	r3, [r7, #12]
   * instead of return(SE_ERROR) to avoid any attempt of attack by modifying
   * the call stack (LR) in order to execute code inside secure enclave
   */

  /* Check the Callgate was called only from SE Interface */
  IS_CALLER_SE_IF();
 8000214:	68fb      	ldr	r3, [r7, #12]
 8000216:	4a33      	ldr	r2, [pc, #204]	; (80002e4 <SE_CallGate+0xe0>)
 8000218:	4293      	cmp	r3, r2
 800021a:	d201      	bcs.n	8000220 <SE_CallGate+0x1c>
 800021c:	f002 f962 	bl	80024e4 <__NVIC_SystemReset>
 8000220:	68fb      	ldr	r3, [r7, #12]
 8000222:	4a31      	ldr	r2, [pc, #196]	; (80002e8 <SE_CallGate+0xe4>)
 8000224:	4293      	cmp	r3, r2
 8000226:	d901      	bls.n	800022c <SE_CallGate+0x28>
 8000228:	f002 f95c 	bl	80024e4 <__NVIC_SystemReset>

  /* Check the pointers allocation */
  if (SE_LL_Buffer_in_ram(peSE_Status, sizeof(*peSE_Status)) != SE_SUCCESS)
 800022c:	2104      	movs	r1, #4
 800022e:	6838      	ldr	r0, [r7, #0]
 8000230:	f000 fe7c 	bl	8000f2c <SE_LL_Buffer_in_ram>
 8000234:	4603      	mov	r3, r0
 8000236:	4a2d      	ldr	r2, [pc, #180]	; (80002ec <SE_CallGate+0xe8>)
 8000238:	4293      	cmp	r3, r2
 800023a:	d001      	beq.n	8000240 <SE_CallGate+0x3c>
  {
    NVIC_SystemReset();
 800023c:	f002 f952 	bl	80024e4 <__NVIC_SystemReset>
  }
  if (SE_LL_Buffer_part_of_SE_ram(peSE_Status, sizeof(*peSE_Status)) == SE_SUCCESS)
 8000240:	2104      	movs	r1, #4
 8000242:	6838      	ldr	r0, [r7, #0]
 8000244:	f000 fea2 	bl	8000f8c <SE_LL_Buffer_part_of_SE_ram>
 8000248:	4603      	mov	r3, r0
 800024a:	4a28      	ldr	r2, [pc, #160]	; (80002ec <SE_CallGate+0xe8>)
 800024c:	4293      	cmp	r3, r2
 800024e:	d101      	bne.n	8000254 <SE_CallGate+0x50>
  {
    NVIC_SystemReset();
 8000250:	f002 f948 	bl	80024e4 <__NVIC_SystemReset>
  }

  /* Double Check to avoid basic fault injection : the Callgate was called only from SE Interface */
  IS_CALLER_SE_IF();
 8000254:	68fb      	ldr	r3, [r7, #12]
 8000256:	4a23      	ldr	r2, [pc, #140]	; (80002e4 <SE_CallGate+0xe0>)
 8000258:	4293      	cmp	r3, r2
 800025a:	d201      	bcs.n	8000260 <SE_CallGate+0x5c>
 800025c:	f002 f942 	bl	80024e4 <__NVIC_SystemReset>
 8000260:	68fb      	ldr	r3, [r7, #12]
 8000262:	4a21      	ldr	r2, [pc, #132]	; (80002e8 <SE_CallGate+0xe4>)
 8000264:	4293      	cmp	r3, r2
 8000266:	d901      	bls.n	800026c <SE_CallGate+0x68>
 8000268:	f002 f93c 	bl	80024e4 <__NVIC_SystemReset>

  /* Double Check to avoid basic fault injection : Check the pointers allocation */
  if (SE_LL_Buffer_in_ram(peSE_Status, sizeof(*peSE_Status)) != SE_SUCCESS)
 800026c:	2104      	movs	r1, #4
 800026e:	6838      	ldr	r0, [r7, #0]
 8000270:	f000 fe5c 	bl	8000f2c <SE_LL_Buffer_in_ram>
 8000274:	4603      	mov	r3, r0
 8000276:	4a1d      	ldr	r2, [pc, #116]	; (80002ec <SE_CallGate+0xe8>)
 8000278:	4293      	cmp	r3, r2
 800027a:	d001      	beq.n	8000280 <SE_CallGate+0x7c>
  {
    NVIC_SystemReset();
 800027c:	f002 f932 	bl	80024e4 <__NVIC_SystemReset>
  }
  if (SE_LL_Buffer_part_of_SE_ram(peSE_Status, sizeof(*peSE_Status)) == SE_SUCCESS)
 8000280:	2104      	movs	r1, #4
 8000282:	6838      	ldr	r0, [r7, #0]
 8000284:	f000 fe82 	bl	8000f8c <SE_LL_Buffer_part_of_SE_ram>
 8000288:	4603      	mov	r3, r0
 800028a:	4a18      	ldr	r2, [pc, #96]	; (80002ec <SE_CallGate+0xe8>)
 800028c:	4293      	cmp	r3, r2
 800028e:	d101      	bne.n	8000294 <SE_CallGate+0x90>
  {
    NVIC_SystemReset();
 8000290:	f002 f928 	bl	80024e4 <__NVIC_SystemReset>
  UNUSED(PrimaskParam);
#endif /* IT_MANAGEMENT) */

#if defined(SFU_ISOLATE_SE_WITH_FIREWALL) || defined(CKS_ENABLED)
  /* Save Appli Vector Table Address   */
  AppliVectorsAddr = SCB->VTOR;
 8000294:	4b16      	ldr	r3, [pc, #88]	; (80002f0 <SE_CallGate+0xec>)
 8000296:	689b      	ldr	r3, [r3, #8]
 8000298:	4a16      	ldr	r2, [pc, #88]	; (80002f4 <SE_CallGate+0xf0>)
 800029a:	6013      	str	r3, [r2, #0]

  /* Set SE vector */
  SCB->VTOR = (uint32_t)&SeVectorsTable;
 800029c:	4b14      	ldr	r3, [pc, #80]	; (80002f0 <SE_CallGate+0xec>)
 800029e:	4a16      	ldr	r2, [pc, #88]	; (80002f8 <SE_CallGate+0xf4>)
 80002a0:	609a      	str	r2, [r3, #8]
#endif /* SFU_ISOLATE_SE_WITH_FIREWALL || CKS_ENABLED */

  *peSE_Status =  SE_OK;
 80002a2:	683b      	ldr	r3, [r7, #0]
 80002a4:	4a15      	ldr	r2, [pc, #84]	; (80002fc <SE_CallGate+0xf8>)
 80002a6:	601a      	str	r2, [r3, #0]

  /* Initializing arguments to store all values after peSE_Status */
  va_start(arguments, PrimaskParam);
 80002a8:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80002ac:	613b      	str	r3, [r7, #16]
#if defined(SFU_ISOLATE_SE_WITH_FIREWALL)
  /* Set SE specific stack before executing SE service */
  e_ret_status =  SE_SP_SMUGGLE(eID, peSE_Status, arguments);
#else
  /* No need to use a specific Stack */
  e_ret_status =  SE_CallGateService(eID, peSE_Status, arguments);
 80002ae:	693a      	ldr	r2, [r7, #16]
 80002b0:	6839      	ldr	r1, [r7, #0]
 80002b2:	6878      	ldr	r0, [r7, #4]
 80002b4:	f001 fe9e 	bl	8001ff4 <SE_CallGateService>
 80002b8:	6178      	str	r0, [r7, #20]
  /* Clean up arguments list*/
  va_end(arguments);

  /* Restore Appli Vector Value   */
#if defined(CKS_ENABLED)
  HAL_NVIC_DisableIRQ(IPCC_C1_RX_IRQn);
 80002ba:	202c      	movs	r0, #44	; 0x2c
 80002bc:	f000 ff26 	bl	800110c <HAL_NVIC_DisableIRQ>
  HAL_NVIC_DisableIRQ(IPCC_C1_TX_IRQn);
 80002c0:	202d      	movs	r0, #45	; 0x2d
 80002c2:	f000 ff23 	bl	800110c <HAL_NVIC_DisableIRQ>
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80002c6:	f3bf 8f6f 	isb	sy
}
 80002ca:	bf00      	nop
  __ISB();
  SCB->VTOR = AppliVectorsAddr;
 80002cc:	4a08      	ldr	r2, [pc, #32]	; (80002f0 <SE_CallGate+0xec>)
 80002ce:	4b09      	ldr	r3, [pc, #36]	; (80002f4 <SE_CallGate+0xf0>)
 80002d0:	681b      	ldr	r3, [r3, #0]
 80002d2:	6093      	str	r3, [r2, #8]
#endif /* SFU_ISOLATE_SE_WITH_FIREWALL */

  /* Exit the protected area */
  EXIT_PROTECTED_AREA();

  return e_ret_status;
 80002d4:	697b      	ldr	r3, [r7, #20]
}
 80002d6:	4618      	mov	r0, r3
 80002d8:	3718      	adds	r7, #24
 80002da:	46bd      	mov	sp, r7
 80002dc:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 80002e0:	b002      	add	sp, #8
 80002e2:	4770      	bx	lr
 80002e4:	08003600 	.word	0x08003600
 80002e8:	08003bff 	.word	0x08003bff
 80002ec:	0012310f 	.word	0x0012310f
 80002f0:	e000ed00 	.word	0xe000ed00
 80002f4:	20000600 	.word	0x20000600
 80002f8:	08003000 	.word	0x08003000
 80002fc:	0012e223 	.word	0x0012e223

Disassembly of section .SE_Startup_Code:

08000500 <SE_CORE_Startup>:
  */
#if defined(__ARMCC_VERSION)
__attribute__((section(".SE_Startup_Code")))
#endif /* __ARMCC_VERSION */
__root SE_ErrorStatus SE_CORE_Startup(void)
{
 8000500:	b508      	push	{r3, lr}
  /* Data initialization function*/
  __iar_data_init3();
#elif defined (__ARMCC_VERSION)
  __arm_data_init();
#elif defined(__GNUC__)
  __gcc_data_init();
 8000502:	f000 f8db 	bl	80006bc <__gcc_data_init>
#endif /* __ICCARM__ */

  /*NOTE : other initialization may be added here */
  return SE_SUCCESS;
}
 8000506:	4801      	ldr	r0, [pc, #4]	; (800050c <SE_CORE_Startup+0xc>)
 8000508:	bd08      	pop	{r3, pc}
 800050a:	bf00      	nop
 800050c:	0012310f 	.word	0x0012310f

Disassembly of section .text:

08000600 <__do_global_dtors_aux>:
 8000600:	b510      	push	{r4, lr}
 8000602:	4c05      	ldr	r4, [pc, #20]	; (8000618 <__do_global_dtors_aux+0x18>)
 8000604:	7823      	ldrb	r3, [r4, #0]
 8000606:	b933      	cbnz	r3, 8000616 <__do_global_dtors_aux+0x16>
 8000608:	4b04      	ldr	r3, [pc, #16]	; (800061c <__do_global_dtors_aux+0x1c>)
 800060a:	b113      	cbz	r3, 8000612 <__do_global_dtors_aux+0x12>
 800060c:	4804      	ldr	r0, [pc, #16]	; (8000620 <__do_global_dtors_aux+0x20>)
 800060e:	f3af 8000 	nop.w
 8000612:	2301      	movs	r3, #1
 8000614:	7023      	strb	r3, [r4, #0]
 8000616:	bd10      	pop	{r4, pc}
 8000618:	2000041c 	.word	0x2000041c
 800061c:	00000000 	.word	0x00000000
 8000620:	08002f38 	.word	0x08002f38

08000624 <frame_dummy>:
 8000624:	b508      	push	{r3, lr}
 8000626:	4b03      	ldr	r3, [pc, #12]	; (8000634 <frame_dummy+0x10>)
 8000628:	b11b      	cbz	r3, 8000632 <frame_dummy+0xe>
 800062a:	4903      	ldr	r1, [pc, #12]	; (8000638 <frame_dummy+0x14>)
 800062c:	4803      	ldr	r0, [pc, #12]	; (800063c <frame_dummy+0x18>)
 800062e:	f3af 8000 	nop.w
 8000632:	bd08      	pop	{r3, pc}
 8000634:	00000000 	.word	0x00000000
 8000638:	20000420 	.word	0x20000420
 800063c:	08002f38 	.word	0x08002f38

08000640 <LoopCopyDataInit>:
	extern char _edata asm("_edata");

	vu32* src = (vu32*) &_sidata;
	vu32* dst = (vu32*) &_sdata;

	vu32 len = (&_edata - &_sdata) / 4;
 8000640:	4b0d      	ldr	r3, [pc, #52]	; (8000678 <LoopCopyDataInit+0x38>)
 8000642:	4a0e      	ldr	r2, [pc, #56]	; (800067c <LoopCopyDataInit+0x3c>)

	for(vu32 i=0; i < len; i++)
		dst[i] = src[i];
 8000644:	480e      	ldr	r0, [pc, #56]	; (8000680 <LoopCopyDataInit+0x40>)
	vu32 len = (&_edata - &_sdata) / 4;
 8000646:	1a9b      	subs	r3, r3, r2
void LoopCopyDataInit(void) {
 8000648:	b082      	sub	sp, #8
	vu32 len = (&_edata - &_sdata) / 4;
 800064a:	bf48      	it	mi
 800064c:	3303      	addmi	r3, #3
 800064e:	109b      	asrs	r3, r3, #2
 8000650:	9300      	str	r3, [sp, #0]
	for(vu32 i=0; i < len; i++)
 8000652:	2300      	movs	r3, #0
 8000654:	9301      	str	r3, [sp, #4]
 8000656:	9901      	ldr	r1, [sp, #4]
 8000658:	9b00      	ldr	r3, [sp, #0]
 800065a:	4299      	cmp	r1, r3
 800065c:	d301      	bcc.n	8000662 <LoopCopyDataInit+0x22>
}
 800065e:	b002      	add	sp, #8
 8000660:	4770      	bx	lr
		dst[i] = src[i];
 8000662:	9901      	ldr	r1, [sp, #4]
 8000664:	9b01      	ldr	r3, [sp, #4]
 8000666:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
 800066a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	for(vu32 i=0; i < len; i++)
 800066e:	9b01      	ldr	r3, [sp, #4]
 8000670:	3301      	adds	r3, #1
 8000672:	9301      	str	r3, [sp, #4]
 8000674:	e7ef      	b.n	8000656 <LoopCopyDataInit+0x16>
 8000676:	bf00      	nop
 8000678:	20000408 	.word	0x20000408
 800067c:	20000400 	.word	0x20000400
 8000680:	08003388 	.word	0x08003388

08000684 <LoopFillZerobss>:
void LoopFillZerobss(void) {
	extern char _sbss asm("_sbss");
	extern char _ebss asm("_ebss");

	vu32* dst = (vu32*) &_sbss;
	vu32 len = (&_ebss - &_sbss) / 4;
 8000684:	4b0b      	ldr	r3, [pc, #44]	; (80006b4 <LoopFillZerobss+0x30>)
 8000686:	4a0c      	ldr	r2, [pc, #48]	; (80006b8 <LoopFillZerobss+0x34>)
 8000688:	1a9b      	subs	r3, r3, r2
void LoopFillZerobss(void) {
 800068a:	b082      	sub	sp, #8
	vu32 len = (&_ebss - &_sbss) / 4;
 800068c:	bf48      	it	mi
 800068e:	3303      	addmi	r3, #3
 8000690:	109b      	asrs	r3, r3, #2
 8000692:	9300      	str	r3, [sp, #0]

	for(vu32 i=0; i < len; i++)
 8000694:	2300      	movs	r3, #0
 8000696:	9301      	str	r3, [sp, #4]
 8000698:	9801      	ldr	r0, [sp, #4]
 800069a:	9900      	ldr	r1, [sp, #0]
 800069c:	4288      	cmp	r0, r1
 800069e:	d301      	bcc.n	80006a4 <LoopFillZerobss+0x20>
		dst[i] = 0;
}
 80006a0:	b002      	add	sp, #8
 80006a2:	4770      	bx	lr
		dst[i] = 0;
 80006a4:	9901      	ldr	r1, [sp, #4]
 80006a6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	for(vu32 i=0; i < len; i++)
 80006aa:	9901      	ldr	r1, [sp, #4]
 80006ac:	3101      	adds	r1, #1
 80006ae:	9101      	str	r1, [sp, #4]
 80006b0:	e7f2      	b.n	8000698 <LoopFillZerobss+0x14>
 80006b2:	bf00      	nop
 80006b4:	20000604 	.word	0x20000604
 80006b8:	2000041c 	.word	0x2000041c

080006bc <__gcc_data_init>:

void __gcc_data_init(void) {
 80006bc:	b508      	push	{r3, lr}
	LoopFillZerobss();
 80006be:	f7ff ffe1 	bl	8000684 <LoopFillZerobss>
	LoopCopyDataInit();
}
 80006c2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	LoopCopyDataInit();
 80006c6:	f7ff bfbb 	b.w	8000640 <LoopCopyDataInit>

080006ca <Reset_Handler>:
  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
    Infinite_Loop:
    b Infinite_Loop
 80006ca:	e7fe      	b.n	80006ca <Reset_Handler>

080006cc <ADC1_IRQHandler>:
 * @retval None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
/*Infinite_Loop:*/
	b	Infinite_Loop
 80006cc:	f7ff bffd 	b.w	80006ca <Reset_Handler>

080006d0 <HW_IPCC_Enable>:
  * @retval None
  */
__STATIC_INLINE void LL_C2_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 80006d0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
}
/******************************************************************************
 * GENERAL
 ******************************************************************************/
void HW_IPCC_Enable( void )
{
 80006d4:	b082      	sub	sp, #8
 80006d6:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
 80006da:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80006de:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 80006e2:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 80006e6:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 80006ea:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80006ec:	9b01      	ldr	r3, [sp, #4]
  *         @arg @ref LL_EXTI_LINE_41
  * @retval None
  */
__STATIC_INLINE void LL_C2_EXTI_EnableEvent_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->C2EMR2, ExtiLine);
 80006ee:	4b0a      	ldr	r3, [pc, #40]	; (8000718 <HW_IPCC_Enable+0x48>)
 80006f0:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 80006f4:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80006f8:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->RTSR2, ExtiLine);
 80006fc:	6a1a      	ldr	r2, [r3, #32]
 80006fe:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000702:	621a      	str	r2, [r3, #32]
   * When the CPU2 receives that command, it waits for its event input to be set to restart the CPU2 firmware.
   * This is required because once C2BOOT has been set once, a clear/set on C2BOOT has no effect.
   * When SHCI_C2_Reinit( ) is not called, generating an event to the CPU2 does not have any effect
   * So, by default, the application shall both set the event flag and set the C2BOOT bit.
   */
  __SEV( );       /* Set the internal event flag and send an event to the CPU2 */
 8000704:	bf40      	sev
  __WFE( );       /* Clear the internal event flag */
 8000706:	bf20      	wfe
  * @rmtoll CR4          C2BOOT        LL_PWR_EnableBootC2
  * @retval None
  */
__STATIC_INLINE void LL_PWR_EnableBootC2(void)
{
  SET_BIT(PWR->CR4, PWR_CR4_C2BOOT);
 8000708:	4a04      	ldr	r2, [pc, #16]	; (800071c <HW_IPCC_Enable+0x4c>)
 800070a:	68d3      	ldr	r3, [r2, #12]
 800070c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000710:	60d3      	str	r3, [r2, #12]
  LL_PWR_EnableBootC2( );

  return;
}
 8000712:	b002      	add	sp, #8
 8000714:	4770      	bx	lr
 8000716:	bf00      	nop
 8000718:	58000800 	.word	0x58000800
 800071c:	58000400 	.word	0x58000400

08000720 <HW_IPCC_Init>:
  SET_BIT(RCC->AHB3ENR, Periphs);
 8000720:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

void HW_IPCC_Init( void )
{
 8000724:	b507      	push	{r0, r1, r2, lr}
 8000726:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8000728:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800072c:	651a      	str	r2, [r3, #80]	; 0x50
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 800072e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8000730:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000734:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8000736:	9b01      	ldr	r3, [sp, #4]
  * @param  IPCCx IPCC Instance.
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_EnableIT_RXO(IPCC_TypeDef *IPCCx)
{
  SET_BIT(IPCCx->C1CR, IPCC_C1CR_RXOIE);
 8000738:	4b08      	ldr	r3, [pc, #32]	; (800075c <HW_IPCC_Init+0x3c>)
 800073a:	681a      	ldr	r2, [r3, #0]
 800073c:	f042 0201 	orr.w	r2, r2, #1
 8000740:	601a      	str	r2, [r3, #0]
  SET_BIT(IPCCx->C1CR, IPCC_C1CR_TXFIE);
 8000742:	681a      	ldr	r2, [r3, #0]
 8000744:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000748:	601a      	str	r2, [r3, #0]
  LL_AHB3_GRP1_EnableClock( LL_AHB3_GRP1_PERIPH_IPCC );

  LL_C1_IPCC_EnableIT_RXO( IPCC );
  LL_C1_IPCC_EnableIT_TXF( IPCC );

  HAL_NVIC_EnableIRQ(IPCC_C1_RX_IRQn);
 800074a:	202c      	movs	r0, #44	; 0x2c
 800074c:	f000 fcd0 	bl	80010f0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_EnableIRQ(IPCC_C1_TX_IRQn);
 8000750:	202d      	movs	r0, #45	; 0x2d

  return;
}
 8000752:	b003      	add	sp, #12
 8000754:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_NVIC_EnableIRQ(IPCC_C1_TX_IRQn);
 8000758:	f000 bcca 	b.w	80010f0 <HAL_NVIC_EnableIRQ>
 800075c:	58000c00 	.word	0x58000c00

08000760 <HW_IPCC_SYS_Init>:
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_EnableReceiveChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
  CLEAR_BIT(IPCCx->C1MR, Channel);
 8000760:	4a02      	ldr	r2, [pc, #8]	; (800076c <HW_IPCC_SYS_Init+0xc>)
 8000762:	6853      	ldr	r3, [r2, #4]
 8000764:	f023 0302 	bic.w	r3, r3, #2
 8000768:	6053      	str	r3, [r2, #4]
void HW_IPCC_SYS_Init( void )
{
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_SYSTEM_EVENT_CHANNEL );

  return;
}
 800076a:	4770      	bx	lr
 800076c:	58000c00 	.word	0x58000c00

08000770 <HW_IPCC_SYS_SendCmd>:
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_SetFlag_CHx(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
  WRITE_REG(IPCCx->C1SCR, Channel << IPCC_C1SCR_CH1S_Pos);
 8000770:	4b04      	ldr	r3, [pc, #16]	; (8000784 <HW_IPCC_SYS_SendCmd+0x14>)
 8000772:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8000776:	609a      	str	r2, [r3, #8]
  CLEAR_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8000778:	685a      	ldr	r2, [r3, #4]
 800077a:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800077e:	605a      	str	r2, [r3, #4]
{
  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );
  LL_C1_IPCC_EnableTransmitChannel( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );

  return;
}
 8000780:	4770      	bx	lr
 8000782:	bf00      	nop
 8000784:	58000c00 	.word	0x58000c00

08000788 <HW_IPCC_Tx_Handler>:
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_C1_IPCC_IsActiveFlag_CHx(IPCC_TypeDef  const *const IPCCx, uint32_t Channel)
{
  return ((READ_BIT(IPCCx->C1TOC2SR, Channel) == (Channel)) ? 1UL : 0UL);
 8000788:	4b1e      	ldr	r3, [pc, #120]	; (8000804 <HW_IPCC_Tx_Handler+0x7c>)
 800078a:	68da      	ldr	r2, [r3, #12]
 800078c:	f012 0f02 	tst.w	r2, #2
{
 8000790:	b510      	push	{r4, lr}
 8000792:	461a      	mov	r2, r3
 8000794:	d109      	bne.n	80007aa <HW_IPCC_Tx_Handler+0x22>
  if (HW_IPCC_TX_PENDING( HW_IPCC_SYSTEM_CMD_RSP_CHANNEL ))
 8000796:	6859      	ldr	r1, [r3, #4]
 8000798:	0389      	lsls	r1, r1, #14
 800079a:	d406      	bmi.n	80007aa <HW_IPCC_Tx_Handler+0x22>
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 800079c:	685a      	ldr	r2, [r3, #4]
 800079e:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 80007a2:	605a      	str	r2, [r3, #4]

static void HW_IPCC_SYS_CmdEvtHandler( void )
{
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );

  HW_IPCC_SYS_CmdEvtNot();
 80007a4:	f002 f8d2 	bl	800294c <HW_IPCC_SYS_CmdEvtNot>
}
 80007a8:	bd10      	pop	{r4, pc}
  return ((READ_BIT(IPCCx->C1TOC2SR, Channel) == (Channel)) ? 1UL : 0UL);
 80007aa:	68d3      	ldr	r3, [r2, #12]
 80007ac:	079b      	lsls	r3, r3, #30
 80007ae:	d407      	bmi.n	80007c0 <HW_IPCC_Tx_Handler+0x38>
  else if (HW_IPCC_TX_PENDING( HW_IPCC_SYSTEM_CMD_RSP_CHANNEL ))
 80007b0:	6853      	ldr	r3, [r2, #4]
 80007b2:	039c      	lsls	r4, r3, #14
 80007b4:	d404      	bmi.n	80007c0 <HW_IPCC_Tx_Handler+0x38>
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 80007b6:	6853      	ldr	r3, [r2, #4]
 80007b8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80007bc:	6053      	str	r3, [r2, #4]
 80007be:	e7f1      	b.n	80007a4 <HW_IPCC_Tx_Handler+0x1c>
  return ((READ_BIT(IPCCx->C1TOC2SR, Channel) == (Channel)) ? 1UL : 0UL);
 80007c0:	4c10      	ldr	r4, [pc, #64]	; (8000804 <HW_IPCC_Tx_Handler+0x7c>)
 80007c2:	68e3      	ldr	r3, [r4, #12]
 80007c4:	f013 0f08 	tst.w	r3, #8
 80007c8:	4623      	mov	r3, r4
 80007ca:	d10d      	bne.n	80007e8 <HW_IPCC_Tx_Handler+0x60>
  else if (HW_IPCC_TX_PENDING( HW_IPCC_MM_RELEASE_BUFFER_CHANNEL ))
 80007cc:	6862      	ldr	r2, [r4, #4]
 80007ce:	0310      	lsls	r0, r2, #12
 80007d0:	d40a      	bmi.n	80007e8 <HW_IPCC_Tx_Handler+0x60>
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 80007d2:	6863      	ldr	r3, [r4, #4]
 80007d4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80007d8:	6063      	str	r3, [r4, #4]

static void HW_IPCC_MM_FreeBufHandler( void )
{
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );

  FreeBufCb();
 80007da:	4b0b      	ldr	r3, [pc, #44]	; (8000808 <HW_IPCC_Tx_Handler+0x80>)
 80007dc:	681b      	ldr	r3, [r3, #0]
 80007de:	4798      	blx	r3
  WRITE_REG(IPCCx->C1SCR, Channel << IPCC_C1SCR_CH1S_Pos);
 80007e0:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80007e4:	60a3      	str	r3, [r4, #8]

  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );

  return;
 80007e6:	e7df      	b.n	80007a8 <HW_IPCC_Tx_Handler+0x20>
  return ((READ_BIT(IPCCx->C1TOC2SR, Channel) == (Channel)) ? 1UL : 0UL);
 80007e8:	68da      	ldr	r2, [r3, #12]
 80007ea:	0691      	lsls	r1, r2, #26
 80007ec:	d4dc      	bmi.n	80007a8 <HW_IPCC_Tx_Handler+0x20>
  else if (HW_IPCC_TX_PENDING( HW_IPCC_HCI_ACL_DATA_CHANNEL ))
 80007ee:	685a      	ldr	r2, [r3, #4]
 80007f0:	0292      	lsls	r2, r2, #10
 80007f2:	d4d9      	bmi.n	80007a8 <HW_IPCC_Tx_Handler+0x20>
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 80007f4:	685a      	ldr	r2, [r3, #4]
 80007f6:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80007fa:	605a      	str	r2, [r3, #4]
  HW_IPCC_BLE_AclDataAckNot();
 80007fc:	f002 f878 	bl	80028f0 <HW_IPCC_BLE_AclDataAckNot>
  return;
 8000800:	e7d2      	b.n	80007a8 <HW_IPCC_Tx_Handler+0x20>
 8000802:	bf00      	nop
 8000804:	58000c00 	.word	0x58000c00
 8000808:	20000438 	.word	0x20000438

0800080c <HW_IPCC_Rx_Handler>:
{
 800080c:	b538      	push	{r3, r4, r5, lr}
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_C2_IPCC_IsActiveFlag_CHx(IPCC_TypeDef  const *const IPCCx, uint32_t Channel)
{
  return ((READ_BIT(IPCCx->C2TOC1SR, Channel) == (Channel)) ? 1UL : 0UL);
 800080e:	4c12      	ldr	r4, [pc, #72]	; (8000858 <HW_IPCC_Rx_Handler+0x4c>)
 8000810:	69e3      	ldr	r3, [r4, #28]
 8000812:	f013 0f02 	tst.w	r3, #2
 8000816:	4625      	mov	r5, r4
 8000818:	d007      	beq.n	800082a <HW_IPCC_Rx_Handler+0x1e>
  if (HW_IPCC_RX_PENDING( HW_IPCC_SYSTEM_EVENT_CHANNEL ))
 800081a:	6863      	ldr	r3, [r4, #4]
 800081c:	079b      	lsls	r3, r3, #30
 800081e:	d404      	bmi.n	800082a <HW_IPCC_Rx_Handler+0x1e>
  HW_IPCC_SYS_EvtNot();
 8000820:	f002 f8a0 	bl	8002964 <HW_IPCC_SYS_EvtNot>
  WRITE_REG(IPCCx->C1SCR, Channel);
 8000824:	2302      	movs	r3, #2
 8000826:	60a3      	str	r3, [r4, #8]
  return;
 8000828:	e009      	b.n	800083e <HW_IPCC_Rx_Handler+0x32>
  return ((READ_BIT(IPCCx->C2TOC1SR, Channel) == (Channel)) ? 1UL : 0UL);
 800082a:	69eb      	ldr	r3, [r5, #28]
 800082c:	07d8      	lsls	r0, r3, #31
 800082e:	d507      	bpl.n	8000840 <HW_IPCC_Rx_Handler+0x34>
  else if (HW_IPCC_RX_PENDING( HW_IPCC_BLE_EVENT_CHANNEL ))
 8000830:	686b      	ldr	r3, [r5, #4]
 8000832:	07d9      	lsls	r1, r3, #31
 8000834:	d404      	bmi.n	8000840 <HW_IPCC_Rx_Handler+0x34>
  HW_IPCC_BLE_RxEvtNot();
 8000836:	f002 f845 	bl	80028c4 <HW_IPCC_BLE_RxEvtNot>
  WRITE_REG(IPCCx->C1SCR, Channel);
 800083a:	2301      	movs	r3, #1
 800083c:	60ab      	str	r3, [r5, #8]
}
 800083e:	bd38      	pop	{r3, r4, r5, pc}
  return ((READ_BIT(IPCCx->C2TOC1SR, Channel) == (Channel)) ? 1UL : 0UL);
 8000840:	4c05      	ldr	r4, [pc, #20]	; (8000858 <HW_IPCC_Rx_Handler+0x4c>)
 8000842:	69e3      	ldr	r3, [r4, #28]
 8000844:	071a      	lsls	r2, r3, #28
 8000846:	d5fa      	bpl.n	800083e <HW_IPCC_Rx_Handler+0x32>
  else if (HW_IPCC_RX_PENDING( HW_IPCC_TRACES_CHANNEL ))
 8000848:	6863      	ldr	r3, [r4, #4]
 800084a:	071b      	lsls	r3, r3, #28
 800084c:	d4f7      	bmi.n	800083e <HW_IPCC_Rx_Handler+0x32>
  return;
}

static void HW_IPCC_TRACES_EvtHandler( void )
{
  HW_IPCC_TRACES_EvtNot();
 800084e:	f002 f8c1 	bl	80029d4 <HW_IPCC_TRACES_EvtNot>
  WRITE_REG(IPCCx->C1SCR, Channel);
 8000852:	2308      	movs	r3, #8
 8000854:	e7e7      	b.n	8000826 <HW_IPCC_Rx_Handler+0x1a>
 8000856:	bf00      	nop
 8000858:	58000c00 	.word	0x58000c00

0800085c <CM0_Init>:
  SET_BIT(RCC->AHB3ENR, Periphs);
 800085c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  * @note
  * @param  None
  * @retval None
  */
void CM0_Init(void)
{
 8000860:	b510      	push	{r4, lr}
 8000862:	6d1a      	ldr	r2, [r3, #80]	; 0x50
  SHCI_TL_HciInitConf_t SHci_Tl_Init_Conf;
  /**< Reference table initialization */
  TL_Init();

  /**< System channel initialization */
  SHci_Tl_Init_Conf.p_cmdbuffer = (uint8_t*)&SystemCmdBuffer;
 8000864:	4c1c      	ldr	r4, [pc, #112]	; (80008d8 <CM0_Init+0x7c>)
 8000866:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800086a:	651a      	str	r2, [r3, #80]	; 0x50
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 800086c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
{
 800086e:	b08a      	sub	sp, #40	; 0x28
 8000870:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000874:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8000876:	9b01      	ldr	r3, [sp, #4]
 8000878:	4b18      	ldr	r3, [pc, #96]	; (80008dc <CM0_Init+0x80>)
 800087a:	223f      	movs	r2, #63	; 0x3f
 800087c:	609a      	str	r2, [r3, #8]
  WRITE_REG(IPCCx->C2SCR, Channel);
 800087e:	619a      	str	r2, [r3, #24]
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8000880:	685a      	ldr	r2, [r3, #4]
 8000882:	f442 127c 	orr.w	r2, r2, #4128768	; 0x3f0000
 8000886:	605a      	str	r2, [r3, #4]
  SET_BIT(IPCCx->C2MR, Channel << (IPCC_C2MR_CH1FM_Pos));
 8000888:	695a      	ldr	r2, [r3, #20]
 800088a:	f442 127c 	orr.w	r2, r2, #4128768	; 0x3f0000
 800088e:	615a      	str	r2, [r3, #20]
  SET_BIT(IPCCx->C1MR, Channel);
 8000890:	685a      	ldr	r2, [r3, #4]
 8000892:	f042 023f 	orr.w	r2, r2, #63	; 0x3f
 8000896:	605a      	str	r2, [r3, #4]
  SET_BIT(IPCCx->C2MR, Channel);
 8000898:	695a      	ldr	r2, [r3, #20]
 800089a:	f042 023f 	orr.w	r2, r2, #63	; 0x3f
 800089e:	615a      	str	r2, [r3, #20]
  TL_Init();
 80008a0:	f001 ffec 	bl	800287c <TL_Init>
  SHci_Tl_Init_Conf.StatusNotCallBack = NULL;
 80008a4:	2000      	movs	r0, #0
  shci_init(NULL, (void*) &SHci_Tl_Init_Conf);
 80008a6:	a902      	add	r1, sp, #8
  SHci_Tl_Init_Conf.p_cmdbuffer = (uint8_t*)&SystemCmdBuffer;
 80008a8:	9402      	str	r4, [sp, #8]
  SHci_Tl_Init_Conf.StatusNotCallBack = NULL;
 80008aa:	9003      	str	r0, [sp, #12]
  shci_init(NULL, (void*) &SHci_Tl_Init_Conf);
 80008ac:	f001 ff4c 	bl	8002748 <shci_init>

  /**< Memory Manager channel initialization */
  tl_mm_config.p_SystemSpareEvtBuffer = SystemSpareEvtBuffer;
 80008b0:	f504 7386 	add.w	r3, r4, #268	; 0x10c
 80008b4:	9305      	str	r3, [sp, #20]
  tl_mm_config.p_AsynchEvtPool = EvtPool;
  tl_mm_config.AsynchEvtPoolSize = POOL_SIZE;
  TL_MM_Init( &tl_mm_config );
 80008b6:	a804      	add	r0, sp, #16
  tl_mm_config.AsynchEvtPoolSize = POOL_SIZE;
 80008b8:	f44f 7386 	mov.w	r3, #268	; 0x10c
  tl_mm_config.p_AsynchEvtPool = EvtPool;
 80008bc:	f504 7406 	add.w	r4, r4, #536	; 0x218
  tl_mm_config.AsynchEvtPoolSize = POOL_SIZE;
 80008c0:	9307      	str	r3, [sp, #28]
  tl_mm_config.p_AsynchEvtPool = EvtPool;
 80008c2:	9406      	str	r4, [sp, #24]
  TL_MM_Init( &tl_mm_config );
 80008c4:	f002 f864 	bl	8002990 <TL_MM_Init>

  TL_Enable();
 80008c8:	f001 ffd6 	bl	8002878 <TL_Enable>

  // Check channel 2
  while(FLAG_WAIT_CPU2_RDY==1);
 80008cc:	4a04      	ldr	r2, [pc, #16]	; (80008e0 <CM0_Init+0x84>)
 80008ce:	7813      	ldrb	r3, [r2, #0]
 80008d0:	2b01      	cmp	r3, #1
 80008d2:	d0fc      	beq.n	80008ce <CM0_Init+0x72>
}
 80008d4:	b00a      	add	sp, #40	; 0x28
 80008d6:	bd10      	pop	{r4, pc}
 80008d8:	200300d4 	.word	0x200300d4
 80008dc:	58000c00 	.word	0x58000c00
 80008e0:	20000400 	.word	0x20000400

080008e4 <CM0_DeInit>:
{
 80008e4:	b508      	push	{r3, lr}
  if (SHCI_C2_FUS_GetState(NULL) == FUS_STATE_VALUE_IDLE)
 80008e6:	2000      	movs	r0, #0
 80008e8:	f001 feb8 	bl	800265c <SHCI_C2_FUS_GetState>
 80008ec:	b928      	cbnz	r0, 80008fa <CM0_DeInit+0x16>
    SHCI_C2_FUS_StartWs();
 80008ee:	f001 fee9 	bl	80026c4 <SHCI_C2_FUS_StartWs>
    HAL_Delay(2000U);
 80008f2:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80008f6:	f001 fea3 	bl	8002640 <HAL_Delay>
}
 80008fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  SHCI_C2_Reinit();
 80008fe:	f001 befd 	b.w	80026fc <SHCI_C2_Reinit>
	...

08000904 <shci_notify_asynch_evt>:
  * @param  pdata Packet
  * @retval None
  */
void shci_notify_asynch_evt(void *pdata)
{
  FLAG_WAIT_CPU2_RDY = 0U;
 8000904:	4b01      	ldr	r3, [pc, #4]	; (800090c <shci_notify_asynch_evt+0x8>)
 8000906:	2200      	movs	r2, #0
 8000908:	701a      	strb	r2, [r3, #0]
  return;
}
 800090a:	4770      	bx	lr
 800090c:	20000400 	.word	0x20000400

08000910 <shci_cmd_resp_release>:
  * @param  flag: Release flag
  * @retval None
  */
void shci_cmd_resp_release(uint32_t flag)
{
  FLAG_WAIT_RESP = 1U;
 8000910:	4b01      	ldr	r3, [pc, #4]	; (8000918 <shci_cmd_resp_release+0x8>)
 8000912:	2201      	movs	r2, #1
 8000914:	701a      	strb	r2, [r3, #0]
  return;
}
 8000916:	4770      	bx	lr
 8000918:	2000043c 	.word	0x2000043c

0800091c <shci_cmd_resp_wait>:
  * @param  timeout: Waiting timeout
  * @retval None
  */
void shci_cmd_resp_wait(uint32_t timeout)
{
  while ((FLAG_WAIT_RESP & 0x1) == 0U);
 800091c:	4b03      	ldr	r3, [pc, #12]	; (800092c <shci_cmd_resp_wait+0x10>)
 800091e:	781a      	ldrb	r2, [r3, #0]
 8000920:	07d2      	lsls	r2, r2, #31
 8000922:	d5fc      	bpl.n	800091e <shci_cmd_resp_wait+0x2>
  FLAG_WAIT_RESP = 0U;
 8000924:	2200      	movs	r2, #0
 8000926:	701a      	strb	r2, [r3, #0]
  return;
}
 8000928:	4770      	bx	lr
 800092a:	bf00      	nop
 800092c:	2000043c 	.word	0x2000043c

08000930 <CM0_Update>:
  * @note
  * @param  None
  * @retval None
  */
SE_ErrorStatus CM0_Update(void)
{
 8000930:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8000932:	4c3a      	ldr	r4, [pc, #232]	; (8000a1c <CM0_Update+0xec>)
  SE_ErrorStatus e_ret_status = SE_ERROR;

  /* Enable IPCC interrupt */
  HAL_NVIC_EnableIRQ(IPCC_C1_RX_IRQn);
 8000934:	202c      	movs	r0, #44	; 0x2c
 8000936:	f000 fbdb 	bl	80010f0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_EnableIRQ(IPCC_C1_TX_IRQn);
 800093a:	202d      	movs	r0, #45	; 0x2d
 800093c:	f000 fbd8 	bl	80010f0 <HAL_NVIC_EnableIRQ>

  if (STANDALONE_LOADER_STATE == STANDALONE_LOADER_DWL_REQ)
 8000940:	6822      	ldr	r2, [r4, #0]
 8000942:	4b37      	ldr	r3, [pc, #220]	; (8000a20 <CM0_Update+0xf0>)
 8000944:	429a      	cmp	r2, r3
 8000946:	4627      	mov	r7, r4
 8000948:	d104      	bne.n	8000954 <CM0_Update+0x24>
  {
    /* New download started ==> CMO process restarted from initial stage */
    CMO_UPDATE_PROCESS = CM0_UPDATE_NOT_INITIALIZED;
 800094a:	2300      	movs	r3, #0
 800094c:	6063      	str	r3, [r4, #4]
      e_ret_status = SE_SUCCESS;
 800094e:	4835      	ldr	r0, [pc, #212]	; (8000a24 <CM0_Update+0xf4>)
  {
    e_ret_status = SE_ERROR;
  }

  return e_ret_status;
}
 8000950:	b003      	add	sp, #12
 8000952:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (CMO_UPDATE_PROCESS == CM0_UPDATE_NOT_INITIALIZED)
 8000954:	6865      	ldr	r5, [r4, #4]
 8000956:	4e34      	ldr	r6, [pc, #208]	; (8000a28 <CM0_Update+0xf8>)
 8000958:	b9f5      	cbnz	r5, 8000998 <CM0_Update+0x68>
  CMO_UPDATE_PROCESS = CM0_UPDATE_TO_BE_STARTED;
 800095a:	6066      	str	r6, [r4, #4]
  fus_state_value = SHCI_C2_FUS_GetState(NULL);
 800095c:	4628      	mov	r0, r5
 800095e:	f001 fe7d 	bl	800265c <SHCI_C2_FUS_GetState>
  if (fus_state_value == FUS_STATE_VALUE_ERROR)
 8000962:	28ff      	cmp	r0, #255	; 0xff
 8000964:	d10b      	bne.n	800097e <CM0_Update+0x4e>
    (void) SHCI_C2_FUS_GetState(NULL);
 8000966:	4628      	mov	r0, r5
 8000968:	f001 fe78 	bl	800265c <SHCI_C2_FUS_GetState>
      WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
 800096c:	4c2f      	ldr	r4, [pc, #188]	; (8000a2c <CM0_Update+0xfc>)
 800096e:	f64a 25aa 	movw	r5, #43690	; 0xaaaa
      HAL_Delay(2000U);
 8000972:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8000976:	f001 fe63 	bl	8002640 <HAL_Delay>
      WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
 800097a:	6025      	str	r5, [r4, #0]
    while(1)
 800097c:	e7f9      	b.n	8000972 <CM0_Update+0x42>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800097e:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8000982:	492b      	ldr	r1, [pc, #172]	; (8000a30 <CM0_Update+0x100>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8000984:	4b2b      	ldr	r3, [pc, #172]	; (8000a34 <CM0_Update+0x104>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8000986:	68ca      	ldr	r2, [r1, #12]
 8000988:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800098c:	4313      	orrs	r3, r2
 800098e:	60cb      	str	r3, [r1, #12]
 8000990:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8000994:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8000996:	e7fd      	b.n	8000994 <CM0_Update+0x64>
  else if ((CMO_UPDATE_PROCESS == CM0_UPDATE_TO_BE_STARTED) ||
 8000998:	42b5      	cmp	r5, r6
 800099a:	d002      	beq.n	80009a2 <CM0_Update+0x72>
 800099c:	4b26      	ldr	r3, [pc, #152]	; (8000a38 <CM0_Update+0x108>)
 800099e:	429d      	cmp	r5, r3
 80009a0:	d12d      	bne.n	80009fe <CM0_Update+0xce>
  fus_state_value = SHCI_C2_FUS_GetState(NULL);
 80009a2:	2000      	movs	r0, #0
 80009a4:	f001 fe5a 	bl	800265c <SHCI_C2_FUS_GetState>
  switch(fus_state_value)
 80009a8:	4601      	mov	r1, r0
 80009aa:	b178      	cbz	r0, 80009cc <CM0_Update+0x9c>
 80009ac:	28ff      	cmp	r0, #255	; 0xff
 80009ae:	d008      	beq.n	80009c2 <CM0_Update+0x92>
        WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
 80009b0:	4c1e      	ldr	r4, [pc, #120]	; (8000a2c <CM0_Update+0xfc>)
 80009b2:	f64a 25aa 	movw	r5, #43690	; 0xaaaa
        HAL_Delay(2000U);
 80009b6:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80009ba:	f001 fe41 	bl	8002640 <HAL_Delay>
        WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
 80009be:	6025      	str	r5, [r4, #0]
      while(1)
 80009c0:	e7f9      	b.n	80009b6 <CM0_Update+0x86>
      CMO_UPDATE_PROCESS = CM0_UPDATE_DONE;
 80009c2:	4b1e      	ldr	r3, [pc, #120]	; (8000a3c <CM0_Update+0x10c>)
 80009c4:	6063      	str	r3, [r4, #4]
      STANDALONE_LOADER_STATE = STANDALONE_LOADER_NO_REQ;
 80009c6:	2300      	movs	r3, #0
 80009c8:	603b      	str	r3, [r7, #0]
 80009ca:	e7c0      	b.n	800094e <CM0_Update+0x1e>
      if (CMO_UPDATE_PROCESS == CM0_UPDATE_TO_BE_STARTED)
 80009cc:	6862      	ldr	r2, [r4, #4]
 80009ce:	4b1a      	ldr	r3, [pc, #104]	; (8000a38 <CM0_Update+0x108>)
 80009d0:	42b2      	cmp	r2, r6
 80009d2:	d116      	bne.n	8000a02 <CM0_Update+0xd2>
        CMO_UPDATE_PROCESS = CM0_UPDATE_IN_PROGRESS;
 80009d4:	6063      	str	r3, [r4, #4]
        SHCI_C2_FUS_FwUpgrade(0,0);
 80009d6:	f001 fe52 	bl	800267e <SHCI_C2_FUS_FwUpgrade>
          WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
 80009da:	4c14      	ldr	r4, [pc, #80]	; (8000a2c <CM0_Update+0xfc>)
 80009dc:	f64a 25aa 	movw	r5, #43690	; 0xaaaa
          HAL_Delay(4000U);
 80009e0:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 80009e4:	f001 fe2c 	bl	8002640 <HAL_Delay>
          WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
 80009e8:	6025      	str	r5, [r4, #0]
          fus_state_value = SHCI_C2_FUS_GetState(&error);
 80009ea:	f10d 0007 	add.w	r0, sp, #7
 80009ee:	f001 fe35 	bl	800265c <SHCI_C2_FUS_GetState>
          if (error != FUS_STATE_ERROR_NO_ERROR)
 80009f2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80009f6:	2b00      	cmp	r3, #0
 80009f8:	d0f2      	beq.n	80009e0 <CM0_Update+0xb0>
            STANDALONE_LOADER_STATE = STANDALONE_LOADER_NO_REQ;
 80009fa:	2300      	movs	r3, #0
 80009fc:	603b      	str	r3, [r7, #0]
    e_ret_status = SE_ERROR;
 80009fe:	4810      	ldr	r0, [pc, #64]	; (8000a40 <CM0_Update+0x110>)
  return e_ret_status;
 8000a00:	e7a6      	b.n	8000950 <CM0_Update+0x20>
      else if (CMO_UPDATE_PROCESS == CM0_UPDATE_IN_PROGRESS)
 8000a02:	429a      	cmp	r2, r3
 8000a04:	d1f9      	bne.n	80009fa <CM0_Update+0xca>
        SHCI_C2_FUS_StartWs();
 8000a06:	f001 fe5d 	bl	80026c4 <SHCI_C2_FUS_StartWs>
          WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
 8000a0a:	4c08      	ldr	r4, [pc, #32]	; (8000a2c <CM0_Update+0xfc>)
 8000a0c:	f64a 25aa 	movw	r5, #43690	; 0xaaaa
          HAL_Delay(2000U);
 8000a10:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8000a14:	f001 fe14 	bl	8002640 <HAL_Delay>
          WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
 8000a18:	6025      	str	r5, [r4, #0]
        while(1)
 8000a1a:	e7f9      	b.n	8000a10 <CM0_Update+0xe0>
 8000a1c:	20001000 	.word	0x20001000
 8000a20:	375aa32c 	.word	0x375aa32c
 8000a24:	0012310f 	.word	0x0012310f
 8000a28:	df23ac61 	.word	0xdf23ac61
 8000a2c:	40003000 	.word	0x40003000
 8000a30:	e000ed00 	.word	0xe000ed00
 8000a34:	05fa0004 	.word	0x05fa0004
 8000a38:	98fca513 	.word	0x98fca513
 8000a3c:	f234b97a 	.word	0xf234b97a
 8000a40:	00018799 	.word	0x00018799

08000a44 <SE_CRYPTO_Decrypt_Init>:
  * @param SE_FwType: Type of Fw Image.
  *        This parameter can be SE_FW_IMAGE_COMPLETE or SE_FW_IMAGE_PARTIAL.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_CRYPTO_Decrypt_Init(SE_FwRawHeaderTypeDef *pxSE_Metadata, uint32_t SE_FwType)
{
 8000a44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#else
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_CRYPTO_SCHEME == SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM */

  /* Check the pointers allocation */
  if (pxSE_Metadata == NULL)
 8000a46:	4604      	mov	r4, r0
 8000a48:	b910      	cbnz	r0, 8000a50 <SE_CRYPTO_Decrypt_Init+0xc>
  {
    return SE_ERROR;
 8000a4a:	4d24      	ldr	r5, [pc, #144]	; (8000adc <SE_CRYPTO_Decrypt_Init+0x98>)
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_CRYPTO_SCHEME */

  /* Return status*/
  return e_ret_status;
}
 8000a4c:	4628      	mov	r0, r5
 8000a4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  hcryp1.Instance = AES1;
 8000a50:	4d23      	ldr	r5, [pc, #140]	; (8000ae0 <SE_CRYPTO_Decrypt_Init+0x9c>)
 8000a52:	4b24      	ldr	r3, [pc, #144]	; (8000ae4 <SE_CRYPTO_Decrypt_Init+0xa0>)
 8000a54:	602b      	str	r3, [r5, #0]
  if (HAL_CRYP_DeInit(&hcryp1) != HAL_OK)
 8000a56:	4628      	mov	r0, r5
 8000a58:	f000 fd1d 	bl	8001496 <HAL_CRYP_DeInit>
 8000a5c:	462b      	mov	r3, r5
 8000a5e:	2800      	cmp	r0, #0
 8000a60:	d1f3      	bne.n	8000a4a <SE_CRYPTO_Decrypt_Init+0x6>
  hcryp1.Init.DataType = CRYP_DATATYPE_8B;
 8000a62:	2204      	movs	r2, #4
 8000a64:	606a      	str	r2, [r5, #4]
  hcryp1.Init.KeySize = CRYP_KEYSIZE_128B;
 8000a66:	60a8      	str	r0, [r5, #8]
  hcryp1.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 8000a68:	2201      	movs	r2, #1
  hcryp1.Init.Algorithm = CRYP_AES_CBC;
 8000a6a:	2120      	movs	r1, #32
  hcryp1.Init.pKey = NULL;  /* Key loaded by CPU2 */
 8000a6c:	60e8      	str	r0, [r5, #12]
 8000a6e:	f105 0060 	add.w	r0, r5, #96	; 0x60
  hcryp1.Init.Algorithm = CRYP_AES_CBC;
 8000a72:	6169      	str	r1, [r5, #20]
  hcryp1.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 8000a74:	626a      	str	r2, [r5, #36]	; 0x24
  hcryp1.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 8000a76:	62ea      	str	r2, [r5, #44]	; 0x2c
  for (i = 0U; i < 4U; i ++)
 8000a78:	4621      	mov	r1, r4
 8000a7a:	f104 0610 	add.w	r6, r4, #16
 8000a7e:	4605      	mov	r5, r0
    m_aSE_AesIV[i] = pxSE_Metadata->InitVector[j] << 24    | pxSE_Metadata->InitVector[j + 1] << 16 | \
 8000a80:	f891 2055 	ldrb.w	r2, [r1, #85]	; 0x55
 8000a84:	f891 7054 	ldrb.w	r7, [r1, #84]	; 0x54
 8000a88:	0412      	lsls	r2, r2, #16
                     pxSE_Metadata->InitVector[j + 2] << 8 | pxSE_Metadata->InitVector[j + 3];
 8000a8a:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
 8000a8e:	f891 7057 	ldrb.w	r7, [r1, #87]	; 0x57
 8000a92:	433a      	orrs	r2, r7
 8000a94:	f891 7056 	ldrb.w	r7, [r1, #86]	; 0x56
 8000a98:	3104      	adds	r1, #4
 8000a9a:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
  for (i = 0U; i < 4U; i ++)
 8000a9e:	428e      	cmp	r6, r1
    m_aSE_AesIV[i] = pxSE_Metadata->InitVector[j] << 24    | pxSE_Metadata->InitVector[j + 1] << 16 | \
 8000aa0:	f840 2b04 	str.w	r2, [r0], #4
  for (i = 0U; i < 4U; i ++)
 8000aa4:	d1ec      	bne.n	8000a80 <SE_CRYPTO_Decrypt_Init+0x3c>
  if (HAL_CRYP_Init(&hcryp1) == HAL_OK)
 8000aa6:	480e      	ldr	r0, [pc, #56]	; (8000ae0 <SE_CRYPTO_Decrypt_Init+0x9c>)
  hcryp1.Init.pInitVect = m_aSE_AesIV;
 8000aa8:	611d      	str	r5, [r3, #16]
  if (HAL_CRYP_Init(&hcryp1) == HAL_OK)
 8000aaa:	f000 fcd1 	bl	8001450 <HAL_CRYP_Init>
    e_ret_status = SE_ERROR;
 8000aae:	4d0b      	ldr	r5, [pc, #44]	; (8000adc <SE_CRYPTO_Decrypt_Init+0x98>)
 8000ab0:	4b0d      	ldr	r3, [pc, #52]	; (8000ae8 <SE_CRYPTO_Decrypt_Init+0xa4>)
  if (memcmp(pxSE_Metadata->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
 8000ab2:	490e      	ldr	r1, [pc, #56]	; (8000aec <SE_CRYPTO_Decrypt_Init+0xa8>)
    e_ret_status = SE_ERROR;
 8000ab4:	2800      	cmp	r0, #0
 8000ab6:	bf08      	it	eq
 8000ab8:	461d      	moveq	r5, r3
  if (memcmp(pxSE_Metadata->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
 8000aba:	2204      	movs	r2, #4
 8000abc:	4620      	mov	r0, r4
 8000abe:	f002 fa17 	bl	8002ef0 <memcmp>
 8000ac2:	2800      	cmp	r0, #0
 8000ac4:	d1c2      	bne.n	8000a4c <SE_CRYPTO_Decrypt_Init+0x8>
  HAL_NVIC_EnableIRQ(IPCC_C1_RX_IRQn);
 8000ac6:	202c      	movs	r0, #44	; 0x2c
 8000ac8:	f000 fb12 	bl	80010f0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_EnableIRQ(IPCC_C1_TX_IRQn);
 8000acc:	202d      	movs	r0, #45	; 0x2d
 8000ace:	f000 fb0f 	bl	80010f0 <HAL_NVIC_EnableIRQ>
  SHCI_C2_FUS_LoadUsrKey(SBSFU_AES_KEY_IDX + key);
 8000ad2:	2001      	movs	r0, #1
 8000ad4:	f001 fde7 	bl	80026a6 <SHCI_C2_FUS_LoadUsrKey>
 8000ad8:	e7b8      	b.n	8000a4c <SE_CRYPTO_Decrypt_Init+0x8>
 8000ada:	bf00      	nop
 8000adc:	00018799 	.word	0x00018799
 8000ae0:	20000440 	.word	0x20000440
 8000ae4:	50060000 	.word	0x50060000
 8000ae8:	0012310f 	.word	0x0012310f
 8000aec:	08003270 	.word	0x08003270

08000af0 <SE_CRYPTO_Decrypt_Append>:
  * @param pOutputSize: pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_CRYPTO_Decrypt_Append(const uint8_t *pInputBuffer, int32_t InputSize, uint8_t *pOutputBuffer,
                                        int32_t *pOutputSize)
{
 8000af0:	b507      	push	{r0, r1, r2, lr}
  SE_ErrorStatus e_ret_status;

  /* DecryptImageInDwlSlot() always starts by calling the Decrypt service with a 0 byte buffer */
  if (0 == InputSize)
 8000af2:	b191      	cbz	r1, 8000b1a <SE_CRYPTO_Decrypt_Append+0x2a>
    /* Nothing to do but we must return a success for the decrypt operation to continue */
    return (SE_SUCCESS);
  }

  /* Check the pointers allocation */
  if ((pInputBuffer == NULL) || (pOutputBuffer == NULL) || (pOutputSize == NULL))
 8000af4:	b918      	cbnz	r0, 8000afe <SE_CRYPTO_Decrypt_Append+0xe>
  {
    return SE_ERROR;
 8000af6:	480a      	ldr	r0, [pc, #40]	; (8000b20 <SE_CRYPTO_Decrypt_Append+0x30>)
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_CRYPTO_SCHEME */

  /* Return status*/
  return e_ret_status;
}
 8000af8:	b003      	add	sp, #12
 8000afa:	f85d fb04 	ldr.w	pc, [sp], #4
  if ((pInputBuffer == NULL) || (pOutputBuffer == NULL) || (pOutputSize == NULL))
 8000afe:	2a00      	cmp	r2, #0
 8000b00:	d0f9      	beq.n	8000af6 <SE_CRYPTO_Decrypt_Append+0x6>
 8000b02:	2b00      	cmp	r3, #0
 8000b04:	d0f7      	beq.n	8000af6 <SE_CRYPTO_Decrypt_Append+0x6>
  if (HAL_CRYP_Decrypt(&hcryp1, (uint32_t *)pInputBuffer, InputSize, (uint32_t *)pOutputBuffer,
 8000b06:	23ff      	movs	r3, #255	; 0xff
 8000b08:	9300      	str	r3, [sp, #0]
 8000b0a:	4613      	mov	r3, r2
 8000b0c:	b28a      	uxth	r2, r1
 8000b0e:	4601      	mov	r1, r0
 8000b10:	4804      	ldr	r0, [pc, #16]	; (8000b24 <SE_CRYPTO_Decrypt_Append+0x34>)
 8000b12:	f000 ff15 	bl	8001940 <HAL_CRYP_Decrypt>
 8000b16:	2800      	cmp	r0, #0
 8000b18:	d1ed      	bne.n	8000af6 <SE_CRYPTO_Decrypt_Append+0x6>
    e_ret_status = SE_SUCCESS;
 8000b1a:	4803      	ldr	r0, [pc, #12]	; (8000b28 <SE_CRYPTO_Decrypt_Append+0x38>)
 8000b1c:	e7ec      	b.n	8000af8 <SE_CRYPTO_Decrypt_Append+0x8>
 8000b1e:	bf00      	nop
 8000b20:	00018799 	.word	0x00018799
 8000b24:	20000440 	.word	0x20000440
 8000b28:	0012310f 	.word	0x0012310f

08000b2c <SE_CRYPTO_Decrypt_Finish>:
  * @param pOutputBuffer: pointer to Output Buffer.
  * @param pOutputSize: pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_CRYPTO_Decrypt_Finish(uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8000b2c:	b508      	push	{r3, lr}
#elif (SECBOOT_CRYPTO_SCHEME == SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM)
  uint32_t i;
#endif /* SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256 */

  /* Check the pointers allocation */
  if ((pOutputBuffer == NULL) || (pOutputSize == NULL))
 8000b2e:	b128      	cbz	r0, 8000b3c <SE_CRYPTO_Decrypt_Finish+0x10>
 8000b30:	b121      	cbz	r1, 8000b3c <SE_CRYPTO_Decrypt_Finish+0x10>
  }
  HAL_CRYP_DeInit(&hcryp1);

#elif (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256)
  /* HAL function call to deinitialize HW crypto peripheral */
  HAL_CRYP_DeInit(&hcryp1);
 8000b32:	4803      	ldr	r0, [pc, #12]	; (8000b40 <SE_CRYPTO_Decrypt_Finish+0x14>)
 8000b34:	f000 fcaf 	bl	8001496 <HAL_CRYP_DeInit>

  /* Clean-up the key in RAM */
  SE_CLEAN_UP_FW_KEY();

  /* Return status*/
  return e_ret_status;
 8000b38:	4802      	ldr	r0, [pc, #8]	; (8000b44 <SE_CRYPTO_Decrypt_Finish+0x18>)
}
 8000b3a:	bd08      	pop	{r3, pc}
    return e_ret_status;
 8000b3c:	4802      	ldr	r0, [pc, #8]	; (8000b48 <SE_CRYPTO_Decrypt_Finish+0x1c>)
 8000b3e:	e7fc      	b.n	8000b3a <SE_CRYPTO_Decrypt_Finish+0xe>
 8000b40:	20000440 	.word	0x20000440
 8000b44:	0012310f 	.word	0x0012310f
 8000b48:	00018799 	.word	0x00018799

08000b4c <SE_CRYPTO_AuthenticateFW_Init>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(pxSE_Metadata);
  UNUSED(SE_FwType);

  /* Set the size of the desired hash digest: SHA-256 */
  m_SHA256ctx.mTagSize = CRL_SHA256_SIZE;
 8000b4c:	4808      	ldr	r0, [pc, #32]	; (8000b70 <SE_CRYPTO_AuthenticateFW_Init+0x24>)
{
 8000b4e:	b508      	push	{r3, lr}
  m_SHA256ctx.mTagSize = CRL_SHA256_SIZE;
 8000b50:	2320      	movs	r3, #32
 8000b52:	6783      	str	r3, [r0, #120]	; 0x78

  /* Set flag field to default value */
  m_SHA256ctx.mFlags = E_HASH_DEFAULT;
 8000b54:	2300      	movs	r3, #0
 8000b56:	f880 3074 	strb.w	r3, [r0, #116]	; 0x74

  /* Initialize the HASH context */
  error_status = SHA256_Init(&m_SHA256ctx);
 8000b5a:	3070      	adds	r0, #112	; 0x70
 8000b5c:	f002 f908 	bl	8002d70 <SHA256_Init>
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_CRYPTO_SCHEME */

  /* Return status*/
  return e_ret_status;
}
 8000b60:	4a04      	ldr	r2, [pc, #16]	; (8000b74 <SE_CRYPTO_AuthenticateFW_Init+0x28>)
 8000b62:	4b05      	ldr	r3, [pc, #20]	; (8000b78 <SE_CRYPTO_AuthenticateFW_Init+0x2c>)
 8000b64:	2800      	cmp	r0, #0
 8000b66:	bf0c      	ite	eq
 8000b68:	4610      	moveq	r0, r2
 8000b6a:	4618      	movne	r0, r3
 8000b6c:	bd08      	pop	{r3, pc}
 8000b6e:	bf00      	nop
 8000b70:	20000440 	.word	0x20000440
 8000b74:	0012310f 	.word	0x0012310f
 8000b78:	00018799 	.word	0x00018799

08000b7c <SE_CRYPTO_AuthenticateFW_Append>:
  * @param pOutputSize: pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_CRYPTO_AuthenticateFW_Append(const uint8_t *pInputBuffer, int32_t InputSize, uint8_t *pOutputBuffer,
                                               int32_t *pOutputSize)
{
 8000b7c:	b508      	push	{r3, lr}
 8000b7e:	460a      	mov	r2, r1
  /* The parameters below are useless for the HASH but are needed for API compatibility with other procedures */
  (void)pOutputBuffer;
  (void)pOutputSize;

  /* Add data to be hashed */
  error_status = SHA256_Append(&m_SHA256ctx, pInputBuffer, InputSize);
 8000b80:	4601      	mov	r1, r0
 8000b82:	4805      	ldr	r0, [pc, #20]	; (8000b98 <SE_CRYPTO_AuthenticateFW_Append+0x1c>)
 8000b84:	f002 f8b8 	bl	8002cf8 <SHA256_Append>
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_CRYPTO_SCHEME */

  /* Return status*/
  return e_ret_status;
}
 8000b88:	4a04      	ldr	r2, [pc, #16]	; (8000b9c <SE_CRYPTO_AuthenticateFW_Append+0x20>)
 8000b8a:	4b05      	ldr	r3, [pc, #20]	; (8000ba0 <SE_CRYPTO_AuthenticateFW_Append+0x24>)
 8000b8c:	2800      	cmp	r0, #0
 8000b8e:	bf0c      	ite	eq
 8000b90:	4610      	moveq	r0, r2
 8000b92:	4618      	movne	r0, r3
 8000b94:	bd08      	pop	{r3, pc}
 8000b96:	bf00      	nop
 8000b98:	200004b0 	.word	0x200004b0
 8000b9c:	0012310f 	.word	0x0012310f
 8000ba0:	00018799 	.word	0x00018799

08000ba4 <SE_CRYPTO_AuthenticateFW_Finish>:
  * @param pOutputBuffer: pointer to Output Buffer.
  * @param pOutputSize: pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_CRYPTO_AuthenticateFW_Finish(uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8000ba4:	b508      	push	{r3, lr}
 8000ba6:	460a      	mov	r2, r1
  e_ret_status = SE_CRYPTO_Encrypt_Finish(pOutputBuffer, pOutputSize);
#elif ( (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITHOUT_ENCRYPT_SHA256) )
  int32_t error_status;

  /* Add data to be hashed */
  error_status = SHA256_Finish(&m_SHA256ctx, pOutputBuffer, pOutputSize);
 8000ba8:	4601      	mov	r1, r0
 8000baa:	4805      	ldr	r0, [pc, #20]	; (8000bc0 <SE_CRYPTO_AuthenticateFW_Finish+0x1c>)
 8000bac:	f002 f97a 	bl	8002ea4 <SHA256_Finish>
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_CRYPTO_SCHEME */

  /* Return status*/
  return e_ret_status;
}
 8000bb0:	4a04      	ldr	r2, [pc, #16]	; (8000bc4 <SE_CRYPTO_AuthenticateFW_Finish+0x20>)
 8000bb2:	4b05      	ldr	r3, [pc, #20]	; (8000bc8 <SE_CRYPTO_AuthenticateFW_Finish+0x24>)
 8000bb4:	2800      	cmp	r0, #0
 8000bb6:	bf0c      	ite	eq
 8000bb8:	4610      	moveq	r0, r2
 8000bba:	4618      	movne	r0, r3
 8000bbc:	bd08      	pop	{r3, pc}
 8000bbe:	bf00      	nop
 8000bc0:	200004b0 	.word	0x200004b0
 8000bc4:	0012310f 	.word	0x0012310f
 8000bc8:	00018799 	.word	0x00018799

08000bcc <SE_CRYPTO_Authenticate_Metadata>:
  *        Authenticates the header containing the Firmware metadata.
  * @param pxSE_Metadata: Firmware metadata.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_CRYPTO_Authenticate_Metadata(SE_FwRawHeaderTypeDef *pxSE_Metadata)
{
 8000bcc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000bd0:	b0b5      	sub	sp, #212	; 0xd4
 8000bd2:	4604      	mov	r4, r0
    * Local variables for authentication procedure.
    */
#if (SECBOOT_CRYPTO_SCHEME == SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM)
#elif ( (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITHOUT_ENCRYPT_SHA256) )
  int32_t status;
  PKA_ECDSAVerifInTypeDef ECDSA_verif = {0};
 8000bd4:	2234      	movs	r2, #52	; 0x34
 8000bd6:	2100      	movs	r1, #0
 8000bd8:	a80a      	add	r0, sp, #40	; 0x28
 8000bda:	f002 f9a5 	bl	8002f28 <memset>
  uint8_t *pSign;             /* Reference MAC (ECCDSA signed SHA256 of the FW metadata) */
  const uint8_t *pPub_x;
  const uint8_t *pPub_y;
  /* buffer for sha256 computing */
  uint8_t MessageDigest[CRL_SHA256_SIZE];
  int32_t MessageDigestLength = 0;
 8000bde:	2300      	movs	r3, #0
 8000be0:	9301      	str	r3, [sp, #4]
  /* the key to be used for crypto operations (as this is a pointer to m_aSE_FirmwareKey or m_aSE_PubKey it can be a
     local variable, the pointed data is protected) */
  uint8_t *pKey;
#endif /* SECBOOT_CRYPTO_SCHEME */

  if (NULL == pxSE_Metadata)
 8000be2:	2c00      	cmp	r4, #0
 8000be4:	f000 80a2 	beq.w	8000d2c <SE_CRYPTO_Authenticate_Metadata+0x160>
  if (memcmp(pxSE_Metadata->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
 8000be8:	4951      	ldr	r1, [pc, #324]	; (8000d30 <SE_CRYPTO_Authenticate_Metadata+0x164>)
 8000bea:	2204      	movs	r2, #4
 8000bec:	4620      	mov	r0, r4
 8000bee:	f002 f97f 	bl	8002ef0 <memcmp>
 8000bf2:	b910      	cbnz	r0, 8000bfa <SE_CRYPTO_Authenticate_Metadata+0x2e>
    SE_ReadKey_1_Pub(paSE_PubKey);
 8000bf4:	484f      	ldr	r0, [pc, #316]	; (8000d34 <SE_CRYPTO_Authenticate_Metadata+0x168>)
 8000bf6:	f7ff fc18 	bl	800042a <SE_ReadKey_1_Pub>
  P_pSHA256ctx.mFlags = E_HASH_DEFAULT;
 8000bfa:	2300      	movs	r3, #0
  P_pSHA256ctx.mTagSize = CRL_SHA256_SIZE;
 8000bfc:	2620      	movs	r6, #32
  error_status = SHA256_Init(&P_pSHA256ctx);
 8000bfe:	a817      	add	r0, sp, #92	; 0x5c
  P_pSHA256ctx.mTagSize = CRL_SHA256_SIZE;
 8000c00:	9619      	str	r6, [sp, #100]	; 0x64
  P_pSHA256ctx.mFlags = E_HASH_DEFAULT;
 8000c02:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
  error_status = SHA256_Init(&P_pSHA256ctx);
 8000c06:	f002 f8b3 	bl	8002d70 <SHA256_Init>
  if (error_status == HASH_SUCCESS)
 8000c0a:	f8df 9128 	ldr.w	r9, [pc, #296]	; 8000d34 <SE_CRYPTO_Authenticate_Metadata+0x168>
 8000c0e:	2800      	cmp	r0, #0
 8000c10:	f040 808a 	bne.w	8000d28 <SE_CRYPTO_Authenticate_Metadata+0x15c>
    error_status = SHA256_Append(&P_pSHA256ctx,
 8000c14:	2280      	movs	r2, #128	; 0x80
 8000c16:	4621      	mov	r1, r4
 8000c18:	a817      	add	r0, sp, #92	; 0x5c
 8000c1a:	f002 f86d 	bl	8002cf8 <SHA256_Append>
    if (error_status == HASH_SUCCESS)
 8000c1e:	2800      	cmp	r0, #0
 8000c20:	f040 8082 	bne.w	8000d28 <SE_CRYPTO_Authenticate_Metadata+0x15c>
      error_status = SHA256_Finish(&P_pSHA256ctx, MessageDigest, MessageDigestLength);
 8000c24:	f10d 0808 	add.w	r8, sp, #8
 8000c28:	aa01      	add	r2, sp, #4
 8000c2a:	4641      	mov	r1, r8
 8000c2c:	a817      	add	r0, sp, #92	; 0x5c
 8000c2e:	f002 f939 	bl	8002ea4 <SHA256_Finish>
  status = SE_CRYPTO_SHA256_HASH_DigestCompute(pPayload,
                                               payloadSize,
                                               (uint8_t *)MessageDigest,
                                               &MessageDigestLength);

  if (status == HASH_SUCCESS)
 8000c32:	2800      	cmp	r0, #0
 8000c34:	d178      	bne.n	8000d28 <SE_CRYPTO_Authenticate_Metadata+0x15c>
  {
    /* HAL function call to initialize HW PKA and launch ECDSA verification */
    hpka.Instance = PKA;
    if (HAL_PKA_Init(&hpka) == HAL_OK)
 8000c36:	f109 0740 	add.w	r7, r9, #64	; 0x40
    hpka.Instance = PKA;
 8000c3a:	4b3f      	ldr	r3, [pc, #252]	; (8000d38 <SE_CRYPTO_Authenticate_Metadata+0x16c>)
 8000c3c:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
    if (HAL_PKA_Init(&hpka) == HAL_OK)
 8000c40:	4638      	mov	r0, r7
 8000c42:	f001 f849 	bl	8001cd8 <HAL_PKA_Init>
 8000c46:	2800      	cmp	r0, #0
 8000c48:	d135      	bne.n	8000cb6 <SE_CRYPTO_Authenticate_Metadata+0xea>
    {
      /* Set input parameters */
      ECDSA_verif.primeOrderSize =  sizeof(P_256_n);
      ECDSA_verif.modulusSize =     sizeof(P_256_p);
      ECDSA_verif.coefSign =        P_256_a_sign;
 8000c4a:	2301      	movs	r3, #1
 8000c4c:	930c      	str	r3, [sp, #48]	; 0x30
      ECDSA_verif.coef =            P_256_absA;
 8000c4e:	4b3b      	ldr	r3, [pc, #236]	; (8000d3c <SE_CRYPTO_Authenticate_Metadata+0x170>)
 8000c50:	930d      	str	r3, [sp, #52]	; 0x34
      ECDSA_verif.modulus =         P_256_p;
 8000c52:	199a      	adds	r2, r3, r6
 8000c54:	920e      	str	r2, [sp, #56]	; 0x38
      ECDSA_verif.basePointX =      P_256_Gx;
 8000c56:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8000c5a:	920f      	str	r2, [sp, #60]	; 0x3c
      ECDSA_verif.basePointY =      P_256_Gy;
 8000c5c:	f103 0260 	add.w	r2, r3, #96	; 0x60
      ECDSA_verif.primeOrder =      P_256_n;
 8000c60:	3380      	adds	r3, #128	; 0x80
 8000c62:	9316      	str	r3, [sp, #88]	; 0x58

      ECDSA_verif.pPubKeyCurvePtX = pPub_x;
      ECDSA_verif.pPubKeyCurvePtY = pPub_y;
 8000c64:	eb09 0306 	add.w	r3, r9, r6
 8000c68:	9312      	str	r3, [sp, #72]	; 0x48
  pSign = pxSE_Metadata->HeaderSignature;
 8000c6a:	f104 0380 	add.w	r3, r4, #128	; 0x80
      ECDSA_verif.basePointY =      P_256_Gy;
 8000c6e:	9210      	str	r2, [sp, #64]	; 0x40
      ECDSA_verif.RSign =           pSign_r;
 8000c70:	9313      	str	r3, [sp, #76]	; 0x4c
      ECDSA_verif.SSign =           pSign_s;
      ECDSA_verif.hash =            MessageDigest;

      /* Launch the verification */
      if (HAL_PKA_ECDSAVerif(&hpka, &ECDSA_verif, HAL_PKA_TIMEOUT) == HAL_OK)
 8000c72:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
  pSign_s = (uint8_t *)(pSign + 32);
 8000c76:	f104 03a0 	add.w	r3, r4, #160	; 0xa0
      if (HAL_PKA_ECDSAVerif(&hpka, &ECDSA_verif, HAL_PKA_TIMEOUT) == HAL_OK)
 8000c7a:	a90a      	add	r1, sp, #40	; 0x28
 8000c7c:	4638      	mov	r0, r7
      ECDSA_verif.modulusSize =     sizeof(P_256_p);
 8000c7e:	e9cd 660a 	strd	r6, r6, [sp, #40]	; 0x28
      ECDSA_verif.hash =            MessageDigest;
 8000c82:	e9cd 3814 	strd	r3, r8, [sp, #80]	; 0x50
      ECDSA_verif.pPubKeyCurvePtX = pPub_x;
 8000c86:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
      if (HAL_PKA_ECDSAVerif(&hpka, &ECDSA_verif, HAL_PKA_TIMEOUT) == HAL_OK)
 8000c8a:	f001 f9a5 	bl	8001fd8 <HAL_PKA_ECDSAVerif>
 8000c8e:	4606      	mov	r6, r0
 8000c90:	b988      	cbnz	r0, 8000cb6 <SE_CRYPTO_Authenticate_Metadata+0xea>
      {
        /* Compare to expected result */
        if (HAL_PKA_ECDSAVerif_IsValidSignature(&hpka) == 1)
 8000c92:	4638      	mov	r0, r7
 8000c94:	f001 f84a 	bl	8001d2c <HAL_PKA_ECDSAVerif_IsValidSignature>
 8000c98:	2801      	cmp	r0, #1
 8000c9a:	d10c      	bne.n	8000cb6 <SE_CRYPTO_Authenticate_Metadata+0xea>
  uint8_t* p_sign_PKA = (uint8_t*) &hpka.Instance->RAM[PKA_ECDSA_VERIF_OUT_SIGNATURE_R];
 8000c9c:	f8d9 0040 	ldr.w	r0, [r9, #64]	; 0x40
 8000ca0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  __IO uint8_t result = 0x00U;
 8000ca2:	f88d 605c 	strb.w	r6, [sp, #92]	; 0x5c
  for (i = 0U, j = Size - 1U; i < Size; i++, j--)
 8000ca6:	347f      	adds	r4, #127	; 0x7f
 8000ca8:	4403      	add	r3, r0
 8000caa:	4298      	cmp	r0, r3
 8000cac:	d12c      	bne.n	8000d08 <SE_CRYPTO_Authenticate_Metadata+0x13c>
  if ((result == IMAGE_VALID) && (i == Size))
 8000cae:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
 8000cb2:	2b55      	cmp	r3, #85	; 0x55
 8000cb4:	d036      	beq.n	8000d24 <SE_CRYPTO_Authenticate_Metadata+0x158>
    return SE_ERROR;
 8000cb6:	4c22      	ldr	r4, [pc, #136]	; (8000d40 <SE_CRYPTO_Authenticate_Metadata+0x174>)
          e_ret_status = SE_CRYPTO_SHA256_CheckPKASignature((uint8_t *) pSign_r, ECDSA_verif.primeOrderSize);
        }
      }
    }
    /* HAL function call to deinitialize HW PKA peripheral */
    HAL_PKA_DeInit(&hpka);
 8000cb8:	4822      	ldr	r0, [pc, #136]	; (8000d44 <SE_CRYPTO_Authenticate_Metadata+0x178>)
 8000cba:	f001 f823 	bl	8001d04 <HAL_PKA_DeInit>
#if (SECBOOT_CRYPTO_SCHEME == SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM)
  /* Symmetric key */
  SE_CLEAN_UP_FW_KEY();
#else
  /* ECC public key */
  SE_CLEAN_UP_PUB_KEY();
 8000cbe:	4822      	ldr	r0, [pc, #136]	; (8000d48 <SE_CRYPTO_Authenticate_Metadata+0x17c>)
 8000cc0:	4922      	ldr	r1, [pc, #136]	; (8000d4c <SE_CRYPTO_Authenticate_Metadata+0x180>)
 8000cc2:	6883      	ldr	r3, [r0, #8]
 8000cc4:	f640 72ff 	movw	r2, #4095	; 0xfff
 8000cc8:	fbb3 f2f2 	udiv	r2, r3, r2
 8000ccc:	ebc2 3202 	rsb	r2, r2, r2, lsl #12
 8000cd0:	1a9b      	subs	r3, r3, r2
 8000cd2:	440b      	add	r3, r1
 8000cd4:	4a17      	ldr	r2, [pc, #92]	; (8000d34 <SE_CRYPTO_Authenticate_Metadata+0x168>)
 8000cd6:	f103 0540 	add.w	r5, r3, #64	; 0x40
 8000cda:	f853 6b04 	ldr.w	r6, [r3], #4
 8000cde:	f842 6b04 	str.w	r6, [r2], #4
 8000ce2:	42ab      	cmp	r3, r5
 8000ce4:	d1f9      	bne.n	8000cda <SE_CRYPTO_Authenticate_Metadata+0x10e>
 8000ce6:	6882      	ldr	r2, [r0, #8]
 8000ce8:	4819      	ldr	r0, [pc, #100]	; (8000d50 <SE_CRYPTO_Authenticate_Metadata+0x184>)
 8000cea:	f640 73ff 	movw	r3, #4095	; 0xfff
 8000cee:	fbb2 f3f3 	udiv	r3, r2, r3
 8000cf2:	ebc3 3303 	rsb	r3, r3, r3, lsl #12
 8000cf6:	1ad3      	subs	r3, r2, r3
 8000cf8:	4419      	add	r1, r3
 8000cfa:	2274      	movs	r2, #116	; 0x74
 8000cfc:	f002 f906 	bl	8002f0c <memcpy>
#endif /* SECBOOT_CRYPTO_SCHEME */

  /* Return status*/
  return e_ret_status;
}
 8000d00:	4620      	mov	r0, r4
 8000d02:	b035      	add	sp, #212	; 0xd4
 8000d04:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    result |= pSign[i] ^ IMAGE_VALID ^ p_sign_PKA[j];
 8000d08:	f893 555b 	ldrb.w	r5, [r3, #1371]	; 0x55b
 8000d0c:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 8000d10:	f89d 105c 	ldrb.w	r1, [sp, #92]	; 0x5c
 8000d14:	406a      	eors	r2, r5
 8000d16:	f082 0255 	eor.w	r2, r2, #85	; 0x55
 8000d1a:	430a      	orrs	r2, r1
 8000d1c:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
  for (i = 0U, j = Size - 1U; i < Size; i++, j--)
 8000d20:	3b01      	subs	r3, #1
 8000d22:	e7c2      	b.n	8000caa <SE_CRYPTO_Authenticate_Metadata+0xde>
    return SE_SUCCESS;
 8000d24:	4c0b      	ldr	r4, [pc, #44]	; (8000d54 <SE_CRYPTO_Authenticate_Metadata+0x188>)
 8000d26:	e7c7      	b.n	8000cb8 <SE_CRYPTO_Authenticate_Metadata+0xec>
  e_ret_status = SE_ERROR;
 8000d28:	4c05      	ldr	r4, [pc, #20]	; (8000d40 <SE_CRYPTO_Authenticate_Metadata+0x174>)
 8000d2a:	e7c8      	b.n	8000cbe <SE_CRYPTO_Authenticate_Metadata+0xf2>
    return e_ret_status;
 8000d2c:	4c04      	ldr	r4, [pc, #16]	; (8000d40 <SE_CRYPTO_Authenticate_Metadata+0x174>)
 8000d2e:	e7e7      	b.n	8000d00 <SE_CRYPTO_Authenticate_Metadata+0x134>
 8000d30:	08003270 	.word	0x08003270
 8000d34:	20000524 	.word	0x20000524
 8000d38:	58002000 	.word	0x58002000
 8000d3c:	08003140 	.word	0x08003140
 8000d40:	00018799 	.word	0x00018799
 8000d44:	20000564 	.word	0x20000564
 8000d48:	e000e010 	.word	0xe000e010
 8000d4c:	08000500 	.word	0x08000500
 8000d50:	200004b0 	.word	0x200004b0
 8000d54:	0012310f 	.word	0x0012310f

08000d58 <SE_CRYPTO_Lock_CKS_Keys>:
  * @brief Secure Engine lock and remove the keys from AES HW.
  * @param none.
  * @retval none.
  */
void SE_CRYPTO_Lock_CKS_Keys(void)
{
 8000d58:	b508      	push	{r3, lr}
  /* Lock the key 1 */
  HAL_NVIC_EnableIRQ(IPCC_C1_RX_IRQn);
 8000d5a:	202c      	movs	r0, #44	; 0x2c
 8000d5c:	f000 f9c8 	bl	80010f0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_EnableIRQ(IPCC_C1_TX_IRQn);
 8000d60:	202d      	movs	r0, #45	; 0x2d
 8000d62:	f000 f9c5 	bl	80010f0 <HAL_NVIC_EnableIRQ>
  SHCI_C2_FUS_LockUsrKey(SBSFU_AES_KEY_IDX);
 8000d66:	2001      	movs	r0, #1
 8000d68:	f001 fcb9 	bl	80026de <SHCI_C2_FUS_LockUsrKey>
  SET_BIT(RCC->AHB2RSTR, Periphs);
 8000d6c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000d70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000d72:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000d76:	62da      	str	r2, [r3, #44]	; 0x2c
  CLEAR_BIT(RCC->AHB2RSTR, Periphs);
 8000d78:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000d7a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000d7e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Unload the keys by resetting AES1 using AES1RST bit in RCC_AHB2RSTR
     As keys are locked they cannot be re-loaded */
  __HAL_RCC_AES1_FORCE_RESET();
  __HAL_RCC_AES1_RELEASE_RESET();
}
 8000d80:	bd08      	pop	{r3, pc}
	...

08000d84 <__NVIC_SystemReset>:
 8000d84:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8000d88:	4905      	ldr	r1, [pc, #20]	; (8000da0 <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8000d8a:	4b06      	ldr	r3, [pc, #24]	; (8000da4 <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8000d8c:	68ca      	ldr	r2, [r1, #12]
 8000d8e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8000d92:	4313      	orrs	r3, r2
 8000d94:	60cb      	str	r3, [r1, #12]
 8000d96:	f3bf 8f4f 	dsb	sy
    __NOP();
 8000d9a:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8000d9c:	e7fd      	b.n	8000d9a <__NVIC_SystemReset+0x16>
 8000d9e:	bf00      	nop
 8000da0:	e000ed00 	.word	0xe000ed00
 8000da4:	05fa0004 	.word	0x05fa0004

08000da8 <SE_LL_GetPage>:
  */
static uint32_t SE_LL_GetPage(uint32_t Address)
{
  uint32_t page;

  if (Address < (FLASH_BASE + (FLASH_BANK_SIZE)))
 8000da8:	4b07      	ldr	r3, [pc, #28]	; (8000dc8 <SE_LL_GetPage+0x20>)
 8000daa:	4a08      	ldr	r2, [pc, #32]	; (8000dcc <SE_LL_GetPage+0x24>)
 8000dac:	881b      	ldrh	r3, [r3, #0]
 8000dae:	ea02 2283 	and.w	r2, r2, r3, lsl #10
 8000db2:	f102 6100 	add.w	r1, r2, #134217728	; 0x8000000
 8000db6:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 8000dba:	4281      	cmp	r1, r0
  {
    /* Bank 1 */
    page = (Address - FLASH_BASE) / FLASH_PAGE_SIZE;
 8000dbc:	bf8e      	itee	hi
 8000dbe:	0b18      	lsrhi	r0, r3, #12
  }
  else
  {
    /* Bank 2 */
    page = (Address - (FLASH_BASE + (FLASH_BANK_SIZE))) / FLASH_PAGE_SIZE;
 8000dc0:	1a98      	subls	r0, r3, r2
 8000dc2:	0b00      	lsrls	r0, r0, #12
  }
  return page;
}
 8000dc4:	4770      	bx	lr
 8000dc6:	bf00      	nop
 8000dc8:	1fff75e0 	.word	0x1fff75e0
 8000dcc:	001ffc00 	.word	0x001ffc00

08000dd0 <SE_LL_CRC_Config>:
  CrcHandle.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
 8000dd0:	4809      	ldr	r0, [pc, #36]	; (8000df8 <SE_LL_CRC_Config+0x28>)
  CrcHandle.Instance = CRC;
 8000dd2:	4a0a      	ldr	r2, [pc, #40]	; (8000dfc <SE_LL_CRC_Config+0x2c>)
{
 8000dd4:	b508      	push	{r3, lr}
  CrcHandle.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
 8000dd6:	2300      	movs	r3, #0
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 8000dd8:	e9c0 3305 	strd	r3, r3, [r0, #20]
  CrcHandle.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 8000ddc:	8083      	strh	r3, [r0, #4]
  CrcHandle.InputDataFormat = CRC_INPUTDATA_FORMAT_WORDS;
 8000dde:	2303      	movs	r3, #3
  CrcHandle.Instance = CRC;
 8000de0:	6002      	str	r2, [r0, #0]
  CrcHandle.InputDataFormat = CRC_INPUTDATA_FORMAT_WORDS;
 8000de2:	6203      	str	r3, [r0, #32]
  if (HAL_CRC_Init(&CrcHandle) == HAL_OK)
 8000de4:	f000 f9a8 	bl	8001138 <HAL_CRC_Init>
}
 8000de8:	4a05      	ldr	r2, [pc, #20]	; (8000e00 <SE_LL_CRC_Config+0x30>)
 8000dea:	4b06      	ldr	r3, [pc, #24]	; (8000e04 <SE_LL_CRC_Config+0x34>)
 8000dec:	2800      	cmp	r0, #0
 8000dee:	bf14      	ite	ne
 8000df0:	4610      	movne	r0, r2
 8000df2:	4618      	moveq	r0, r3
 8000df4:	bd08      	pop	{r3, pc}
 8000df6:	bf00      	nop
 8000df8:	20000570 	.word	0x20000570
 8000dfc:	40023000 	.word	0x40023000
 8000e00:	00018799 	.word	0x00018799
 8000e04:	0012310f 	.word	0x0012310f

08000e08 <SE_LL_FLASH_Erase>:
{
 8000e08:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint32_t page_error = 0U;
 8000e0a:	2300      	movs	r3, #0
{
 8000e0c:	4606      	mov	r6, r0
 8000e0e:	460c      	mov	r4, r1
  uint32_t page_error = 0U;
 8000e10:	9300      	str	r3, [sp, #0]
  if (HAL_FLASH_Unlock() == HAL_OK)
 8000e12:	f000 fe65 	bl	8001ae0 <HAL_FLASH_Unlock>
 8000e16:	b9d8      	cbnz	r0, 8000e50 <SE_LL_FLASH_Erase+0x48>
    p_erase_init.TypeErase     = FLASH_TYPEERASE_PAGES;
 8000e18:	2302      	movs	r3, #2
    p_erase_init.Page          = SE_LL_GetPage(start);
 8000e1a:	4630      	mov	r0, r6
    p_erase_init.TypeErase     = FLASH_TYPEERASE_PAGES;
 8000e1c:	9301      	str	r3, [sp, #4]
    p_erase_init.Page          = SE_LL_GetPage(start);
 8000e1e:	f7ff ffc3 	bl	8000da8 <SE_LL_GetPage>
    p_erase_init.NbPages       = SE_LL_GetPage(start + Length - 1U) - p_erase_init.Page + 1U;
 8000e22:	3c01      	subs	r4, #1
    p_erase_init.Page          = SE_LL_GetPage(start);
 8000e24:	4605      	mov	r5, r0
 8000e26:	9002      	str	r0, [sp, #8]
    p_erase_init.NbPages       = SE_LL_GetPage(start + Length - 1U) - p_erase_init.Page + 1U;
 8000e28:	1930      	adds	r0, r6, r4
 8000e2a:	f7ff ffbd 	bl	8000da8 <SE_LL_GetPage>
 8000e2e:	1c43      	adds	r3, r0, #1
 8000e30:	1b5b      	subs	r3, r3, r5
    if (HAL_FLASHEx_Erase(&p_erase_init, &page_error) != HAL_OK)
 8000e32:	4669      	mov	r1, sp
 8000e34:	a801      	add	r0, sp, #4
    p_erase_init.NbPages       = SE_LL_GetPage(start + Length - 1U) - p_erase_init.Page + 1U;
 8000e36:	9303      	str	r3, [sp, #12]
    if (HAL_FLASHEx_Erase(&p_erase_init, &page_error) != HAL_OK)
 8000e38:	f000 fee6 	bl	8001c08 <HAL_FLASHEx_Erase>
      e_ret_status = SE_ERROR;
 8000e3c:	4c05      	ldr	r4, [pc, #20]	; (8000e54 <SE_LL_FLASH_Erase+0x4c>)
 8000e3e:	4b06      	ldr	r3, [pc, #24]	; (8000e58 <SE_LL_FLASH_Erase+0x50>)
 8000e40:	2800      	cmp	r0, #0
 8000e42:	bf08      	it	eq
 8000e44:	461c      	moveq	r4, r3
    (void)HAL_FLASH_Lock();
 8000e46:	f000 fe5d 	bl	8001b04 <HAL_FLASH_Lock>
}
 8000e4a:	4620      	mov	r0, r4
 8000e4c:	b004      	add	sp, #16
 8000e4e:	bd70      	pop	{r4, r5, r6, pc}
    e_ret_status = SE_ERROR;
 8000e50:	4c00      	ldr	r4, [pc, #0]	; (8000e54 <SE_LL_FLASH_Erase+0x4c>)
  return e_ret_status;
 8000e52:	e7fa      	b.n	8000e4a <SE_LL_FLASH_Erase+0x42>
 8000e54:	00018799 	.word	0x00018799
 8000e58:	0012310f 	.word	0x0012310f

08000e5c <SE_LL_FLASH_Write>:
{
 8000e5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000e5e:	4606      	mov	r6, r0
 8000e60:	460d      	mov	r5, r1
  if (Length == 0U)
 8000e62:	4617      	mov	r7, r2
 8000e64:	b912      	cbnz	r2, 8000e6c <SE_LL_FLASH_Write+0x10>
    return SE_ERROR;
 8000e66:	4c11      	ldr	r4, [pc, #68]	; (8000eac <SE_LL_FLASH_Write+0x50>)
}
 8000e68:	4620      	mov	r0, r4
 8000e6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8000e6c:	4b10      	ldr	r3, [pc, #64]	; (8000eb0 <SE_LL_FLASH_Write+0x54>)
 8000e6e:	4283      	cmp	r3, r0
 8000e70:	d8f9      	bhi.n	8000e66 <SE_LL_FLASH_Write+0xa>
        ((destination + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 8000e72:	1882      	adds	r2, r0, r2
 8000e74:	f503 7300 	add.w	r3, r3, #512	; 0x200
    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8000e78:	429a      	cmp	r2, r3
 8000e7a:	d8f4      	bhi.n	8000e66 <SE_LL_FLASH_Write+0xa>
  if (HAL_FLASH_Unlock() == HAL_OK)
 8000e7c:	f000 fe30 	bl	8001ae0 <HAL_FLASH_Unlock>
 8000e80:	4604      	mov	r4, r0
 8000e82:	2800      	cmp	r0, #0
 8000e84:	d1ef      	bne.n	8000e66 <SE_LL_FLASH_Write+0xa>
 8000e86:	3d08      	subs	r5, #8
 8000e88:	e007      	b.n	8000e9a <SE_LL_FLASH_Write+0x3e>
      if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (destination + i), *(uint64_t *)(source + i)) != HAL_OK)
 8000e8a:	e9f5 2302 	ldrd	r2, r3, [r5, #8]!
 8000e8e:	1931      	adds	r1, r6, r4
 8000e90:	2001      	movs	r0, #1
 8000e92:	f000 fe73 	bl	8001b7c <HAL_FLASH_Program>
 8000e96:	b930      	cbnz	r0, 8000ea6 <SE_LL_FLASH_Write+0x4a>
    for (i = 0U; i < Length; i += 8U)
 8000e98:	3408      	adds	r4, #8
 8000e9a:	42bc      	cmp	r4, r7
 8000e9c:	d3f5      	bcc.n	8000e8a <SE_LL_FLASH_Write+0x2e>
  SE_ErrorStatus ret = SE_SUCCESS;
 8000e9e:	4c05      	ldr	r4, [pc, #20]	; (8000eb4 <SE_LL_FLASH_Write+0x58>)
    (void)HAL_FLASH_Lock();
 8000ea0:	f000 fe30 	bl	8001b04 <HAL_FLASH_Lock>
 8000ea4:	e7e0      	b.n	8000e68 <SE_LL_FLASH_Write+0xc>
        ret = SE_ERROR;
 8000ea6:	4c01      	ldr	r4, [pc, #4]	; (8000eac <SE_LL_FLASH_Write+0x50>)
 8000ea8:	e7fa      	b.n	8000ea0 <SE_LL_FLASH_Write+0x44>
 8000eaa:	bf00      	nop
 8000eac:	00018799 	.word	0x00018799
 8000eb0:	08018000 	.word	0x08018000
 8000eb4:	0012310f 	.word	0x0012310f

08000eb8 <SE_LL_FLASH_Read>:
{
 8000eb8:	b530      	push	{r4, r5, lr}
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8000eba:	4c16      	ldr	r4, [pc, #88]	; (8000f14 <SE_LL_FLASH_Read+0x5c>)
 8000ebc:	428c      	cmp	r4, r1
 8000ebe:	d822      	bhi.n	8000f06 <SE_LL_FLASH_Read+0x4e>
        ((source + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 8000ec0:	188b      	adds	r3, r1, r2
 8000ec2:	f504 7400 	add.w	r4, r4, #512	; 0x200
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8000ec6:	429c      	cmp	r4, r3
 8000ec8:	bf34      	ite	cc
 8000eca:	2300      	movcc	r3, #0
 8000ecc:	2301      	movcs	r3, #1
    if ((source >= SlotStartAdd[SLOT_DWL_1 + i]) &&
 8000ece:	4c12      	ldr	r4, [pc, #72]	; (8000f18 <SE_LL_FLASH_Read+0x60>)
 8000ed0:	42a1      	cmp	r1, r4
 8000ed2:	d202      	bcs.n	8000eda <SE_LL_FLASH_Read+0x22>
  if (verified == 0U)
 8000ed4:	b92b      	cbnz	r3, 8000ee2 <SE_LL_FLASH_Read+0x2a>
    return SE_ERROR;
 8000ed6:	4811      	ldr	r0, [pc, #68]	; (8000f1c <SE_LL_FLASH_Read+0x64>)
 8000ed8:	e014      	b.n	8000f04 <SE_LL_FLASH_Read+0x4c>
        ((source + Length) <= (SlotStartAdd[SLOT_DWL_1 + i] + SLOT_SIZE(SLOT_DWL_1))))
 8000eda:	4d11      	ldr	r5, [pc, #68]	; (8000f20 <SE_LL_FLASH_Read+0x68>)
 8000edc:	188c      	adds	r4, r1, r2
    if ((source >= SlotStartAdd[SLOT_DWL_1 + i]) &&
 8000ede:	42ac      	cmp	r4, r5
 8000ee0:	d8f8      	bhi.n	8000ed4 <SE_LL_FLASH_Read+0x1c>
  SE_DoubleECC_Error_Counter = 0U;
 8000ee2:	4b10      	ldr	r3, [pc, #64]	; (8000f24 <SE_LL_FLASH_Read+0x6c>)
 8000ee4:	2400      	movs	r4, #0
 8000ee6:	625c      	str	r4, [r3, #36]	; 0x24
  for (i = 0; (i < Length) && (SE_DoubleECC_Error_Counter == 0U); i++, pDestination++, pSource++)
 8000ee8:	3901      	subs	r1, #1
 8000eea:	4402      	add	r2, r0
 8000eec:	4282      	cmp	r2, r0
 8000eee:	d001      	beq.n	8000ef4 <SE_LL_FLASH_Read+0x3c>
 8000ef0:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8000ef2:	b154      	cbz	r4, 8000f0a <SE_LL_FLASH_Read+0x52>
  if (SE_DoubleECC_Error_Counter == 0U)
 8000ef4:	6a59      	ldr	r1, [r3, #36]	; 0x24
    e_ret_status = SE_SUCCESS;
 8000ef6:	4a0c      	ldr	r2, [pc, #48]	; (8000f28 <SE_LL_FLASH_Read+0x70>)
 8000ef8:	4808      	ldr	r0, [pc, #32]	; (8000f1c <SE_LL_FLASH_Read+0x64>)
 8000efa:	2900      	cmp	r1, #0
 8000efc:	bf08      	it	eq
 8000efe:	4610      	moveq	r0, r2
  SE_DoubleECC_Error_Counter = 0U;
 8000f00:	2200      	movs	r2, #0
 8000f02:	625a      	str	r2, [r3, #36]	; 0x24
}
 8000f04:	bd30      	pop	{r4, r5, pc}
 8000f06:	2300      	movs	r3, #0
 8000f08:	e7e1      	b.n	8000ece <SE_LL_FLASH_Read+0x16>
    *pDestination = *pSource;
 8000f0a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8000f0e:	f800 4b01 	strb.w	r4, [r0], #1
  for (i = 0; (i < Length) && (SE_DoubleECC_Error_Counter == 0U); i++, pDestination++, pSource++)
 8000f12:	e7eb      	b.n	8000eec <SE_LL_FLASH_Read+0x34>
 8000f14:	08018000 	.word	0x08018000
 8000f18:	0804c000 	.word	0x0804c000
 8000f1c:	00018799 	.word	0x00018799
 8000f20:	08080000 	.word	0x08080000
 8000f24:	20000570 	.word	0x20000570
 8000f28:	0012310f 	.word	0x0012310f

08000f2c <SE_LL_Buffer_in_ram>:
{
 8000f2c:	b508      	push	{r3, lr}
  uint32_t addr_end = addr_start + Length - 1U;
 8000f2e:	1e4b      	subs	r3, r1, #1
 8000f30:	4403      	add	r3, r0
  if ((Length != 0U) && (!((0xFFFFFFFFUL - addr_start) < Length))
 8000f32:	b141      	cbz	r1, 8000f46 <SE_LL_Buffer_in_ram+0x1a>
 8000f34:	43c2      	mvns	r2, r0
 8000f36:	428a      	cmp	r2, r1
 8000f38:	d305      	bcc.n	8000f46 <SE_LL_Buffer_in_ram+0x1a>
      && ((addr_end  <= SB_REGION_RAM_END) && (addr_start >= (SE_REGION_RAM_END + 1U))))
 8000f3a:	4a05      	ldr	r2, [pc, #20]	; (8000f50 <SE_LL_Buffer_in_ram+0x24>)
 8000f3c:	4293      	cmp	r3, r2
 8000f3e:	d802      	bhi.n	8000f46 <SE_LL_Buffer_in_ram+0x1a>
 8000f40:	4b04      	ldr	r3, [pc, #16]	; (8000f54 <SE_LL_Buffer_in_ram+0x28>)
 8000f42:	4283      	cmp	r3, r0
 8000f44:	d901      	bls.n	8000f4a <SE_LL_Buffer_in_ram+0x1e>
    NVIC_SystemReset();
 8000f46:	f7ff ff1d 	bl	8000d84 <__NVIC_SystemReset>
}
 8000f4a:	4803      	ldr	r0, [pc, #12]	; (8000f58 <SE_LL_Buffer_in_ram+0x2c>)
 8000f4c:	bd08      	pop	{r3, pc}
 8000f4e:	bf00      	nop
 8000f50:	2002ffff 	.word	0x2002ffff
 8000f54:	20001000 	.word	0x20001000
 8000f58:	0012310f 	.word	0x0012310f

08000f5c <SE_LL_Buffer_in_SBSFU_ram>:
{
 8000f5c:	b508      	push	{r3, lr}
  uint32_t addr_end = addr_start + Length - 1U;
 8000f5e:	1e4b      	subs	r3, r1, #1
 8000f60:	4403      	add	r3, r0
  if ((Length != 0U) && (!((0xFFFFFFFFUL - addr_start) < Length))
 8000f62:	b141      	cbz	r1, 8000f76 <SE_LL_Buffer_in_SBSFU_ram+0x1a>
 8000f64:	43c2      	mvns	r2, r0
 8000f66:	428a      	cmp	r2, r1
 8000f68:	d305      	bcc.n	8000f76 <SE_LL_Buffer_in_SBSFU_ram+0x1a>
      && ((addr_end  <= SB_REGION_RAM_END) && (addr_start >= SB_REGION_RAM_START)))
 8000f6a:	4a05      	ldr	r2, [pc, #20]	; (8000f80 <SE_LL_Buffer_in_SBSFU_ram+0x24>)
 8000f6c:	4293      	cmp	r3, r2
 8000f6e:	d802      	bhi.n	8000f76 <SE_LL_Buffer_in_SBSFU_ram+0x1a>
 8000f70:	4b04      	ldr	r3, [pc, #16]	; (8000f84 <SE_LL_Buffer_in_SBSFU_ram+0x28>)
 8000f72:	4298      	cmp	r0, r3
 8000f74:	d201      	bcs.n	8000f7a <SE_LL_Buffer_in_SBSFU_ram+0x1e>
    NVIC_SystemReset();
 8000f76:	f7ff ff05 	bl	8000d84 <__NVIC_SystemReset>
}
 8000f7a:	4803      	ldr	r0, [pc, #12]	; (8000f88 <SE_LL_Buffer_in_SBSFU_ram+0x2c>)
 8000f7c:	bd08      	pop	{r3, pc}
 8000f7e:	bf00      	nop
 8000f80:	2002ffff 	.word	0x2002ffff
 8000f84:	20001010 	.word	0x20001010
 8000f88:	0012310f 	.word	0x0012310f

08000f8c <SE_LL_Buffer_part_of_SE_ram>:
{
 8000f8c:	b508      	push	{r3, lr}
  if (((Length != 0U) && (!(((addr_start < SE_REGION_RAM_START) && (addr_end < SE_REGION_RAM_START)) ||
 8000f8e:	b181      	cbz	r1, 8000fb2 <SE_LL_Buffer_part_of_SE_ram+0x26>
 8000f90:	4a09      	ldr	r2, [pc, #36]	; (8000fb8 <SE_LL_Buffer_part_of_SE_ram+0x2c>)
  uint32_t addr_end = addr_start + Length - 1U;
 8000f92:	1e4b      	subs	r3, r1, #1
  if (((Length != 0U) && (!(((addr_start < SE_REGION_RAM_START) && (addr_end < SE_REGION_RAM_START)) ||
 8000f94:	4282      	cmp	r2, r0
  uint32_t addr_end = addr_start + Length - 1U;
 8000f96:	4403      	add	r3, r0
  if (((Length != 0U) && (!(((addr_start < SE_REGION_RAM_START) && (addr_end < SE_REGION_RAM_START)) ||
 8000f98:	d901      	bls.n	8000f9e <SE_LL_Buffer_part_of_SE_ram+0x12>
 8000f9a:	429a      	cmp	r2, r3
 8000f9c:	d804      	bhi.n	8000fa8 <SE_LL_Buffer_part_of_SE_ram+0x1c>
                            ((addr_start > SE_REGION_RAM_END) && (addr_end > SE_REGION_RAM_END)))))
 8000f9e:	4a07      	ldr	r2, [pc, #28]	; (8000fbc <SE_LL_Buffer_part_of_SE_ram+0x30>)
  if (((Length != 0U) && (!(((addr_start < SE_REGION_RAM_START) && (addr_end < SE_REGION_RAM_START)) ||
 8000fa0:	4282      	cmp	r2, r0
 8000fa2:	d204      	bcs.n	8000fae <SE_LL_Buffer_part_of_SE_ram+0x22>
                            ((addr_start > SE_REGION_RAM_END) && (addr_end > SE_REGION_RAM_END)))))
 8000fa4:	429a      	cmp	r2, r3
 8000fa6:	d202      	bcs.n	8000fae <SE_LL_Buffer_part_of_SE_ram+0x22>
      || ((0xFFFFFFFFUL - addr_start) < Length))
 8000fa8:	43c0      	mvns	r0, r0
 8000faa:	4288      	cmp	r0, r1
 8000fac:	d201      	bcs.n	8000fb2 <SE_LL_Buffer_part_of_SE_ram+0x26>
    NVIC_SystemReset();
 8000fae:	f7ff fee9 	bl	8000d84 <__NVIC_SystemReset>
}
 8000fb2:	4803      	ldr	r0, [pc, #12]	; (8000fc0 <SE_LL_Buffer_part_of_SE_ram+0x34>)
 8000fb4:	bd08      	pop	{r3, pc}
 8000fb6:	bf00      	nop
 8000fb8:	20000000 	.word	0x20000000
 8000fbc:	20000fff 	.word	0x20000fff
 8000fc0:	00018799 	.word	0x00018799

08000fc4 <NMI_Handler>:
  * @brief  NMI Handler present for handling Double ECC NMI interrupt
  * @param  None.
  * @retval None.
  */
void NMI_Handler(void)
{
 8000fc4:	b508      	push	{r3, lr}
  uint32_t *p_sp;
  uint32_t lr;
  uint16_t opcode_msb;

  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD))
 8000fc6:	4b1b      	ldr	r3, [pc, #108]	; (8001034 <NMI_Handler+0x70>)
 8000fc8:	699b      	ldr	r3, [r3, #24]
 8000fca:	2b00      	cmp	r3, #0
 8000fcc:	da2e      	bge.n	800102c <NMI_Handler+0x68>
  {
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ECCD);
 8000fce:	4a19      	ldr	r2, [pc, #100]	; (8001034 <NMI_Handler+0x70>)
 8000fd0:	6993      	ldr	r3, [r2, #24]
 8000fd2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000fd6:	6193      	str	r3, [r2, #24]

    /* Memorize error to ignore the read value */
    SE_DoubleECC_Error_Counter++;
 8000fd8:	4a17      	ldr	r2, [pc, #92]	; (8001038 <NMI_Handler+0x74>)
 8000fda:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8000fdc:	3301      	adds	r3, #1
 8000fde:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile("MOV %0, LR" : "=r"(result));
 8000fe0:	4673      	mov	r3, lr

    lr = __get_LR();

    /* Check EXC_RETURN value in LR to know which SP was used prior entering exception */
    if (((lr) & (0xFU)) == 0xDU)
 8000fe2:	f003 030f 	and.w	r3, r3, #15
 8000fe6:	2b0d      	cmp	r3, #13
 8000fe8:	d016      	beq.n	8001018 <NMI_Handler+0x54>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 8000fea:	f3ef 8308 	mrs	r3, MSP
      /* interrupted code was using Main Stack Pointer */
      p_sp = (uint32_t *)__get_MSP();
    }

    /* Test caller mode T bit from CPSR in stack */
    if ((*(p_sp + 7U) & (1U << xPSR_T_Pos)) != 0U)
 8000fee:	69da      	ldr	r2, [r3, #28]
 8000ff0:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 8000ff4:	d016      	beq.n	8001024 <NMI_Handler+0x60>
         Test PC in stack.
         If bits [15:11] of the halfword being decoded take any of the following values,
         the halfword is the first halfword of a 32-bit instruction: 0b11101, 0b11110, 0b11111.
         Otherwise, the halfword is a 16-bit instruction.
      */
      opcode_msb = (*(uint16_t *)(*(p_sp + 6) & 0xFFFFFFFEU) & 0xF800U);
 8000ff6:	699a      	ldr	r2, [r3, #24]
 8000ff8:	f022 0101 	bic.w	r1, r2, #1
 8000ffc:	8809      	ldrh	r1, [r1, #0]
      if ((opcode_msb == 0xE800U) || (opcode_msb == 0xF000U) || (opcode_msb == 0xF800U))
 8000ffe:	f401 4068 	and.w	r0, r1, #59392	; 0xe800
 8001002:	f5b0 4f68 	cmp.w	r0, #59392	; 0xe800
 8001006:	d00a      	beq.n	800101e <NMI_Handler+0x5a>
 8001008:	f401 4178 	and.w	r1, r1, #63488	; 0xf800
 800100c:	f5b1 4f70 	cmp.w	r1, #61440	; 0xf000
 8001010:	d005      	beq.n	800101e <NMI_Handler+0x5a>
        *(p_sp + 6U) += 4U;
      }
      else
      {
        /* execute next instruction PC +2  */
        *(p_sp + 6U) += 2U;
 8001012:	3202      	adds	r2, #2
 8001014:	619a      	str	r2, [r3, #24]
 8001016:	e00b      	b.n	8001030 <NMI_Handler+0x6c>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001018:	f3ef 8309 	mrs	r3, PSP
  return(result);
 800101c:	e7e7      	b.n	8000fee <NMI_Handler+0x2a>
        *(p_sp + 6U) += 4U;
 800101e:	3204      	adds	r2, #4
 8001020:	619a      	str	r2, [r3, #24]
 8001022:	e005      	b.n	8001030 <NMI_Handler+0x6c>
      }
    }
    else
    {
      /* ARM mode execute next instruction PC +4 */
      *(p_sp + 6U) += 4U;
 8001024:	699a      	ldr	r2, [r3, #24]
 8001026:	3204      	adds	r2, #4
 8001028:	619a      	str	r2, [r3, #24]
 800102a:	e001      	b.n	8001030 <NMI_Handler+0x6c>
    }
  }
  else
  {
    /* This exception occurs for another reason than flash double ECC errors */
    SE_NMI_ExceptionHandler();
 800102c:	f001 fa6c 	bl	8002508 <SE_NMI_ExceptionHandler>
  }
}
 8001030:	bd08      	pop	{r3, pc}
 8001032:	bf00      	nop
 8001034:	58004000 	.word	0x58004000
 8001038:	20000570 	.word	0x20000570

0800103c <HardFault_Handler>:
  * @param  None.
  * @retvat void
  */
void HardFault_Handler(void)
{
  SE_NMI_ExceptionHandler();
 800103c:	f001 ba64 	b.w	8002508 <SE_NMI_ExceptionHandler>

08001040 <SE_LL_CORE_Cleanup>:
  * The function is called  during SE_LOCK_RESTRICT_SERVICES.
  *
  */
void  SE_LL_CORE_Cleanup(void)
{
}
 8001040:	4770      	bx	lr
	...

08001044 <SE_LL_Lock_Keys>:
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise
  */
SE_ErrorStatus SE_LL_Lock_Keys(void)
{
  return SE_SUCCESS;
}
 8001044:	4800      	ldr	r0, [pc, #0]	; (8001048 <SE_LL_Lock_Keys+0x4>)
 8001046:	4770      	bx	lr
 8001048:	0012310f 	.word	0x0012310f

0800104c <HAL_CRYP_MspInit>:
  * @param hcryp: CRYP handle pointer
  * @retval None
  */
void HAL_CRYP_MspInit(CRYP_HandleTypeDef *hcryp)
{
  if (hcryp->Instance == AES1)
 800104c:	6802      	ldr	r2, [r0, #0]
 800104e:	4b08      	ldr	r3, [pc, #32]	; (8001070 <HAL_CRYP_MspInit+0x24>)
 8001050:	429a      	cmp	r2, r3
{
 8001052:	b082      	sub	sp, #8
  if (hcryp->Instance == AES1)
 8001054:	d10a      	bne.n	800106c <HAL_CRYP_MspInit+0x20>
  SET_BIT(RCC->AHB2ENR, Periphs);
 8001056:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800105a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800105c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001060:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8001062:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001064:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001068:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800106a:	9b01      	ldr	r3, [sp, #4]
  {
    /* Peripheral clock enable */
    __HAL_RCC_AES1_CLK_ENABLE();
  }
}
 800106c:	b002      	add	sp, #8
 800106e:	4770      	bx	lr
 8001070:	50060000 	.word	0x50060000

08001074 <HAL_CRYP_MspDeInit>:
  * @param haes: AES handle pointer
  * @retval None
  */
void HAL_CRYP_MspDeInit(CRYP_HandleTypeDef *hcryp)
{
  if (hcryp->Instance == AES1)
 8001074:	6802      	ldr	r2, [r0, #0]
 8001076:	4b05      	ldr	r3, [pc, #20]	; (800108c <HAL_CRYP_MspDeInit+0x18>)
 8001078:	429a      	cmp	r2, r3
  CLEAR_BIT(RCC->AHB2ENR, Periphs);
 800107a:	bf01      	itttt	eq
 800107c:	f04f 42b0 	moveq.w	r2, #1476395008	; 0x58000000
 8001080:	6cd3      	ldreq	r3, [r2, #76]	; 0x4c
 8001082:	f423 3380 	biceq.w	r3, r3, #65536	; 0x10000
 8001086:	64d3      	streq	r3, [r2, #76]	; 0x4c
  {
    /* Peripheral clock disable */
    __HAL_RCC_AES1_CLK_DISABLE();
  }
}
 8001088:	4770      	bx	lr
 800108a:	bf00      	nop
 800108c:	50060000 	.word	0x50060000

08001090 <HAL_PKA_MspInit>:
  * @param hpka: PKA handle pointer
  * @retval None
  */
void HAL_PKA_MspInit(PKA_HandleTypeDef *hpka)
{
  if (hpka->Instance == PKA)
 8001090:	6802      	ldr	r2, [r0, #0]
 8001092:	4b08      	ldr	r3, [pc, #32]	; (80010b4 <HAL_PKA_MspInit+0x24>)
 8001094:	429a      	cmp	r2, r3
{
 8001096:	b082      	sub	sp, #8
  if (hpka->Instance == PKA)
 8001098:	d10a      	bne.n	80010b0 <HAL_PKA_MspInit+0x20>
  SET_BIT(RCC->AHB3ENR, Periphs);
 800109a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800109e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80010a0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80010a4:	651a      	str	r2, [r3, #80]	; 0x50
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 80010a6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80010a8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80010ac:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80010ae:	9b01      	ldr	r3, [sp, #4]
  {
    /* Peripheral clock enable */
    __HAL_RCC_PKA_CLK_ENABLE();
  }
}
 80010b0:	b002      	add	sp, #8
 80010b2:	4770      	bx	lr
 80010b4:	58002000 	.word	0x58002000

080010b8 <HAL_PKA_MspDeInit>:
  * @param hpka: PKA handle pointer
  * @retval None
  */
void HAL_PKA_MspDeInit(PKA_HandleTypeDef *hpka)
{
  if (hpka->Instance == PKA)
 80010b8:	6802      	ldr	r2, [r0, #0]
 80010ba:	4b09      	ldr	r3, [pc, #36]	; (80010e0 <HAL_PKA_MspDeInit+0x28>)
 80010bc:	429a      	cmp	r2, r3
 80010be:	d10d      	bne.n	80010dc <HAL_PKA_MspDeInit+0x24>
  SET_BIT(RCC->AHB3RSTR, Periphs);
 80010c0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80010c4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80010c6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80010ca:	631a      	str	r2, [r3, #48]	; 0x30
  CLEAR_BIT(RCC->AHB3RSTR, Periphs);
 80010cc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80010ce:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80010d2:	631a      	str	r2, [r3, #48]	; 0x30
  CLEAR_BIT(RCC->AHB3ENR, Periphs);
 80010d4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80010d6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80010da:	651a      	str	r2, [r3, #80]	; 0x50
    __HAL_RCC_PKA_RELEASE_RESET();

    /* Peripheral clock disable */
    __HAL_RCC_PKA_CLK_DISABLE();
  }
}
 80010dc:	4770      	bx	lr
 80010de:	bf00      	nop
 80010e0:	58002000 	.word	0x58002000

080010e4 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
}
 80010e4:	4770      	bx	lr

080010e6 <IPCC_C1_TX_IRQHandler>:
  * @param  None
  * @retval None
  */
void IPCC_C1_TX_IRQHandler(void)
{
  HW_IPCC_Tx_Handler();
 80010e6:	f7ff bb4f 	b.w	8000788 <HW_IPCC_Tx_Handler>

080010ea <IPCC_C1_RX_IRQHandler>:
  * @param  None
  * @retval None
  */
void IPCC_C1_RX_IRQHandler(void)
{
  HW_IPCC_Rx_Handler();
 80010ea:	f7ff bb8f 	b.w	800080c <HW_IPCC_Rx_Handler>
	...

080010f0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80010f0:	2800      	cmp	r0, #0
 80010f2:	db08      	blt.n	8001106 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80010f4:	0942      	lsrs	r2, r0, #5
 80010f6:	2301      	movs	r3, #1
 80010f8:	f000 001f 	and.w	r0, r0, #31
 80010fc:	fa03 f000 	lsl.w	r0, r3, r0
 8001100:	4b01      	ldr	r3, [pc, #4]	; (8001108 <HAL_NVIC_EnableIRQ+0x18>)
 8001102:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8001106:	4770      	bx	lr
 8001108:	e000e100 	.word	0xe000e100

0800110c <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800110c:	2800      	cmp	r0, #0
 800110e:	db0d      	blt.n	800112c <HAL_NVIC_DisableIRQ+0x20>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001110:	0943      	lsrs	r3, r0, #5
 8001112:	2201      	movs	r2, #1
 8001114:	f000 001f 	and.w	r0, r0, #31
 8001118:	fa02 f000 	lsl.w	r0, r2, r0
 800111c:	3320      	adds	r3, #32
 800111e:	4a04      	ldr	r2, [pc, #16]	; (8001130 <HAL_NVIC_DisableIRQ+0x24>)
 8001120:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 8001124:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8001128:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 800112c:	4770      	bx	lr
 800112e:	bf00      	nop
 8001130:	e000e100 	.word	0xe000e100

08001134 <HAL_CRC_MspInit>:
  UNUSED(hcrc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_CRC_MspInit can be implemented in the user file
   */
}
 8001134:	4770      	bx	lr
	...

08001138 <HAL_CRC_Init>:
{
 8001138:	b510      	push	{r4, lr}
  if (hcrc == NULL)
 800113a:	4604      	mov	r4, r0
 800113c:	b908      	cbnz	r0, 8001142 <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 800113e:	2001      	movs	r0, #1
}
 8001140:	bd10      	pop	{r4, pc}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 8001142:	7f43      	ldrb	r3, [r0, #29]
 8001144:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001148:	b913      	cbnz	r3, 8001150 <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 800114a:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 800114c:	f7ff fff2 	bl	8001134 <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY;
 8001150:	2302      	movs	r3, #2
 8001152:	7763      	strb	r3, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 8001154:	7923      	ldrb	r3, [r4, #4]
 8001156:	b9e3      	cbnz	r3, 8001192 <HAL_CRC_Init+0x5a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 8001158:	6823      	ldr	r3, [r4, #0]
 800115a:	4a13      	ldr	r2, [pc, #76]	; (80011a8 <HAL_CRC_Init+0x70>)
 800115c:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800115e:	689a      	ldr	r2, [r3, #8]
 8001160:	f022 0218 	bic.w	r2, r2, #24
 8001164:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 8001166:	7962      	ldrb	r2, [r4, #5]
 8001168:	6823      	ldr	r3, [r4, #0]
 800116a:	b9d2      	cbnz	r2, 80011a2 <HAL_CRC_Init+0x6a>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800116c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 8001170:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 8001172:	689a      	ldr	r2, [r3, #8]
 8001174:	6961      	ldr	r1, [r4, #20]
 8001176:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800117a:	430a      	orrs	r2, r1
 800117c:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800117e:	689a      	ldr	r2, [r3, #8]
 8001180:	69a1      	ldr	r1, [r4, #24]
 8001182:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001186:	430a      	orrs	r2, r1
 8001188:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 800118a:	2301      	movs	r3, #1
 800118c:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 800118e:	2000      	movs	r0, #0
 8001190:	e7d6      	b.n	8001140 <HAL_CRC_Init+0x8>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 8001192:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 8001196:	4620      	mov	r0, r4
 8001198:	f000 f808 	bl	80011ac <HAL_CRCEx_Polynomial_Set>
 800119c:	2800      	cmp	r0, #0
 800119e:	d0e2      	beq.n	8001166 <HAL_CRC_Init+0x2e>
 80011a0:	e7cd      	b.n	800113e <HAL_CRC_Init+0x6>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 80011a2:	6922      	ldr	r2, [r4, #16]
 80011a4:	e7e4      	b.n	8001170 <HAL_CRC_Init+0x38>
 80011a6:	bf00      	nop
 80011a8:	04c11db7 	.word	0x04c11db7

080011ac <HAL_CRCEx_Polynomial_Set>:
  *          @arg @ref CRC_POLYLENGTH_16B 16-bit long CRC (generating polynomial of degree 16)
  *          @arg @ref CRC_POLYLENGTH_32B 32-bit long CRC (generating polynomial of degree 32)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 80011ac:	b510      	push	{r4, lr}
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 80011ae:	231f      	movs	r3, #31
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 80011b0:	3b01      	subs	r3, #1
 80011b2:	d306      	bcc.n	80011c2 <HAL_CRCEx_Polynomial_Set+0x16>
 80011b4:	fa21 f403 	lsr.w	r4, r1, r3
 80011b8:	07e4      	lsls	r4, r4, #31
 80011ba:	d5f9      	bpl.n	80011b0 <HAL_CRCEx_Polynomial_Set+0x4>
  {
  }

  switch (PolyLength)
 80011bc:	2a08      	cmp	r2, #8
 80011be:	d014      	beq.n	80011ea <HAL_CRCEx_Polynomial_Set+0x3e>
 80011c0:	d802      	bhi.n	80011c8 <HAL_CRCEx_Polynomial_Set+0x1c>
 80011c2:	b13a      	cbz	r2, 80011d4 <HAL_CRCEx_Polynomial_Set+0x28>
      }
      break;
    case CRC_POLYLENGTH_8B:
      if (msb >= HAL_CRC_LENGTH_8B)
      {
        status =   HAL_ERROR;
 80011c4:	2001      	movs	r0, #1

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
 80011c6:	e00d      	b.n	80011e4 <HAL_CRCEx_Polynomial_Set+0x38>
  switch (PolyLength)
 80011c8:	2a10      	cmp	r2, #16
 80011ca:	d00c      	beq.n	80011e6 <HAL_CRCEx_Polynomial_Set+0x3a>
 80011cc:	2a18      	cmp	r2, #24
 80011ce:	d1f9      	bne.n	80011c4 <HAL_CRCEx_Polynomial_Set+0x18>
      if (msb >= HAL_CRC_LENGTH_7B)
 80011d0:	2b06      	cmp	r3, #6
      if (msb >= HAL_CRC_LENGTH_16B)
 80011d2:	d8f7      	bhi.n	80011c4 <HAL_CRCEx_Polynomial_Set+0x18>
    WRITE_REG(hcrc->Instance->POL, Pol);
 80011d4:	6800      	ldr	r0, [r0, #0]
 80011d6:	6141      	str	r1, [r0, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 80011d8:	6883      	ldr	r3, [r0, #8]
 80011da:	f023 0318 	bic.w	r3, r3, #24
 80011de:	431a      	orrs	r2, r3
 80011e0:	6082      	str	r2, [r0, #8]
 80011e2:	2000      	movs	r0, #0
}
 80011e4:	bd10      	pop	{r4, pc}
      if (msb >= HAL_CRC_LENGTH_8B)
 80011e6:	2b07      	cmp	r3, #7
 80011e8:	e7f3      	b.n	80011d2 <HAL_CRCEx_Polynomial_Set+0x26>
      if (msb >= HAL_CRC_LENGTH_16B)
 80011ea:	2b0f      	cmp	r3, #15
 80011ec:	e7f1      	b.n	80011d2 <HAL_CRCEx_Polynomial_Set+0x26>

080011ee <CRYP_SetKey>:
  *         occurs when the key is written out of HAL scope.
  * @retval None
  */
static void CRYP_SetKey(CRYP_HandleTypeDef *hcryp, uint32_t KeySize)
{
  if (hcryp->Init.pKey != NULL)
 80011ee:	68c3      	ldr	r3, [r0, #12]
 80011f0:	b1a3      	cbz	r3, 800121c <CRYP_SetKey+0x2e>
  {
    switch (KeySize)
 80011f2:	b1a1      	cbz	r1, 800121e <CRYP_SetKey+0x30>
 80011f4:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 80011f8:	d110      	bne.n	800121c <CRYP_SetKey+0x2e>
    {
      case CRYP_KEYSIZE_256B:
        hcryp->Instance->KEYR7 = *(uint32_t *)(hcryp->Init.pKey);
 80011fa:	6802      	ldr	r2, [r0, #0]
 80011fc:	6819      	ldr	r1, [r3, #0]
 80011fe:	63d1      	str	r1, [r2, #60]	; 0x3c
        hcryp->Instance->KEYR6 = *(uint32_t *)(hcryp->Init.pKey + 1U);
 8001200:	6859      	ldr	r1, [r3, #4]
 8001202:	6391      	str	r1, [r2, #56]	; 0x38
        hcryp->Instance->KEYR5 = *(uint32_t *)(hcryp->Init.pKey + 2U);
 8001204:	6899      	ldr	r1, [r3, #8]
 8001206:	6351      	str	r1, [r2, #52]	; 0x34
        hcryp->Instance->KEYR4 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 8001208:	68d9      	ldr	r1, [r3, #12]
 800120a:	6311      	str	r1, [r2, #48]	; 0x30
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey + 4U);
 800120c:	6919      	ldr	r1, [r3, #16]
 800120e:	61d1      	str	r1, [r2, #28]
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 5U);
 8001210:	6959      	ldr	r1, [r3, #20]
 8001212:	6191      	str	r1, [r2, #24]
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 6U);
 8001214:	6999      	ldr	r1, [r3, #24]
 8001216:	6151      	str	r1, [r2, #20]
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 7U);
 8001218:	69db      	ldr	r3, [r3, #28]
        break;
      case CRYP_KEYSIZE_128B:
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey);
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 1U);
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 2U);
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 800121a:	6113      	str	r3, [r2, #16]
        break;
      default:
        break;
    }
  }
}
 800121c:	4770      	bx	lr
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey);
 800121e:	6802      	ldr	r2, [r0, #0]
 8001220:	6819      	ldr	r1, [r3, #0]
 8001222:	61d1      	str	r1, [r2, #28]
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 1U);
 8001224:	6859      	ldr	r1, [r3, #4]
 8001226:	6191      	str	r1, [r2, #24]
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 2U);
 8001228:	6899      	ldr	r1, [r3, #8]
 800122a:	6151      	str	r1, [r2, #20]
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 800122c:	68db      	ldr	r3, [r3, #12]
 800122e:	e7f4      	b.n	800121a <CRYP_SetKey+0x2c>

08001230 <CRYP_WaitOnCCFlag>:
  * @param  Timeout Timeout duration.
  * @note   This function can only be used in thread mode.
  * @retval HAL status
  */
static HAL_StatusTypeDef CRYP_WaitOnCCFlag(CRYP_HandleTypeDef *hcryp, uint32_t Timeout)
{
 8001230:	b570      	push	{r4, r5, r6, lr}
 8001232:	4606      	mov	r6, r0
 8001234:	460c      	mov	r4, r1
  uint32_t tickstart;

  /* Get timeout */
  tickstart = HAL_GetTick();
 8001236:	f001 f9e1 	bl	80025fc <HAL_GetTick>
 800123a:	4605      	mov	r5, r0

  while (HAL_IS_BIT_CLR(hcryp->Instance->SR, AES_SR_CCF))
 800123c:	6832      	ldr	r2, [r6, #0]
 800123e:	6853      	ldr	r3, [r2, #4]
 8001240:	07db      	lsls	r3, r3, #31
 8001242:	d501      	bpl.n	8001248 <CRYP_WaitOnCCFlag+0x18>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 8001244:	2000      	movs	r0, #0
}
 8001246:	bd70      	pop	{r4, r5, r6, pc}
    if (Timeout != HAL_MAX_DELAY)
 8001248:	1c61      	adds	r1, r4, #1
 800124a:	d0f8      	beq.n	800123e <CRYP_WaitOnCCFlag+0xe>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800124c:	f001 f9d6 	bl	80025fc <HAL_GetTick>
 8001250:	1b40      	subs	r0, r0, r5
 8001252:	42a0      	cmp	r0, r4
 8001254:	d801      	bhi.n	800125a <CRYP_WaitOnCCFlag+0x2a>
 8001256:	2c00      	cmp	r4, #0
 8001258:	d1f0      	bne.n	800123c <CRYP_WaitOnCCFlag+0xc>
        return HAL_ERROR;
 800125a:	2001      	movs	r0, #1
 800125c:	e7f3      	b.n	8001246 <CRYP_WaitOnCCFlag+0x16>
	...

08001260 <CRYP_GCMCCM_SetHeaderPhase>:
{
 8001260:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 8001264:	4e79      	ldr	r6, [pc, #484]	; (800144c <CRYP_GCMCCM_SetHeaderPhase+0x1ec>)
{
 8001266:	4604      	mov	r4, r0
 8001268:	460f      	mov	r7, r1
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 800126a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
{
 800126c:	b08c      	sub	sp, #48	; 0x30
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 800126e:	466d      	mov	r5, sp
 8001270:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8001272:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8001274:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8001276:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 800127a:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  if (hcryp->Init.HeaderWidthUnit == CRYP_HEADERWIDTHUNIT_WORD)
 800127e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001280:	69e5      	ldr	r5, [r4, #28]
 8001282:	b903      	cbnz	r3, 8001286 <CRYP_GCMCCM_SetHeaderPhase+0x26>
    size_in_bytes = hcryp->Init.HeaderSize * 4U;
 8001284:	00ad      	lsls	r5, r5, #2
  if ((size_in_bytes != 0U))
 8001286:	6823      	ldr	r3, [r4, #0]
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 8001288:	681a      	ldr	r2, [r3, #0]
  if ((size_in_bytes != 0U))
 800128a:	2d00      	cmp	r5, #0
 800128c:	f000 80cd 	beq.w	800142a <CRYP_GCMCCM_SetHeaderPhase+0x1ca>
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 8001290:	f422 42c0 	bic.w	r2, r2, #24576	; 0x6000
 8001294:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001298:	601a      	str	r2, [r3, #0]
    __HAL_CRYP_ENABLE(hcryp);
 800129a:	681a      	ldr	r2, [r3, #0]
    if ((size_in_bytes % 16U) == 0U)
 800129c:	f015 060f 	ands.w	r6, r5, #15
    __HAL_CRYP_ENABLE(hcryp);
 80012a0:	f042 0201 	orr.w	r2, r2, #1
 80012a4:	601a      	str	r2, [r3, #0]
    if ((size_in_bytes % 16U) == 0U)
 80012a6:	d01f      	beq.n	80012e8 <CRYP_GCMCCM_SetHeaderPhase+0x88>
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 80012a8:	ea4f 1815 	mov.w	r8, r5, lsr #4
 80012ac:	ea4f 0888 	mov.w	r8, r8, lsl #2
 80012b0:	2600      	movs	r6, #0
 80012b2:	45b0      	cmp	r8, r6
 80012b4:	6823      	ldr	r3, [r4, #0]
 80012b6:	d85e      	bhi.n	8001376 <CRYP_GCMCCM_SetHeaderPhase+0x116>
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 80012b8:	f3c5 0281 	ubfx	r2, r5, #2, #2
 80012bc:	2100      	movs	r1, #0
 80012be:	428a      	cmp	r2, r1
 80012c0:	f040 808b 	bne.w	80013da <CRYP_GCMCCM_SetHeaderPhase+0x17a>
      if ((size_in_bytes % 4U) == 0U)
 80012c4:	f015 0503 	ands.w	r5, r5, #3
 80012c8:	f040 8093 	bne.w	80013f2 <CRYP_GCMCCM_SetHeaderPhase+0x192>
          loopcounter++;
 80012cc:	3101      	adds	r1, #1
        while (loopcounter < 4U)
 80012ce:	2904      	cmp	r1, #4
          hcryp->Instance->DINR = 0x0U;
 80012d0:	609d      	str	r5, [r3, #8]
        while (loopcounter < 4U)
 80012d2:	d1fb      	bne.n	80012cc <CRYP_GCMCCM_SetHeaderPhase+0x6c>
      if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80012d4:	4639      	mov	r1, r7
 80012d6:	4620      	mov	r0, r4
 80012d8:	f7ff ffaa 	bl	8001230 <CRYP_WaitOnCCFlag>
 80012dc:	6823      	ldr	r3, [r4, #0]
 80012de:	2800      	cmp	r0, #0
 80012e0:	f000 809e 	beq.w	8001420 <CRYP_GCMCCM_SetHeaderPhase+0x1c0>
        __HAL_CRYP_DISABLE(hcryp);
 80012e4:	681a      	ldr	r2, [r3, #0]
 80012e6:	e033      	b.n	8001350 <CRYP_GCMCCM_SetHeaderPhase+0xf0>
      for (loopcounter = 0U; (loopcounter < (size_in_bytes / 4U)); loopcounter += 4U)
 80012e8:	08ad      	lsrs	r5, r5, #2
 80012ea:	42b5      	cmp	r5, r6
 80012ec:	d803      	bhi.n	80012f6 <CRYP_GCMCCM_SetHeaderPhase+0x96>
  return HAL_OK;
 80012ee:	2000      	movs	r0, #0
}
 80012f0:	b00c      	add	sp, #48	; 0x30
 80012f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80012f6:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80012f8:	69a1      	ldr	r1, [r4, #24]
 80012fa:	6822      	ldr	r2, [r4, #0]
 80012fc:	b29b      	uxth	r3, r3
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80012fe:	4620      	mov	r0, r4
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 8001300:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001304:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 8001306:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8001308:	3301      	adds	r3, #1
 800130a:	b29b      	uxth	r3, r3
 800130c:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 800130e:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8001310:	b29b      	uxth	r3, r3
 8001312:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001316:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 8001318:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 800131a:	3301      	adds	r3, #1
 800131c:	b29b      	uxth	r3, r3
 800131e:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR  = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 8001320:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8001322:	b29b      	uxth	r3, r3
 8001324:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001328:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 800132a:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 800132c:	3301      	adds	r3, #1
 800132e:	b29b      	uxth	r3, r3
 8001330:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 8001332:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8001334:	b29b      	uxth	r3, r3
 8001336:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800133a:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 800133c:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 800133e:	3301      	adds	r3, #1
 8001340:	b29b      	uxth	r3, r3
 8001342:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8001344:	4639      	mov	r1, r7
 8001346:	f7ff ff73 	bl	8001230 <CRYP_WaitOnCCFlag>
 800134a:	6823      	ldr	r3, [r4, #0]
          __HAL_CRYP_DISABLE(hcryp);
 800134c:	681a      	ldr	r2, [r3, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 800134e:	b168      	cbz	r0, 800136c <CRYP_GCMCCM_SetHeaderPhase+0x10c>
        __HAL_CRYP_DISABLE(hcryp);
 8001350:	f022 0201 	bic.w	r2, r2, #1
 8001354:	601a      	str	r2, [r3, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8001356:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001358:	f043 0310 	orr.w	r3, r3, #16
 800135c:	6563      	str	r3, [r4, #84]	; 0x54
        hcryp->State = HAL_CRYP_STATE_READY;
 800135e:	2001      	movs	r0, #1
        __HAL_UNLOCK(hcryp);
 8001360:	2300      	movs	r3, #0
        hcryp->State = HAL_CRYP_STATE_READY;
 8001362:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
        __HAL_UNLOCK(hcryp);
 8001366:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
        return HAL_ERROR;
 800136a:	e7c1      	b.n	80012f0 <CRYP_GCMCCM_SetHeaderPhase+0x90>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 800136c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001370:	601a      	str	r2, [r3, #0]
      for (loopcounter = 0U; (loopcounter < (size_in_bytes / 4U)); loopcounter += 4U)
 8001372:	3604      	adds	r6, #4
 8001374:	e7b9      	b.n	80012ea <CRYP_GCMCCM_SetHeaderPhase+0x8a>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 8001376:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 8001378:	69a1      	ldr	r1, [r4, #24]
 800137a:	b292      	uxth	r2, r2
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 800137c:	4620      	mov	r0, r4
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 800137e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 8001382:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++ ;
 8001384:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 8001386:	3201      	adds	r2, #1
 8001388:	b292      	uxth	r2, r2
 800138a:	87a2      	strh	r2, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 800138c:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 800138e:	b292      	uxth	r2, r2
 8001390:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 8001394:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++ ;
 8001396:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 8001398:	3201      	adds	r2, #1
 800139a:	b292      	uxth	r2, r2
 800139c:	87a2      	strh	r2, [r4, #60]	; 0x3c
        hcryp->Instance->DINR  = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 800139e:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 80013a0:	b292      	uxth	r2, r2
 80013a2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80013a6:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++ ;
 80013a8:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 80013aa:	3201      	adds	r2, #1
 80013ac:	b292      	uxth	r2, r2
 80013ae:	87a2      	strh	r2, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80013b0:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 80013b2:	b292      	uxth	r2, r2
 80013b4:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80013b8:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++ ;
 80013ba:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80013bc:	3301      	adds	r3, #1
 80013be:	b29b      	uxth	r3, r3
 80013c0:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80013c2:	4639      	mov	r1, r7
 80013c4:	f7ff ff34 	bl	8001230 <CRYP_WaitOnCCFlag>
 80013c8:	6823      	ldr	r3, [r4, #0]
          __HAL_CRYP_DISABLE(hcryp);
 80013ca:	681a      	ldr	r2, [r3, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80013cc:	2800      	cmp	r0, #0
 80013ce:	d1bf      	bne.n	8001350 <CRYP_GCMCCM_SetHeaderPhase+0xf0>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 80013d0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80013d4:	601a      	str	r2, [r3, #0]
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 80013d6:	3604      	adds	r6, #4
 80013d8:	e76b      	b.n	80012b2 <CRYP_GCMCCM_SetHeaderPhase+0x52>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80013da:	8fa0      	ldrh	r0, [r4, #60]	; 0x3c
 80013dc:	69a6      	ldr	r6, [r4, #24]
 80013de:	b280      	uxth	r0, r0
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 80013e0:	3101      	adds	r1, #1
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80013e2:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 80013e6:	6098      	str	r0, [r3, #8]
        hcryp->CrypHeaderCount++ ;
 80013e8:	8fa0      	ldrh	r0, [r4, #60]	; 0x3c
 80013ea:	3001      	adds	r0, #1
 80013ec:	b280      	uxth	r0, r0
 80013ee:	87a0      	strh	r0, [r4, #60]	; 0x3c
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 80013f0:	e765      	b.n	80012be <CRYP_GCMCCM_SetHeaderPhase+0x5e>
         tmp =  *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80013f2:	8fa1      	ldrh	r1, [r4, #60]	; 0x3c
 80013f4:	69a0      	ldr	r0, [r4, #24]
 80013f6:	b289      	uxth	r1, r1
         loopcounter++;
 80013f8:	3201      	adds	r2, #1
         tmp =  *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80013fa:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
         tmp &= mask[(hcryp->Init.DataType * 2U) + (size_in_bytes % 4U)];
 80013fe:	6860      	ldr	r0, [r4, #4]
 8001400:	eb05 0540 	add.w	r5, r5, r0, lsl #1
 8001404:	a80c      	add	r0, sp, #48	; 0x30
 8001406:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 800140a:	f855 0c30 	ldr.w	r0, [r5, #-48]
 800140e:	4001      	ands	r1, r0
         hcryp->Instance->DINR = tmp;
 8001410:	6099      	str	r1, [r3, #8]
           hcryp->Instance->DINR = 0x0U;
 8001412:	2100      	movs	r1, #0
         while (loopcounter < 4U)
 8001414:	2a04      	cmp	r2, #4
 8001416:	f43f af5d 	beq.w	80012d4 <CRYP_GCMCCM_SetHeaderPhase+0x74>
           hcryp->Instance->DINR = 0x0U;
 800141a:	6099      	str	r1, [r3, #8]
           loopcounter++;
 800141c:	3201      	adds	r2, #1
 800141e:	e7f9      	b.n	8001414 <CRYP_GCMCCM_SetHeaderPhase+0x1b4>
      __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8001420:	681a      	ldr	r2, [r3, #0]
 8001422:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001426:	601a      	str	r2, [r3, #0]
 8001428:	e762      	b.n	80012f0 <CRYP_GCMCCM_SetHeaderPhase+0x90>
    MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE, hcryp->Init.DataType);
 800142a:	6861      	ldr	r1, [r4, #4]
 800142c:	f022 0206 	bic.w	r2, r2, #6
 8001430:	430a      	orrs	r2, r1
 8001432:	601a      	str	r2, [r3, #0]
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 8001434:	681a      	ldr	r2, [r3, #0]
 8001436:	f422 42c0 	bic.w	r2, r2, #24576	; 0x6000
 800143a:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800143e:	601a      	str	r2, [r3, #0]
    __HAL_CRYP_ENABLE(hcryp);
 8001440:	681a      	ldr	r2, [r3, #0]
 8001442:	f042 0201 	orr.w	r2, r2, #1
 8001446:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8001448:	4628      	mov	r0, r5
 800144a:	e751      	b.n	80012f0 <CRYP_GCMCCM_SetHeaderPhase+0x90>
 800144c:	08003240 	.word	0x08003240

08001450 <HAL_CRYP_Init>:
{
 8001450:	b510      	push	{r4, lr}
  if (hcryp == NULL)
 8001452:	4604      	mov	r4, r0
 8001454:	b1e8      	cbz	r0, 8001492 <HAL_CRYP_Init+0x42>
  if (hcryp->State == HAL_CRYP_STATE_RESET)
 8001456:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 800145a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800145e:	b91b      	cbnz	r3, 8001468 <HAL_CRYP_Init+0x18>
    hcryp->Lock = HAL_UNLOCKED;
 8001460:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50
    HAL_CRYP_MspInit(hcryp);
 8001464:	f7ff fdf2 	bl	800104c <HAL_CRYP_MspInit>
  MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm);
 8001468:	e9d4 3001 	ldrd	r3, r0, [r4, #4]
 800146c:	6821      	ldr	r1, [r4, #0]
 800146e:	680a      	ldr	r2, [r1, #0]
 8001470:	4303      	orrs	r3, r0
 8001472:	6960      	ldr	r0, [r4, #20]
 8001474:	f422 22a0 	bic.w	r2, r2, #327680	; 0x50000
 8001478:	4303      	orrs	r3, r0
 800147a:	f022 0266 	bic.w	r2, r2, #102	; 0x66
 800147e:	4313      	orrs	r3, r2
 8001480:	600b      	str	r3, [r1, #0]
  hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;
 8001482:	2000      	movs	r0, #0
  hcryp->State = HAL_CRYP_STATE_READY;
 8001484:	2301      	movs	r3, #1
  hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;
 8001486:	6560      	str	r0, [r4, #84]	; 0x54
  hcryp->KeyIVConfig = 0U;
 8001488:	65a0      	str	r0, [r4, #88]	; 0x58
  hcryp->State = HAL_CRYP_STATE_READY;
 800148a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  hcryp->Phase = CRYP_PHASE_READY;
 800148e:	6463      	str	r3, [r4, #68]	; 0x44
}
 8001490:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8001492:	2001      	movs	r0, #1
 8001494:	e7fc      	b.n	8001490 <HAL_CRYP_Init+0x40>

08001496 <HAL_CRYP_DeInit>:
{
 8001496:	b538      	push	{r3, r4, r5, lr}
  if (hcryp == NULL)
 8001498:	4605      	mov	r5, r0
 800149a:	2401      	movs	r4, #1
 800149c:	b180      	cbz	r0, 80014c0 <HAL_CRYP_DeInit+0x2a>
  __HAL_CRYP_DISABLE(hcryp);
 800149e:	6802      	ldr	r2, [r0, #0]
  hcryp->Phase = CRYP_PHASE_READY;
 80014a0:	6444      	str	r4, [r0, #68]	; 0x44
  hcryp->CrypInCount = 0;
 80014a2:	2400      	movs	r4, #0
 80014a4:	87c4      	strh	r4, [r0, #62]	; 0x3e
  hcryp->CrypOutCount = 0;
 80014a6:	f8a0 4040 	strh.w	r4, [r0, #64]	; 0x40
  hcryp->CrypHeaderCount = 0;
 80014aa:	8784      	strh	r4, [r0, #60]	; 0x3c
  __HAL_CRYP_DISABLE(hcryp);
 80014ac:	6813      	ldr	r3, [r2, #0]
 80014ae:	f023 0301 	bic.w	r3, r3, #1
 80014b2:	6013      	str	r3, [r2, #0]
  HAL_CRYP_MspDeInit(hcryp);
 80014b4:	f7ff fdde 	bl	8001074 <HAL_CRYP_MspDeInit>
  hcryp->State = HAL_CRYP_STATE_RESET;
 80014b8:	f885 4051 	strb.w	r4, [r5, #81]	; 0x51
  __HAL_UNLOCK(hcryp);
 80014bc:	f885 4050 	strb.w	r4, [r5, #80]	; 0x50
    return HAL_ERROR;
 80014c0:	4620      	mov	r0, r4
}
 80014c2:	bd38      	pop	{r3, r4, r5, pc}

080014c4 <HAL_CRYP_ErrorCallback>:
 80014c4:	4770      	bx	lr

080014c6 <CRYP_AES_ProcessData>:
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 80014c6:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 80014c8:	6802      	ldr	r2, [r0, #0]
{
 80014ca:	b530      	push	{r4, r5, lr}
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 80014cc:	b29b      	uxth	r3, r3
 80014ce:	6b45      	ldr	r5, [r0, #52]	; 0x34
 80014d0:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80014d4:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 80014d6:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 80014d8:	3301      	adds	r3, #1
 80014da:	b29b      	uxth	r3, r3
 80014dc:	87c3      	strh	r3, [r0, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 80014de:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 80014e0:	b29b      	uxth	r3, r3
{
 80014e2:	b085      	sub	sp, #20
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 80014e4:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80014e8:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 80014ea:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 80014ec:	3301      	adds	r3, #1
 80014ee:	b29b      	uxth	r3, r3
 80014f0:	87c3      	strh	r3, [r0, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 80014f2:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 80014f4:	b29b      	uxth	r3, r3
{
 80014f6:	4604      	mov	r4, r0
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 80014f8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80014fc:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 80014fe:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001500:	3301      	adds	r3, #1
 8001502:	b29b      	uxth	r3, r3
 8001504:	87c3      	strh	r3, [r0, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 8001506:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001508:	b29b      	uxth	r3, r3
 800150a:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 800150e:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 8001510:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001512:	3301      	adds	r3, #1
 8001514:	b29b      	uxth	r3, r3
 8001516:	87c3      	strh	r3, [r0, #62]	; 0x3e
  if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8001518:	f7ff fe8a 	bl	8001230 <CRYP_WaitOnCCFlag>
 800151c:	b188      	cbz	r0, 8001542 <CRYP_AES_ProcessData+0x7c>
    __HAL_CRYP_DISABLE(hcryp);
 800151e:	6822      	ldr	r2, [r4, #0]
 8001520:	6813      	ldr	r3, [r2, #0]
 8001522:	f023 0301 	bic.w	r3, r3, #1
 8001526:	6013      	str	r3, [r2, #0]
    hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8001528:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800152a:	f043 0310 	orr.w	r3, r3, #16
 800152e:	6563      	str	r3, [r4, #84]	; 0x54
    hcryp->State = HAL_CRYP_STATE_READY;
 8001530:	2301      	movs	r3, #1
 8001532:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
    __HAL_UNLOCK(hcryp);
 8001536:	2300      	movs	r3, #0
 8001538:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    HAL_CRYP_ErrorCallback(hcryp);
 800153c:	4620      	mov	r0, r4
 800153e:	f7ff ffc1 	bl	80014c4 <HAL_CRYP_ErrorCallback>
  __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8001542:	6823      	ldr	r3, [r4, #0]
 8001544:	681a      	ldr	r2, [r3, #0]
 8001546:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800154a:	601a      	str	r2, [r3, #0]
    temp[i] = hcryp->Instance->DOUTR;
 800154c:	68da      	ldr	r2, [r3, #12]
 800154e:	9200      	str	r2, [sp, #0]
 8001550:	68da      	ldr	r2, [r3, #12]
 8001552:	9201      	str	r2, [sp, #4]
 8001554:	68da      	ldr	r2, [r3, #12]
 8001556:	68db      	ldr	r3, [r3, #12]
 8001558:	9303      	str	r3, [sp, #12]
  while((hcryp->CrypOutCount < ((hcryp->Size + 3U)/4U)) && (i<4U))
 800155a:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
    temp[i] = hcryp->Instance->DOUTR;
 800155e:	9202      	str	r2, [sp, #8]
  while((hcryp->CrypOutCount < ((hcryp->Size + 3U)/4U)) && (i<4U))
 8001560:	3303      	adds	r3, #3
 8001562:	089b      	lsrs	r3, r3, #2
  i= 0U;
 8001564:	2100      	movs	r1, #0
  while((hcryp->CrypOutCount < ((hcryp->Size + 3U)/4U)) && (i<4U))
 8001566:	f8b4 2040 	ldrh.w	r2, [r4, #64]	; 0x40
 800156a:	b292      	uxth	r2, r2
 800156c:	429a      	cmp	r2, r3
 800156e:	d201      	bcs.n	8001574 <CRYP_AES_ProcessData+0xae>
 8001570:	2904      	cmp	r1, #4
 8001572:	d101      	bne.n	8001578 <CRYP_AES_ProcessData+0xb2>
}
 8001574:	b005      	add	sp, #20
 8001576:	bd30      	pop	{r4, r5, pc}
    *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[i];
 8001578:	f8b4 2040 	ldrh.w	r2, [r4, #64]	; 0x40
 800157c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800157e:	f85d 5021 	ldr.w	r5, [sp, r1, lsl #2]
 8001582:	b292      	uxth	r2, r2
    i++;
 8001584:	3101      	adds	r1, #1
    *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[i];
 8001586:	f840 5022 	str.w	r5, [r0, r2, lsl #2]
    hcryp->CrypOutCount++;
 800158a:	f8b4 2040 	ldrh.w	r2, [r4, #64]	; 0x40
 800158e:	3201      	adds	r2, #1
 8001590:	b292      	uxth	r2, r2
 8001592:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
    i++;
 8001596:	e7e6      	b.n	8001566 <CRYP_AES_ProcessData+0xa0>

08001598 <CRYP_AESCCM_Process>:
{
 8001598:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 800159a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 800159c:	f8b0 5042 	ldrh.w	r5, [r0, #66]	; 0x42
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 80015a0:	2b01      	cmp	r3, #1
{
 80015a2:	b085      	sub	sp, #20
 80015a4:	4604      	mov	r4, r0
 80015a6:	460e      	mov	r6, r1
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 80015a8:	d11f      	bne.n	80015ea <CRYP_AESCCM_Process+0x52>
    if (hcryp->KeyIVConfig == 1U)
 80015aa:	6d82      	ldr	r2, [r0, #88]	; 0x58
 80015ac:	2a01      	cmp	r2, #1
 80015ae:	d11b      	bne.n	80015e8 <CRYP_AESCCM_Process+0x50>
      hcryp->SizesSum += hcryp->Size; /* Compute message total payload length */
 80015b0:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 80015b2:	442b      	add	r3, r5
 80015b4:	65c3      	str	r3, [r0, #92]	; 0x5c
  if ((hcryp->Size % 16U) != 0U)
 80015b6:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 80015ba:	08ad      	lsrs	r5, r5, #2
  if ((hcryp->Size % 16U) != 0U)
 80015bc:	0718      	lsls	r0, r3, #28
    wordsize = ((wordsize / 4U) * 4U) ;
 80015be:	bf18      	it	ne
 80015c0:	f025 0503 	bicne.w	r5, r5, #3
  tickstart = HAL_GetTick();
 80015c4:	f001 f81a 	bl	80025fc <HAL_GetTick>
 80015c8:	4607      	mov	r7, r0
    incount = hcryp->CrypInCount;
 80015ca:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    outcount = hcryp->CrypOutCount;
 80015cc:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
    incount = hcryp->CrypInCount;
 80015d0:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 80015d2:	4295      	cmp	r5, r2
    outcount = hcryp->CrypOutCount;
 80015d4:	b29b      	uxth	r3, r3
  while ((incount < wordsize) && (outcount < wordsize))
 80015d6:	d901      	bls.n	80015dc <CRYP_AESCCM_Process+0x44>
 80015d8:	429d      	cmp	r5, r3
 80015da:	d849      	bhi.n	8001670 <CRYP_AESCCM_Process+0xd8>
  if ((hcryp->Size % 16U) != 0U)
 80015dc:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
 80015e0:	071a      	lsls	r2, r3, #28
 80015e2:	d162      	bne.n	80016aa <CRYP_AESCCM_Process+0x112>
  return HAL_OK;
 80015e4:	2000      	movs	r0, #0
 80015e6:	e027      	b.n	8001638 <CRYP_AESCCM_Process+0xa0>
      hcryp->KeyIVConfig = 1U;
 80015e8:	6583      	str	r3, [r0, #88]	; 0x58
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 80015ea:	6822      	ldr	r2, [r4, #0]
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 80015ec:	68a1      	ldr	r1, [r4, #8]
    hcryp->SizesSum = hcryp->Size;
 80015ee:	65e5      	str	r5, [r4, #92]	; 0x5c
    hcryp->CrypHeaderCount = 0U;
 80015f0:	2700      	movs	r7, #0
 80015f2:	87a7      	strh	r7, [r4, #60]	; 0x3c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 80015f4:	6813      	ldr	r3, [r2, #0]
 80015f6:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 80015fa:	6013      	str	r3, [r2, #0]
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 80015fc:	4620      	mov	r0, r4
 80015fe:	f7ff fdf6 	bl	80011ee <CRYP_SetKey>
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.B0);
 8001602:	6a22      	ldr	r2, [r4, #32]
 8001604:	6823      	ldr	r3, [r4, #0]
 8001606:	6811      	ldr	r1, [r2, #0]
 8001608:	62d9      	str	r1, [r3, #44]	; 0x2c
    hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.B0 + 1U);
 800160a:	6851      	ldr	r1, [r2, #4]
 800160c:	6299      	str	r1, [r3, #40]	; 0x28
    hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.B0 + 2U);
 800160e:	6891      	ldr	r1, [r2, #8]
 8001610:	6259      	str	r1, [r3, #36]	; 0x24
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.B0 + 3U);
 8001612:	68d2      	ldr	r2, [r2, #12]
 8001614:	621a      	str	r2, [r3, #32]
    __HAL_CRYP_ENABLE(hcryp);
 8001616:	681a      	ldr	r2, [r3, #0]
 8001618:	f042 0201 	orr.w	r2, r2, #1
 800161c:	601a      	str	r2, [r3, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 800161e:	4631      	mov	r1, r6
 8001620:	f7ff fe06 	bl	8001230 <CRYP_WaitOnCCFlag>
 8001624:	b150      	cbz	r0, 800163c <CRYP_AESCCM_Process+0xa4>
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8001626:	6d63      	ldr	r3, [r4, #84]	; 0x54
      __HAL_UNLOCK(hcryp);
 8001628:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 800162c:	f043 0310 	orr.w	r3, r3, #16
      hcryp->State = HAL_CRYP_STATE_READY;
 8001630:	2001      	movs	r0, #1
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8001632:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 8001634:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
}
 8001638:	b005      	add	sp, #20
 800163a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 800163c:	6822      	ldr	r2, [r4, #0]
 800163e:	6813      	ldr	r3, [r2, #0]
 8001640:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001644:	6013      	str	r3, [r2, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 8001646:	4631      	mov	r1, r6
 8001648:	4620      	mov	r0, r4
 800164a:	f7ff fe09 	bl	8001260 <CRYP_GCMCCM_SetHeaderPhase>
 800164e:	2800      	cmp	r0, #0
 8001650:	f040 8086 	bne.w	8001760 <CRYP_AESCCM_Process+0x1c8>
    MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_PAYLOAD);
 8001654:	6822      	ldr	r2, [r4, #0]
    hcryp->Phase = CRYP_PHASE_PROCESS;
 8001656:	2302      	movs	r3, #2
 8001658:	6463      	str	r3, [r4, #68]	; 0x44
    MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_PAYLOAD);
 800165a:	6813      	ldr	r3, [r2, #0]
 800165c:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 8001660:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001664:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, 0U);
 8001666:	6813      	ldr	r3, [r2, #0]
 8001668:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800166c:	6013      	str	r3, [r2, #0]
 800166e:	e7a2      	b.n	80015b6 <CRYP_AESCCM_Process+0x1e>
    CRYP_AES_ProcessData(hcryp, Timeout);
 8001670:	4631      	mov	r1, r6
 8001672:	4620      	mov	r0, r4
 8001674:	f7ff ff27 	bl	80014c6 <CRYP_AES_ProcessData>
    if (Timeout != HAL_MAX_DELAY)
 8001678:	1c71      	adds	r1, r6, #1
 800167a:	d0a6      	beq.n	80015ca <CRYP_AESCCM_Process+0x32>
      if (((HAL_GetTick() - tickstart) > Timeout) ||(Timeout == 0U))
 800167c:	f000 ffbe 	bl	80025fc <HAL_GetTick>
 8001680:	1bc0      	subs	r0, r0, r7
 8001682:	42b0      	cmp	r0, r6
 8001684:	d801      	bhi.n	800168a <CRYP_AESCCM_Process+0xf2>
 8001686:	2e00      	cmp	r6, #0
 8001688:	d19f      	bne.n	80015ca <CRYP_AESCCM_Process+0x32>
        __HAL_CRYP_DISABLE(hcryp);
 800168a:	6822      	ldr	r2, [r4, #0]
 800168c:	6813      	ldr	r3, [r2, #0]
 800168e:	f023 0301 	bic.w	r3, r3, #1
 8001692:	6013      	str	r3, [r2, #0]
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8001694:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001696:	f043 0310 	orr.w	r3, r3, #16
 800169a:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 800169c:	2001      	movs	r0, #1
      __HAL_UNLOCK(hcryp);
 800169e:	2300      	movs	r3, #0
      hcryp->State = HAL_CRYP_STATE_READY;
 80016a0:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
      __HAL_UNLOCK(hcryp);
 80016a4:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
      return HAL_ERROR;
 80016a8:	e7c6      	b.n	8001638 <CRYP_AESCCM_Process+0xa0>
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_DECRYPT)
 80016aa:	6821      	ldr	r1, [r4, #0]
 80016ac:	6808      	ldr	r0, [r1, #0]
 80016ae:	f000 0018 	and.w	r0, r0, #24
 80016b2:	2810      	cmp	r0, #16
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20);
 80016b4:	bf08      	it	eq
 80016b6:	6808      	ldreq	r0, [r1, #0]
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 80016b8:	ea4f 1213 	mov.w	r2, r3, lsr #4
 80016bc:	f102 0201 	add.w	r2, r2, #1
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20);
 80016c0:	bf08      	it	eq
 80016c2:	f420 0070 	biceq.w	r0, r0, #15728640	; 0xf00000
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 80016c6:	ea4f 1702 	mov.w	r7, r2, lsl #4
 80016ca:	f103 0510 	add.w	r5, r3, #16
 80016ce:	ebc3 1202 	rsb	r2, r3, r2, lsl #4
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20);
 80016d2:	bf08      	it	eq
 80016d4:	ea40 5002 	orreq.w	r0, r0, r2, lsl #20
 80016d8:	eba5 0507 	sub.w	r5, r5, r7
 80016dc:	bf08      	it	eq
 80016de:	6008      	streq	r0, [r1, #0]
    if ((npblb % 4U) == 0U)
 80016e0:	08ad      	lsrs	r5, r5, #2
 80016e2:	0793      	lsls	r3, r2, #30
      lastwordsize = ((16U - npblb) / 4U) + 1U;
 80016e4:	bf18      	it	ne
 80016e6:	3501      	addne	r5, #1
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 80016e8:	2200      	movs	r2, #0
 80016ea:	42aa      	cmp	r2, r5
 80016ec:	d129      	bne.n	8001742 <CRYP_AESCCM_Process+0x1aa>
 80016ee:	462b      	mov	r3, r5
      hcryp->Instance->DINR  = 0U;
 80016f0:	2200      	movs	r2, #0
    while (loopcounter < 4U)
 80016f2:	2b03      	cmp	r3, #3
 80016f4:	d931      	bls.n	800175a <CRYP_AESCCM_Process+0x1c2>
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80016f6:	4631      	mov	r1, r6
 80016f8:	4620      	mov	r0, r4
 80016fa:	f7ff fd99 	bl	8001230 <CRYP_WaitOnCCFlag>
 80016fe:	2800      	cmp	r0, #0
 8001700:	d1c8      	bne.n	8001694 <CRYP_AESCCM_Process+0xfc>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8001702:	6823      	ldr	r3, [r4, #0]
 8001704:	681a      	ldr	r2, [r3, #0]
 8001706:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800170a:	601a      	str	r2, [r3, #0]
      temp[loopcounter] = hcryp->Instance->DOUTR;
 800170c:	68da      	ldr	r2, [r3, #12]
 800170e:	9200      	str	r2, [sp, #0]
 8001710:	68da      	ldr	r2, [r3, #12]
 8001712:	9201      	str	r2, [sp, #4]
 8001714:	68da      	ldr	r2, [r3, #12]
 8001716:	68db      	ldr	r3, [r3, #12]
 8001718:	9202      	str	r2, [sp, #8]
 800171a:	9303      	str	r3, [sp, #12]
    for (loopcounter = 0U; loopcounter<lastwordsize; loopcounter++)
 800171c:	42a8      	cmp	r0, r5
 800171e:	f43f af61 	beq.w	80015e4 <CRYP_AESCCM_Process+0x4c>
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[loopcounter];
 8001722:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
 8001726:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001728:	f85d 1020 	ldr.w	r1, [sp, r0, lsl #2]
 800172c:	b29b      	uxth	r3, r3
    for (loopcounter = 0U; loopcounter<lastwordsize; loopcounter++)
 800172e:	3001      	adds	r0, #1
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[loopcounter];
 8001730:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      hcryp->CrypOutCount++;
 8001734:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
 8001738:	3301      	adds	r3, #1
 800173a:	b29b      	uxth	r3, r3
 800173c:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
    for (loopcounter = 0U; loopcounter<lastwordsize; loopcounter++)
 8001740:	e7ec      	b.n	800171c <CRYP_AESCCM_Process+0x184>
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 8001742:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001744:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8001746:	b29b      	uxth	r3, r3
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 8001748:	3201      	adds	r2, #1
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 800174a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800174e:	608b      	str	r3, [r1, #8]
      hcryp->CrypInCount++;
 8001750:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001752:	3301      	adds	r3, #1
 8001754:	b29b      	uxth	r3, r3
 8001756:	87e3      	strh	r3, [r4, #62]	; 0x3e
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 8001758:	e7c7      	b.n	80016ea <CRYP_AESCCM_Process+0x152>
      hcryp->Instance->DINR  = 0U;
 800175a:	608a      	str	r2, [r1, #8]
      loopcounter++;
 800175c:	3301      	adds	r3, #1
 800175e:	e7c8      	b.n	80016f2 <CRYP_AESCCM_Process+0x15a>
      return HAL_ERROR;
 8001760:	2001      	movs	r0, #1
 8001762:	e769      	b.n	8001638 <CRYP_AESCCM_Process+0xa0>

08001764 <CRYP_AESGCM_Process>:
{
 8001764:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 8001766:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 8001768:	f8b0 5042 	ldrh.w	r5, [r0, #66]	; 0x42
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 800176c:	2b01      	cmp	r3, #1
{
 800176e:	b085      	sub	sp, #20
 8001770:	4604      	mov	r4, r0
 8001772:	460e      	mov	r6, r1
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 8001774:	d11f      	bne.n	80017b6 <CRYP_AESGCM_Process+0x52>
    if (hcryp->KeyIVConfig == 1U)
 8001776:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8001778:	2a01      	cmp	r2, #1
 800177a:	d11b      	bne.n	80017b4 <CRYP_AESGCM_Process+0x50>
      hcryp->SizesSum += hcryp->Size; /* Compute message total payload length */
 800177c:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800177e:	442b      	add	r3, r5
 8001780:	65c3      	str	r3, [r0, #92]	; 0x5c
  if ((hcryp->Size % 16U) != 0U)
 8001782:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 8001786:	08ad      	lsrs	r5, r5, #2
  if ((hcryp->Size % 16U) != 0U)
 8001788:	0718      	lsls	r0, r3, #28
    wordsize = ((wordsize / 4U) * 4U) ;
 800178a:	bf18      	it	ne
 800178c:	f025 0503 	bicne.w	r5, r5, #3
  tickstart = HAL_GetTick();
 8001790:	f000 ff34 	bl	80025fc <HAL_GetTick>
 8001794:	4607      	mov	r7, r0
    incount = hcryp->CrypInCount;
 8001796:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    outcount = hcryp->CrypOutCount;
 8001798:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
    incount = hcryp->CrypInCount;
 800179c:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 800179e:	4295      	cmp	r5, r2
    outcount = hcryp->CrypOutCount;
 80017a0:	b29b      	uxth	r3, r3
  while ((incount < wordsize) && (outcount < wordsize))
 80017a2:	d901      	bls.n	80017a8 <CRYP_AESGCM_Process+0x44>
 80017a4:	429d      	cmp	r5, r3
 80017a6:	d849      	bhi.n	800183c <CRYP_AESGCM_Process+0xd8>
  if ((hcryp->Size % 16U) != 0U)
 80017a8:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
 80017ac:	071a      	lsls	r2, r3, #28
 80017ae:	d162      	bne.n	8001876 <CRYP_AESGCM_Process+0x112>
  return HAL_OK;
 80017b0:	2000      	movs	r0, #0
 80017b2:	e027      	b.n	8001804 <CRYP_AESGCM_Process+0xa0>
      hcryp->KeyIVConfig = 1U;
 80017b4:	6583      	str	r3, [r0, #88]	; 0x58
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 80017b6:	6822      	ldr	r2, [r4, #0]
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 80017b8:	68a1      	ldr	r1, [r4, #8]
    hcryp->SizesSum = hcryp->Size;
 80017ba:	65e5      	str	r5, [r4, #92]	; 0x5c
    hcryp->CrypHeaderCount = 0U;
 80017bc:	2700      	movs	r7, #0
 80017be:	87a7      	strh	r7, [r4, #60]	; 0x3c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 80017c0:	6813      	ldr	r3, [r2, #0]
 80017c2:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 80017c6:	6013      	str	r3, [r2, #0]
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 80017c8:	4620      	mov	r0, r4
 80017ca:	f7ff fd10 	bl	80011ee <CRYP_SetKey>
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 80017ce:	6922      	ldr	r2, [r4, #16]
 80017d0:	6823      	ldr	r3, [r4, #0]
 80017d2:	6811      	ldr	r1, [r2, #0]
 80017d4:	62d9      	str	r1, [r3, #44]	; 0x2c
    hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 80017d6:	6851      	ldr	r1, [r2, #4]
 80017d8:	6299      	str	r1, [r3, #40]	; 0x28
    hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 80017da:	6891      	ldr	r1, [r2, #8]
 80017dc:	6259      	str	r1, [r3, #36]	; 0x24
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 80017de:	68d2      	ldr	r2, [r2, #12]
 80017e0:	621a      	str	r2, [r3, #32]
    __HAL_CRYP_ENABLE(hcryp);
 80017e2:	681a      	ldr	r2, [r3, #0]
 80017e4:	f042 0201 	orr.w	r2, r2, #1
 80017e8:	601a      	str	r2, [r3, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80017ea:	4631      	mov	r1, r6
 80017ec:	f7ff fd20 	bl	8001230 <CRYP_WaitOnCCFlag>
 80017f0:	b150      	cbz	r0, 8001808 <CRYP_AESGCM_Process+0xa4>
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 80017f2:	6d63      	ldr	r3, [r4, #84]	; 0x54
      __HAL_UNLOCK(hcryp);
 80017f4:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 80017f8:	f043 0310 	orr.w	r3, r3, #16
      hcryp->State = HAL_CRYP_STATE_READY;
 80017fc:	2001      	movs	r0, #1
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 80017fe:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 8001800:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
}
 8001804:	b005      	add	sp, #20
 8001806:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8001808:	6822      	ldr	r2, [r4, #0]
 800180a:	6813      	ldr	r3, [r2, #0]
 800180c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001810:	6013      	str	r3, [r2, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 8001812:	4631      	mov	r1, r6
 8001814:	4620      	mov	r0, r4
 8001816:	f7ff fd23 	bl	8001260 <CRYP_GCMCCM_SetHeaderPhase>
 800181a:	2800      	cmp	r0, #0
 800181c:	f040 808e 	bne.w	800193c <CRYP_AESGCM_Process+0x1d8>
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_PAYLOAD);
 8001820:	6822      	ldr	r2, [r4, #0]
    hcryp->Phase = CRYP_PHASE_PROCESS;
 8001822:	2302      	movs	r3, #2
 8001824:	6463      	str	r3, [r4, #68]	; 0x44
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_PAYLOAD);
 8001826:	6813      	ldr	r3, [r2, #0]
 8001828:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 800182c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001830:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, 0U);
 8001832:	6813      	ldr	r3, [r2, #0]
 8001834:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8001838:	6013      	str	r3, [r2, #0]
 800183a:	e7a2      	b.n	8001782 <CRYP_AESGCM_Process+0x1e>
    CRYP_AES_ProcessData(hcryp, Timeout);
 800183c:	4631      	mov	r1, r6
 800183e:	4620      	mov	r0, r4
 8001840:	f7ff fe41 	bl	80014c6 <CRYP_AES_ProcessData>
    if (Timeout != HAL_MAX_DELAY)
 8001844:	1c71      	adds	r1, r6, #1
 8001846:	d0a6      	beq.n	8001796 <CRYP_AESGCM_Process+0x32>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8001848:	f000 fed8 	bl	80025fc <HAL_GetTick>
 800184c:	1bc0      	subs	r0, r0, r7
 800184e:	42b0      	cmp	r0, r6
 8001850:	d801      	bhi.n	8001856 <CRYP_AESGCM_Process+0xf2>
 8001852:	2e00      	cmp	r6, #0
 8001854:	d19f      	bne.n	8001796 <CRYP_AESGCM_Process+0x32>
        __HAL_CRYP_DISABLE(hcryp);
 8001856:	6822      	ldr	r2, [r4, #0]
 8001858:	6813      	ldr	r3, [r2, #0]
 800185a:	f023 0301 	bic.w	r3, r3, #1
 800185e:	6013      	str	r3, [r2, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8001860:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001862:	f043 0310 	orr.w	r3, r3, #16
 8001866:	6563      	str	r3, [r4, #84]	; 0x54
        hcryp->State = HAL_CRYP_STATE_READY;
 8001868:	2001      	movs	r0, #1
        __HAL_UNLOCK(hcryp);
 800186a:	2300      	movs	r3, #0
        hcryp->State = HAL_CRYP_STATE_READY;
 800186c:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
        __HAL_UNLOCK(hcryp);
 8001870:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
        return HAL_ERROR;
 8001874:	e7c6      	b.n	8001804 <CRYP_AESGCM_Process+0xa0>
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_ENCRYPT)
 8001876:	6821      	ldr	r1, [r4, #0]
 8001878:	6808      	ldr	r0, [r1, #0]
 800187a:	f010 0f18 	tst.w	r0, #24
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20U);
 800187e:	bf08      	it	eq
 8001880:	6808      	ldreq	r0, [r1, #0]
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 8001882:	ea4f 1213 	mov.w	r2, r3, lsr #4
 8001886:	f102 0201 	add.w	r2, r2, #1
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20U);
 800188a:	bf08      	it	eq
 800188c:	f420 0070 	biceq.w	r0, r0, #15728640	; 0xf00000
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 8001890:	ea4f 1702 	mov.w	r7, r2, lsl #4
 8001894:	f103 0510 	add.w	r5, r3, #16
 8001898:	ebc3 1202 	rsb	r2, r3, r2, lsl #4
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20U);
 800189c:	bf08      	it	eq
 800189e:	ea40 5002 	orreq.w	r0, r0, r2, lsl #20
 80018a2:	eba5 0507 	sub.w	r5, r5, r7
 80018a6:	bf08      	it	eq
 80018a8:	6008      	streq	r0, [r1, #0]
    if ((npblb % 4U) == 0U)
 80018aa:	08ad      	lsrs	r5, r5, #2
 80018ac:	0793      	lsls	r3, r2, #30
      lastwordsize = ((16U - npblb) / 4U) + 1U;
 80018ae:	bf18      	it	ne
 80018b0:	3501      	addne	r5, #1
    for (index = 0U; index < lastwordsize; index ++)
 80018b2:	2200      	movs	r2, #0
 80018b4:	42aa      	cmp	r2, r5
 80018b6:	d132      	bne.n	800191e <CRYP_AESGCM_Process+0x1ba>
 80018b8:	462b      	mov	r3, r5
      hcryp->Instance->DINR  = 0U;
 80018ba:	2200      	movs	r2, #0
    while (index < 4U)
 80018bc:	2b03      	cmp	r3, #3
 80018be:	d93a      	bls.n	8001936 <CRYP_AESGCM_Process+0x1d2>
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80018c0:	4631      	mov	r1, r6
 80018c2:	4620      	mov	r0, r4
 80018c4:	f7ff fcb4 	bl	8001230 <CRYP_WaitOnCCFlag>
 80018c8:	b140      	cbz	r0, 80018dc <CRYP_AESGCM_Process+0x178>
      hcryp->State = HAL_CRYP_STATE_READY;
 80018ca:	2301      	movs	r3, #1
 80018cc:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
      __HAL_UNLOCK(hcryp);
 80018d0:	2300      	movs	r3, #0
 80018d2:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
      HAL_CRYP_ErrorCallback(hcryp);
 80018d6:	4620      	mov	r0, r4
 80018d8:	f7ff fdf4 	bl	80014c4 <HAL_CRYP_ErrorCallback>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 80018dc:	6823      	ldr	r3, [r4, #0]
 80018de:	681a      	ldr	r2, [r3, #0]
 80018e0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80018e4:	601a      	str	r2, [r3, #0]
      temp[index] = hcryp->Instance->DOUTR;
 80018e6:	68da      	ldr	r2, [r3, #12]
 80018e8:	9200      	str	r2, [sp, #0]
 80018ea:	68da      	ldr	r2, [r3, #12]
 80018ec:	9201      	str	r2, [sp, #4]
 80018ee:	68da      	ldr	r2, [r3, #12]
 80018f0:	68db      	ldr	r3, [r3, #12]
 80018f2:	9202      	str	r2, [sp, #8]
 80018f4:	9303      	str	r3, [sp, #12]
    for (index = 0U; index < lastwordsize; index++)
 80018f6:	2200      	movs	r2, #0
 80018f8:	42aa      	cmp	r2, r5
 80018fa:	f43f af59 	beq.w	80017b0 <CRYP_AESGCM_Process+0x4c>
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + (hcryp->CrypOutCount)) = temp[index];
 80018fe:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
 8001902:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8001904:	f85d 0022 	ldr.w	r0, [sp, r2, lsl #2]
 8001908:	b29b      	uxth	r3, r3
    for (index = 0U; index < lastwordsize; index++)
 800190a:	3201      	adds	r2, #1
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + (hcryp->CrypOutCount)) = temp[index];
 800190c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
      hcryp->CrypOutCount++;
 8001910:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
 8001914:	3301      	adds	r3, #1
 8001916:	b29b      	uxth	r3, r3
 8001918:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
    for (index = 0U; index < lastwordsize; index++)
 800191c:	e7ec      	b.n	80018f8 <CRYP_AESGCM_Process+0x194>
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 800191e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001920:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8001922:	b29b      	uxth	r3, r3
    for (index = 0U; index < lastwordsize; index ++)
 8001924:	3201      	adds	r2, #1
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 8001926:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800192a:	608b      	str	r3, [r1, #8]
      hcryp->CrypInCount++;
 800192c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800192e:	3301      	adds	r3, #1
 8001930:	b29b      	uxth	r3, r3
 8001932:	87e3      	strh	r3, [r4, #62]	; 0x3e
    for (index = 0U; index < lastwordsize; index ++)
 8001934:	e7be      	b.n	80018b4 <CRYP_AESGCM_Process+0x150>
      hcryp->Instance->DINR  = 0U;
 8001936:	608a      	str	r2, [r1, #8]
      index++;
 8001938:	3301      	adds	r3, #1
 800193a:	e7bf      	b.n	80018bc <CRYP_AESGCM_Process+0x158>
      return HAL_ERROR;
 800193c:	2001      	movs	r0, #1
 800193e:	e761      	b.n	8001804 <CRYP_AESGCM_Process+0xa0>

08001940 <HAL_CRYP_Decrypt>:
{
 8001940:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001942:	4604      	mov	r4, r0
  if (hcryp->State == HAL_CRYP_STATE_READY)
 8001944:	f890 0051 	ldrb.w	r0, [r0, #81]	; 0x51
{
 8001948:	9e06      	ldr	r6, [sp, #24]
  if (hcryp->State == HAL_CRYP_STATE_READY)
 800194a:	2801      	cmp	r0, #1
 800194c:	b2c5      	uxtb	r5, r0
 800194e:	f040 80ba 	bne.w	8001ac6 <HAL_CRYP_Decrypt+0x186>
    __HAL_LOCK(hcryp);
 8001952:	f894 7050 	ldrb.w	r7, [r4, #80]	; 0x50
    hcryp->State = HAL_CRYP_STATE_BUSY;
 8001956:	2002      	movs	r0, #2
    __HAL_LOCK(hcryp);
 8001958:	2f01      	cmp	r7, #1
    hcryp->State = HAL_CRYP_STATE_BUSY;
 800195a:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
    __HAL_LOCK(hcryp);
 800195e:	f000 80b8 	beq.w	8001ad2 <HAL_CRYP_Decrypt+0x192>
    hcryp->pCrypOutBuffPtr = Output;
 8001962:	e9c4 130d 	strd	r1, r3, [r4, #52]	; 0x34
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 8001966:	6a63      	ldr	r3, [r4, #36]	; 0x24
    __HAL_LOCK(hcryp);
 8001968:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
    hcryp->CrypInCount = 0U;
 800196c:	2000      	movs	r0, #0
 800196e:	87e0      	strh	r0, [r4, #62]	; 0x3e
    hcryp->CrypOutCount = 0U;
 8001970:	f8a4 0040 	strh.w	r0, [r4, #64]	; 0x40
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 8001974:	b90b      	cbnz	r3, 800197a <HAL_CRYP_Decrypt+0x3a>
      hcryp->Size = Size * 4U;
 8001976:	0092      	lsls	r2, r2, #2
 8001978:	b292      	uxth	r2, r2
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 800197a:	6823      	ldr	r3, [r4, #0]
 800197c:	f8a4 2042 	strh.w	r2, [r4, #66]	; 0x42
 8001980:	681a      	ldr	r2, [r3, #0]
 8001982:	f022 0218 	bic.w	r2, r2, #24
 8001986:	f042 0210 	orr.w	r2, r2, #16
 800198a:	601a      	str	r2, [r3, #0]
    algo = hcryp->Instance->CR & AES_CR_CHMOD;
 800198c:	6819      	ldr	r1, [r3, #0]
 800198e:	4a52      	ldr	r2, [pc, #328]	; (8001ad8 <HAL_CRYP_Decrypt+0x198>)
 8001990:	400a      	ands	r2, r1
    switch (algo)
 8001992:	2a60      	cmp	r2, #96	; 0x60
 8001994:	f000 808f 	beq.w	8001ab6 <HAL_CRYP_Decrypt+0x176>
 8001998:	d809      	bhi.n	80019ae <HAL_CRYP_Decrypt+0x6e>
 800199a:	2a40      	cmp	r2, #64	; 0x40
 800199c:	d00f      	beq.n	80019be <HAL_CRYP_Decrypt+0x7e>
 800199e:	4a4f      	ldr	r2, [pc, #316]	; (8001adc <HAL_CRYP_Decrypt+0x19c>)
 80019a0:	400a      	ands	r2, r1
 80019a2:	b162      	cbz	r2, 80019be <HAL_CRYP_Decrypt+0x7e>
        hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;
 80019a4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80019a6:	f043 0320 	orr.w	r3, r3, #32
 80019aa:	6563      	str	r3, [r4, #84]	; 0x54
    if (status == HAL_OK)
 80019ac:	e036      	b.n	8001a1c <HAL_CRYP_Decrypt+0xdc>
    switch (algo)
 80019ae:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 80019b2:	d1f7      	bne.n	80019a4 <HAL_CRYP_Decrypt+0x64>
        status = CRYP_AESCCM_Process(hcryp, Timeout);
 80019b4:	4631      	mov	r1, r6
 80019b6:	4620      	mov	r0, r4
 80019b8:	f7ff fdee 	bl	8001598 <CRYP_AESCCM_Process>
 80019bc:	e07f      	b.n	8001abe <HAL_CRYP_Decrypt+0x17e>
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 80019be:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80019c0:	2a01      	cmp	r2, #1
 80019c2:	d103      	bne.n	80019cc <HAL_CRYP_Decrypt+0x8c>
    if (hcryp->KeyIVConfig == 1U)
 80019c4:	6da1      	ldr	r1, [r4, #88]	; 0x58
 80019c6:	2901      	cmp	r1, #1
 80019c8:	d03f      	beq.n	8001a4a <HAL_CRYP_Decrypt+0x10a>
      hcryp->KeyIVConfig = 1U;
 80019ca:	65a2      	str	r2, [r4, #88]	; 0x58
    if (hcryp->Init.Algorithm != CRYP_AES_CTR)   /*ECB or CBC*/
 80019cc:	6962      	ldr	r2, [r4, #20]
 80019ce:	68a1      	ldr	r1, [r4, #8]
 80019d0:	2a40      	cmp	r2, #64	; 0x40
 80019d2:	d067      	beq.n	8001aa4 <HAL_CRYP_Decrypt+0x164>
      if (hcryp->AutoKeyDerivation == DISABLE)/*Mode 2 Key preparation*/
 80019d4:	f894 7030 	ldrb.w	r7, [r4, #48]	; 0x30
 80019d8:	2f00      	cmp	r7, #0
 80019da:	d15a      	bne.n	8001a92 <HAL_CRYP_Decrypt+0x152>
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION);
 80019dc:	681a      	ldr	r2, [r3, #0]
 80019de:	f022 0218 	bic.w	r2, r2, #24
 80019e2:	f042 0208 	orr.w	r2, r2, #8
 80019e6:	601a      	str	r2, [r3, #0]
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 80019e8:	4620      	mov	r0, r4
 80019ea:	f7ff fc00 	bl	80011ee <CRYP_SetKey>
        __HAL_CRYP_ENABLE(hcryp);
 80019ee:	6822      	ldr	r2, [r4, #0]
 80019f0:	6813      	ldr	r3, [r2, #0]
 80019f2:	f043 0301 	orr.w	r3, r3, #1
 80019f6:	6013      	str	r3, [r2, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80019f8:	4631      	mov	r1, r6
 80019fa:	f7ff fc19 	bl	8001230 <CRYP_WaitOnCCFlag>
 80019fe:	6823      	ldr	r3, [r4, #0]
          __HAL_CRYP_DISABLE(hcryp);
 8001a00:	681a      	ldr	r2, [r3, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8001a02:	b168      	cbz	r0, 8001a20 <HAL_CRYP_Decrypt+0xe0>
          __HAL_CRYP_DISABLE(hcryp);
 8001a04:	f022 0201 	bic.w	r2, r2, #1
 8001a08:	601a      	str	r2, [r3, #0]
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8001a0a:	6d63      	ldr	r3, [r4, #84]	; 0x54
          __HAL_UNLOCK(hcryp);
 8001a0c:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8001a10:	f043 0310 	orr.w	r3, r3, #16
 8001a14:	6563      	str	r3, [r4, #84]	; 0x54
          hcryp->State = HAL_CRYP_STATE_READY;
 8001a16:	2301      	movs	r3, #1
 8001a18:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
}
 8001a1c:	4628      	mov	r0, r5
 8001a1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8001a20:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001a24:	601a      	str	r2, [r3, #0]
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 8001a26:	681a      	ldr	r2, [r3, #0]
 8001a28:	f022 0218 	bic.w	r2, r2, #24
 8001a2c:	f042 0210 	orr.w	r2, r2, #16
 8001a30:	601a      	str	r2, [r3, #0]
    if (hcryp->Init.Algorithm != CRYP_AES_ECB)
 8001a32:	6963      	ldr	r3, [r4, #20]
 8001a34:	b14b      	cbz	r3, 8001a4a <HAL_CRYP_Decrypt+0x10a>
      hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 8001a36:	6922      	ldr	r2, [r4, #16]
 8001a38:	6823      	ldr	r3, [r4, #0]
 8001a3a:	6811      	ldr	r1, [r2, #0]
 8001a3c:	62d9      	str	r1, [r3, #44]	; 0x2c
      hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 8001a3e:	6851      	ldr	r1, [r2, #4]
 8001a40:	6299      	str	r1, [r3, #40]	; 0x28
      hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 8001a42:	6891      	ldr	r1, [r2, #8]
 8001a44:	6259      	str	r1, [r3, #36]	; 0x24
      hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 8001a46:	68d2      	ldr	r2, [r2, #12]
 8001a48:	621a      	str	r2, [r3, #32]
  __HAL_CRYP_ENABLE(hcryp);
 8001a4a:	6822      	ldr	r2, [r4, #0]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 8001a4c:	2302      	movs	r3, #2
 8001a4e:	6463      	str	r3, [r4, #68]	; 0x44
  __HAL_CRYP_ENABLE(hcryp);
 8001a50:	6813      	ldr	r3, [r2, #0]
 8001a52:	f043 0301 	orr.w	r3, r3, #1
 8001a56:	6013      	str	r3, [r2, #0]
    incount = hcryp->CrypInCount;
 8001a58:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 8001a5a:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
    outcount = hcryp->CrypOutCount;
 8001a5e:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
    incount = hcryp->CrypInCount;
 8001a62:	b292      	uxth	r2, r2
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 8001a64:	ebb2 0f91 	cmp.w	r2, r1, lsr #2
    outcount = hcryp->CrypOutCount;
 8001a68:	b29b      	uxth	r3, r3
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 8001a6a:	ea4f 0091 	mov.w	r0, r1, lsr #2
 8001a6e:	d201      	bcs.n	8001a74 <HAL_CRYP_Decrypt+0x134>
 8001a70:	4298      	cmp	r0, r3
 8001a72:	d81b      	bhi.n	8001aac <HAL_CRYP_Decrypt+0x16c>
  __HAL_CRYP_DISABLE(hcryp);
 8001a74:	6822      	ldr	r2, [r4, #0]
 8001a76:	6813      	ldr	r3, [r2, #0]
 8001a78:	f023 0301 	bic.w	r3, r3, #1
 8001a7c:	6013      	str	r3, [r2, #0]
  hcryp->State = HAL_CRYP_STATE_READY;
 8001a7e:	2301      	movs	r3, #1
 8001a80:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
      hcryp->State = HAL_CRYP_STATE_READY;
 8001a84:	2301      	movs	r3, #1
      __HAL_UNLOCK(hcryp);
 8001a86:	2500      	movs	r5, #0
      hcryp->State = HAL_CRYP_STATE_READY;
 8001a88:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
      __HAL_UNLOCK(hcryp);
 8001a8c:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
 8001a90:	e7c4      	b.n	8001a1c <HAL_CRYP_Decrypt+0xdc>
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8001a92:	4620      	mov	r0, r4
 8001a94:	f7ff fbab 	bl	80011ee <CRYP_SetKey>
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION_DECRYPT);
 8001a98:	6822      	ldr	r2, [r4, #0]
 8001a9a:	6813      	ldr	r3, [r2, #0]
 8001a9c:	f043 0318 	orr.w	r3, r3, #24
 8001aa0:	6013      	str	r3, [r2, #0]
 8001aa2:	e7c6      	b.n	8001a32 <HAL_CRYP_Decrypt+0xf2>
      CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8001aa4:	4620      	mov	r0, r4
 8001aa6:	f7ff fba2 	bl	80011ee <CRYP_SetKey>
 8001aaa:	e7c2      	b.n	8001a32 <HAL_CRYP_Decrypt+0xf2>
    CRYP_AES_ProcessData(hcryp, Timeout);
 8001aac:	4631      	mov	r1, r6
 8001aae:	4620      	mov	r0, r4
 8001ab0:	f7ff fd09 	bl	80014c6 <CRYP_AES_ProcessData>
 8001ab4:	e7d0      	b.n	8001a58 <HAL_CRYP_Decrypt+0x118>
        status = CRYP_AESGCM_Process(hcryp, Timeout) ;
 8001ab6:	4631      	mov	r1, r6
 8001ab8:	4620      	mov	r0, r4
 8001aba:	f7ff fe53 	bl	8001764 <CRYP_AESGCM_Process>
        status = CRYP_AESCCM_Process(hcryp, Timeout);
 8001abe:	4605      	mov	r5, r0
    if (status == HAL_OK)
 8001ac0:	2800      	cmp	r0, #0
 8001ac2:	d1ab      	bne.n	8001a1c <HAL_CRYP_Decrypt+0xdc>
 8001ac4:	e7de      	b.n	8001a84 <HAL_CRYP_Decrypt+0x144>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 8001ac6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001ac8:	f043 0308 	orr.w	r3, r3, #8
 8001acc:	6563      	str	r3, [r4, #84]	; 0x54
    status = HAL_ERROR;
 8001ace:	2501      	movs	r5, #1
 8001ad0:	e7a4      	b.n	8001a1c <HAL_CRYP_Decrypt+0xdc>
    __HAL_LOCK(hcryp);
 8001ad2:	4605      	mov	r5, r0
 8001ad4:	e7a2      	b.n	8001a1c <HAL_CRYP_Decrypt+0xdc>
 8001ad6:	bf00      	nop
 8001ad8:	00010060 	.word	0x00010060
 8001adc:	00010040 	.word	0x00010040

08001ae0 <HAL_FLASH_Unlock>:
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  HAL_StatusTypeDef status = HAL_OK;

  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8001ae0:	4b06      	ldr	r3, [pc, #24]	; (8001afc <HAL_FLASH_Unlock+0x1c>)
 8001ae2:	695a      	ldr	r2, [r3, #20]
 8001ae4:	2a00      	cmp	r2, #0
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8001ae6:	bfbf      	itttt	lt
 8001ae8:	4a05      	ldrlt	r2, [pc, #20]	; (8001b00 <HAL_FLASH_Unlock+0x20>)
 8001aea:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8001aec:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 8001af0:	609a      	strlt	r2, [r3, #8]

    /* verify Flash is unlock */
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8001af2:	bfba      	itte	lt
 8001af4:	6958      	ldrlt	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_OK;
 8001af6:	0fc0      	lsrlt	r0, r0, #31
 8001af8:	2000      	movge	r0, #0
      status = HAL_ERROR;
    }
  }

  return status;
}
 8001afa:	4770      	bx	lr
 8001afc:	58004000 	.word	0x58004000
 8001b00:	45670123 	.word	0x45670123

08001b04 <HAL_FLASH_Lock>:
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Set the LOCK Bit to lock the FLASH Registers access */
  /* @Note  The lock and unlock procedure is done only using CR registers even from CPU2 */
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8001b04:	4b04      	ldr	r3, [pc, #16]	; (8001b18 <HAL_FLASH_Lock+0x14>)
 8001b06:	695a      	ldr	r2, [r3, #20]
 8001b08:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8001b0c:	615a      	str	r2, [r3, #20]

  /* verify Flash is locked */
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) == 0U)
 8001b0e:	6958      	ldr	r0, [r3, #20]
  {
    status = HAL_ERROR;
  }

  return status;
}
 8001b10:	43c0      	mvns	r0, r0
 8001b12:	0fc0      	lsrs	r0, r0, #31
 8001b14:	4770      	bx	lr
 8001b16:	bf00      	nop
 8001b18:	58004000 	.word	0x58004000

08001b1c <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout Maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
 8001b1c:	b570      	push	{r4, r5, r6, lr}
 8001b1e:	4605      	mov	r5, r0
  uint32_t error;
  uint32_t tickstart = HAL_GetTick();
 8001b20:	f000 fd6c 	bl	80025fc <HAL_GetTick>

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8001b24:	4e13      	ldr	r6, [pc, #76]	; (8001b74 <FLASH_WaitForLastOperation+0x58>)
  uint32_t tickstart = HAL_GetTick();
 8001b26:	4604      	mov	r4, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8001b28:	6933      	ldr	r3, [r6, #16]
 8001b2a:	03d9      	lsls	r1, r3, #15
 8001b2c:	d40f      	bmi.n	8001b4e <FLASH_WaitForLastOperation+0x32>
      return HAL_TIMEOUT;
    }
  }

  /* Check FLASH operation error flags */
  error = FLASH->SR;
 8001b2e:	6933      	ldr	r3, [r6, #16]

  /* Check FLASH End of Operation flag */
  if ((error & FLASH_FLAG_EOP) != 0U)
 8001b30:	07da      	lsls	r2, r3, #31
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001b32:	bf44      	itt	mi
 8001b34:	2201      	movmi	r2, #1
 8001b36:	6132      	strmi	r2, [r6, #16]
  }

  /* Now update error variable to only error value */
  error &= FLASH_FLAG_SR_ERRORS;
 8001b38:	f24c 32fa 	movw	r2, #50170	; 0xc3fa

  /* clear error flags */
  __HAL_FLASH_CLEAR_FLAG(error);
 8001b3c:	4013      	ands	r3, r2
 8001b3e:	d10d      	bne.n	8001b5c <FLASH_WaitForLastOperation+0x40>

    return HAL_ERROR;
  }

  /* Wait for control register to be written */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 8001b40:	4e0c      	ldr	r6, [pc, #48]	; (8001b74 <FLASH_WaitForLastOperation+0x58>)
 8001b42:	6933      	ldr	r3, [r6, #16]
 8001b44:	f413 2380 	ands.w	r3, r3, #262144	; 0x40000
 8001b48:	d10e      	bne.n	8001b68 <FLASH_WaitForLastOperation+0x4c>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 8001b4a:	4618      	mov	r0, r3
 8001b4c:	e005      	b.n	8001b5a <FLASH_WaitForLastOperation+0x3e>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8001b4e:	f000 fd55 	bl	80025fc <HAL_GetTick>
 8001b52:	1b00      	subs	r0, r0, r4
 8001b54:	42a8      	cmp	r0, r5
 8001b56:	d3e7      	bcc.n	8001b28 <FLASH_WaitForLastOperation+0xc>
      return HAL_TIMEOUT;
 8001b58:	2003      	movs	r0, #3
}
 8001b5a:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_FLASH_CLEAR_FLAG(error);
 8001b5c:	4a05      	ldr	r2, [pc, #20]	; (8001b74 <FLASH_WaitForLastOperation+0x58>)
 8001b5e:	6113      	str	r3, [r2, #16]
    pFlash.ErrorCode = error;
 8001b60:	4a05      	ldr	r2, [pc, #20]	; (8001b78 <FLASH_WaitForLastOperation+0x5c>)
    return HAL_ERROR;
 8001b62:	2001      	movs	r0, #1
    pFlash.ErrorCode = error;
 8001b64:	6053      	str	r3, [r2, #4]
    return HAL_ERROR;
 8001b66:	e7f8      	b.n	8001b5a <FLASH_WaitForLastOperation+0x3e>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8001b68:	f000 fd48 	bl	80025fc <HAL_GetTick>
 8001b6c:	1b00      	subs	r0, r0, r4
 8001b6e:	42a8      	cmp	r0, r5
 8001b70:	d3e7      	bcc.n	8001b42 <FLASH_WaitForLastOperation+0x26>
 8001b72:	e7f1      	b.n	8001b58 <FLASH_WaitForLastOperation+0x3c>
 8001b74:	58004000 	.word	0x58004000
 8001b78:	20000598 	.word	0x20000598

08001b7c <HAL_FLASH_Program>:
{
 8001b7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 8001b80:	4c18      	ldr	r4, [pc, #96]	; (8001be4 <HAL_FLASH_Program+0x68>)
{
 8001b82:	4698      	mov	r8, r3
  __HAL_LOCK(&pFlash);
 8001b84:	7823      	ldrb	r3, [r4, #0]
 8001b86:	2b01      	cmp	r3, #1
{
 8001b88:	4606      	mov	r6, r0
 8001b8a:	460d      	mov	r5, r1
 8001b8c:	4617      	mov	r7, r2
  __HAL_LOCK(&pFlash);
 8001b8e:	d026      	beq.n	8001bde <HAL_FLASH_Program+0x62>
 8001b90:	2301      	movs	r3, #1
 8001b92:	7023      	strb	r3, [r4, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8001b94:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001b98:	2300      	movs	r3, #0
 8001b9a:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8001b9c:	f7ff ffbe 	bl	8001b1c <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 8001ba0:	b9a0      	cbnz	r0, 8001bcc <HAL_FLASH_Program+0x50>
    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 8001ba2:	2e01      	cmp	r6, #1
 8001ba4:	d116      	bne.n	8001bd4 <HAL_FLASH_Program+0x58>
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
  /* Set PG bit */
  SET_BIT(FLASH->CR, FLASH_CR_PG);
 8001ba6:	4a10      	ldr	r2, [pc, #64]	; (8001be8 <HAL_FLASH_Program+0x6c>)
 8001ba8:	6953      	ldr	r3, [r2, #20]
 8001baa:	f043 0301 	orr.w	r3, r3, #1
 8001bae:	6153      	str	r3, [r2, #20]

  /* Program first word */
  *(uint32_t *)Address = (uint32_t)Data;
 8001bb0:	602f      	str	r7, [r5, #0]
 8001bb2:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
 8001bb6:	f8c5 8004 	str.w	r8, [r5, #4]
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8001bba:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001bbe:	f7ff ffad 	bl	8001b1c <FLASH_WaitForLastOperation>
    CLEAR_BIT(FLASH->CR, TypeProgram);
 8001bc2:	4a09      	ldr	r2, [pc, #36]	; (8001be8 <HAL_FLASH_Program+0x6c>)
 8001bc4:	6953      	ldr	r3, [r2, #20]
 8001bc6:	ea23 0606 	bic.w	r6, r3, r6
 8001bca:	6156      	str	r6, [r2, #20]
  __HAL_UNLOCK(&pFlash);
 8001bcc:	2300      	movs	r3, #0
 8001bce:	7023      	strb	r3, [r4, #0]
}
 8001bd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      FLASH_Program_Fast(Address, (uint32_t)Data);
 8001bd4:	4639      	mov	r1, r7
 8001bd6:	4628      	mov	r0, r5
 8001bd8:	f001 f9ba 	bl	8002f50 <_etext>
 8001bdc:	e7ed      	b.n	8001bba <HAL_FLASH_Program+0x3e>
  __HAL_LOCK(&pFlash);
 8001bde:	2002      	movs	r0, #2
 8001be0:	e7f6      	b.n	8001bd0 <HAL_FLASH_Program+0x54>
 8001be2:	bf00      	nop
 8001be4:	20000598 	.word	0x20000598
 8001be8:	58004000 	.word	0x58004000

08001bec <FLASH_PageErase>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_PAGE(Page));

  /* Proceed to erase the page */
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 8001bec:	4a05      	ldr	r2, [pc, #20]	; (8001c04 <FLASH_PageErase+0x18>)
 8001bee:	6953      	ldr	r3, [r2, #20]
 8001bf0:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8001bf4:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
 8001bf8:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 8001bfc:	f040 0002 	orr.w	r0, r0, #2
 8001c00:	6150      	str	r0, [r2, #20]
}
 8001c02:	4770      	bx	lr
 8001c04:	58004000 	.word	0x58004000

08001c08 <HAL_FLASHEx_Erase>:
{
 8001c08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 8001c0c:	4d30      	ldr	r5, [pc, #192]	; (8001cd0 <HAL_FLASHEx_Erase+0xc8>)
 8001c0e:	782b      	ldrb	r3, [r5, #0]
 8001c10:	2b01      	cmp	r3, #1
{
 8001c12:	4606      	mov	r6, r0
 8001c14:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 8001c16:	d059      	beq.n	8001ccc <HAL_FLASHEx_Erase+0xc4>
 8001c18:	2301      	movs	r3, #1
 8001c1a:	702b      	strb	r3, [r5, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8001c1c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001c20:	2300      	movs	r3, #0
 8001c22:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8001c24:	f7ff ff7a 	bl	8001b1c <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 8001c28:	4604      	mov	r4, r0
 8001c2a:	2800      	cmp	r0, #0
 8001c2c:	d147      	bne.n	8001cbe <HAL_FLASHEx_Erase+0xb6>
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_PAGES)
 8001c2e:	6833      	ldr	r3, [r6, #0]
 8001c30:	2b02      	cmp	r3, #2
 8001c32:	d11c      	bne.n	8001c6e <HAL_FLASHEx_Erase+0x66>
      *PageError = 0xFFFFFFFFU;
 8001c34:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001c38:	f8c8 3000 	str.w	r3, [r8]
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 8001c3c:	6877      	ldr	r7, [r6, #4]
 8001c3e:	e9d6 3201 	ldrd	r3, r2, [r6, #4]
 8001c42:	4413      	add	r3, r2
 8001c44:	42bb      	cmp	r3, r7
 8001c46:	d90b      	bls.n	8001c60 <HAL_FLASHEx_Erase+0x58>
        FLASH_PageErase(index);
 8001c48:	4638      	mov	r0, r7
 8001c4a:	f7ff ffcf 	bl	8001bec <FLASH_PageErase>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8001c4e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001c52:	f7ff ff63 	bl	8001b1c <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 8001c56:	2800      	cmp	r0, #0
 8001c58:	d036      	beq.n	8001cc8 <HAL_FLASHEx_Erase+0xc0>
          *PageError = index;
 8001c5a:	f8c8 7000 	str.w	r7, [r8]
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8001c5e:	4604      	mov	r4, r0
  * @brief  Acknlowldge the page erase operation.
  * @retval None
  */
static void FLASH_AcknowledgePageErase(void)
{
  CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 8001c60:	4a1c      	ldr	r2, [pc, #112]	; (8001cd4 <HAL_FLASHEx_Erase+0xcc>)
 8001c62:	6953      	ldr	r3, [r2, #20]
 8001c64:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8001c68:	f023 0302 	bic.w	r3, r3, #2
 8001c6c:	6153      	str	r3, [r2, #20]
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) == FLASH_ACR_ICEN)
 8001c6e:	4b19      	ldr	r3, [pc, #100]	; (8001cd4 <HAL_FLASHEx_Erase+0xcc>)
 8001c70:	681a      	ldr	r2, [r3, #0]
 8001c72:	0591      	lsls	r1, r2, #22
 8001c74:	d50f      	bpl.n	8001c96 <HAL_FLASHEx_Erase+0x8e>
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8001c76:	681a      	ldr	r2, [r3, #0]
 8001c78:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001c7c:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 8001c7e:	681a      	ldr	r2, [r3, #0]
 8001c80:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001c84:	601a      	str	r2, [r3, #0]
 8001c86:	681a      	ldr	r2, [r3, #0]
 8001c88:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001c8c:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001c8e:	681a      	ldr	r2, [r3, #0]
 8001c90:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001c94:	601a      	str	r2, [r3, #0]
  if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) == FLASH_ACR_DCEN)
 8001c96:	4b0f      	ldr	r3, [pc, #60]	; (8001cd4 <HAL_FLASHEx_Erase+0xcc>)
 8001c98:	681a      	ldr	r2, [r3, #0]
 8001c9a:	0552      	lsls	r2, r2, #21
 8001c9c:	d50f      	bpl.n	8001cbe <HAL_FLASHEx_Erase+0xb6>
    __HAL_FLASH_DATA_CACHE_DISABLE();
 8001c9e:	681a      	ldr	r2, [r3, #0]
 8001ca0:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001ca4:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_DATA_CACHE_RESET();
 8001ca6:	681a      	ldr	r2, [r3, #0]
 8001ca8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001cac:	601a      	str	r2, [r3, #0]
 8001cae:	681a      	ldr	r2, [r3, #0]
 8001cb0:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8001cb4:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_DATA_CACHE_ENABLE();
 8001cb6:	681a      	ldr	r2, [r3, #0]
 8001cb8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001cbc:	601a      	str	r2, [r3, #0]
  __HAL_UNLOCK(&pFlash);
 8001cbe:	2300      	movs	r3, #0
 8001cc0:	702b      	strb	r3, [r5, #0]
}
 8001cc2:	4620      	mov	r0, r4
 8001cc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 8001cc8:	3701      	adds	r7, #1
 8001cca:	e7b8      	b.n	8001c3e <HAL_FLASHEx_Erase+0x36>
  __HAL_LOCK(&pFlash);
 8001ccc:	2402      	movs	r4, #2
 8001cce:	e7f8      	b.n	8001cc2 <HAL_FLASHEx_Erase+0xba>
 8001cd0:	20000598 	.word	0x20000598
 8001cd4:	58004000 	.word	0x58004000

08001cd8 <HAL_PKA_Init>:
  *         parameters in the PKA_InitTypeDef and initialize the associated handle.
  * @param  hpka PKA handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PKA_Init(PKA_HandleTypeDef *hpka)
{
 8001cd8:	b510      	push	{r4, lr}
  HAL_StatusTypeDef err = HAL_OK;

  /* Check the PKA handle allocation */
  if (hpka != NULL)
 8001cda:	4604      	mov	r4, r0
 8001cdc:	b180      	cbz	r0, 8001d00 <HAL_PKA_Init+0x28>
  {
    /* Check the parameters */
    assert_param(IS_PKA_ALL_INSTANCE(hpka->Instance));

    if (hpka->State == HAL_PKA_STATE_RESET)
 8001cde:	7903      	ldrb	r3, [r0, #4]
 8001ce0:	b90b      	cbnz	r3, 8001ce6 <HAL_PKA_Init+0xe>

      /* Init the low level hardware */
      hpka->MspInitCallback(hpka);
#else
      /* Init the low level hardware */
      HAL_PKA_MspInit(hpka);
 8001ce2:	f7ff f9d5 	bl	8001090 <HAL_PKA_MspInit>
#endif /* USE_HAL_PKA_REGISTER_CALLBACKS */
    }

    /* Set the state to busy */
    hpka->State = HAL_PKA_STATE_BUSY;
 8001ce6:	2302      	movs	r3, #2
 8001ce8:	7123      	strb	r3, [r4, #4]

    /* Reset the control register and enable the PKA */
    hpka->Instance->CR = PKA_CR_EN;
 8001cea:	6823      	ldr	r3, [r4, #0]
 8001cec:	2101      	movs	r1, #1
 8001cee:	6019      	str	r1, [r3, #0]

    /* Reset any pending flag */
    SET_BIT(hpka->Instance->CLRFR, PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC);
 8001cf0:	689a      	ldr	r2, [r3, #8]

    /* Initialize the error code */
    hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 8001cf2:	2000      	movs	r0, #0
    SET_BIT(hpka->Instance->CLRFR, PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC);
 8001cf4:	f442 12d0 	orr.w	r2, r2, #1703936	; 0x1a0000
 8001cf8:	609a      	str	r2, [r3, #8]
    hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 8001cfa:	60a0      	str	r0, [r4, #8]

    /* Set the state to ready */
    hpka->State = HAL_PKA_STATE_READY;
 8001cfc:	7121      	strb	r1, [r4, #4]
  {
    err = HAL_ERROR;
  }

  return err;
}
 8001cfe:	bd10      	pop	{r4, pc}
    err = HAL_ERROR;
 8001d00:	2001      	movs	r0, #1
 8001d02:	e7fc      	b.n	8001cfe <HAL_PKA_Init+0x26>

08001d04 <HAL_PKA_DeInit>:
  * @brief  DeInitialize the PKA peripheral.
  * @param  hpka PKA handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PKA_DeInit(PKA_HandleTypeDef *hpka)
{
 8001d04:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef err = HAL_OK;

  /* Check the PKA handle allocation */
  if (hpka != NULL)
 8001d06:	4605      	mov	r5, r0
 8001d08:	b170      	cbz	r0, 8001d28 <HAL_PKA_DeInit+0x24>
  {
    /* Check the parameters */
    assert_param(IS_PKA_ALL_INSTANCE(hpka->Instance));

    /* Set the state to busy */
    hpka->State = HAL_PKA_STATE_BUSY;
 8001d0a:	2302      	movs	r3, #2
 8001d0c:	7103      	strb	r3, [r0, #4]

    /* Reset the control register */
    /* This abort any operation in progress (PKA RAM content is not guaranted in this case) */
    hpka->Instance->CR = 0;
 8001d0e:	6803      	ldr	r3, [r0, #0]
 8001d10:	2400      	movs	r4, #0
 8001d12:	601c      	str	r4, [r3, #0]

    /* Reset any pending flag */
    SET_BIT(hpka->Instance->CLRFR, PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC);
 8001d14:	689a      	ldr	r2, [r3, #8]
 8001d16:	f442 12d0 	orr.w	r2, r2, #1703936	; 0x1a0000
 8001d1a:	609a      	str	r2, [r3, #8]

    /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    hpka->MspDeInitCallback(hpka);
#else
    /* DeInit the low level hardware: CLOCK, NVIC */
    HAL_PKA_MspDeInit(hpka);
 8001d1c:	f7ff f9cc 	bl	80010b8 <HAL_PKA_MspDeInit>
#endif /* USE_HAL_PKA_REGISTER_CALLBACKS */

    /* Reset the error code */
    hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 8001d20:	60ac      	str	r4, [r5, #8]
  HAL_StatusTypeDef err = HAL_OK;
 8001d22:	4620      	mov	r0, r4

    /* Reset the state */
    hpka->State = HAL_PKA_STATE_RESET;
 8001d24:	712c      	strb	r4, [r5, #4]
  {
    err = HAL_ERROR;
  }

  return err;
}
 8001d26:	bd38      	pop	{r3, r4, r5, pc}
    err = HAL_ERROR;
 8001d28:	2001      	movs	r0, #1
 8001d2a:	e7fc      	b.n	8001d26 <HAL_PKA_DeInit+0x22>

08001d2c <HAL_PKA_ECDSAVerif_IsValidSignature>:
  * @retval 1 if signature is verified, 0 in other case
  */
uint32_t HAL_PKA_ECDSAVerif_IsValidSignature(PKA_HandleTypeDef const *const hpka)
{
  /* Invert the state of the PKA RAM bit containing the result of the operation */
  return (hpka->Instance->RAM[PKA_ECDSA_VERIF_OUT_RESULT] == 0UL) ? 1UL : 0UL;
 8001d2c:	6803      	ldr	r3, [r0, #0]
 8001d2e:	f8d3 05b0 	ldr.w	r0, [r3, #1456]	; 0x5b0
}
 8001d32:	fab0 f080 	clz	r0, r0
 8001d36:	0940      	lsrs	r0, r0, #5
 8001d38:	4770      	bx	lr

08001d3a <PKA_PollEndOfOperation>:
  * @param  Timeout Timeout duration in millisecond.
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
HAL_StatusTypeDef PKA_PollEndOfOperation(PKA_HandleTypeDef *hpka, uint32_t Timeout, uint32_t Tickstart)
{
 8001d3a:	b570      	push	{r4, r5, r6, lr}
 8001d3c:	4605      	mov	r5, r0
 8001d3e:	460c      	mov	r4, r1
 8001d40:	4616      	mov	r6, r2
  /* Wait for the end of operation or timeout */
  while ((hpka->Instance->SR & PKA_SR_PROCENDF) == 0UL)
 8001d42:	682a      	ldr	r2, [r5, #0]
 8001d44:	6853      	ldr	r3, [r2, #4]
 8001d46:	039b      	lsls	r3, r3, #14
 8001d48:	d501      	bpl.n	8001d4e <PKA_PollEndOfOperation+0x14>
      {
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8001d4a:	2000      	movs	r0, #0
}
 8001d4c:	bd70      	pop	{r4, r5, r6, pc}
    if (Timeout != HAL_MAX_DELAY)
 8001d4e:	1c61      	adds	r1, r4, #1
 8001d50:	d0f8      	beq.n	8001d44 <PKA_PollEndOfOperation+0xa>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0UL))
 8001d52:	f000 fc53 	bl	80025fc <HAL_GetTick>
 8001d56:	1b80      	subs	r0, r0, r6
 8001d58:	42a0      	cmp	r0, r4
 8001d5a:	d801      	bhi.n	8001d60 <PKA_PollEndOfOperation+0x26>
 8001d5c:	2c00      	cmp	r4, #0
 8001d5e:	d1f0      	bne.n	8001d42 <PKA_PollEndOfOperation+0x8>
        return HAL_TIMEOUT;
 8001d60:	2003      	movs	r0, #3
 8001d62:	e7f3      	b.n	8001d4c <PKA_PollEndOfOperation+0x12>

08001d64 <PKA_CheckError>:
uint32_t PKA_CheckError(PKA_HandleTypeDef *hpka, uint32_t mode)
{
  uint32_t err = HAL_PKA_ERROR_NONE;

  /* Check RAMERR error */
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_RAMERR) == SET)
 8001d64:	6803      	ldr	r3, [r0, #0]
 8001d66:	6858      	ldr	r0, [r3, #4]
  {
    err |= HAL_PKA_ERROR_RAMERR;
  }

  /* Check ADDRERR error */
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_ADDRERR) == SET)
 8001d68:	685a      	ldr	r2, [r3, #4]
    err |= HAL_PKA_ERROR_RAMERR;
 8001d6a:	f410 2000 	ands.w	r0, r0, #524288	; 0x80000
 8001d6e:	bf18      	it	ne
 8001d70:	2002      	movne	r0, #2
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_ADDRERR) == SET)
 8001d72:	02d2      	lsls	r2, r2, #11
  {
    err |= HAL_PKA_ERROR_ADDRERR;
 8001d74:	bf48      	it	mi
 8001d76:	f040 0001 	orrmi.w	r0, r0, #1
  }

  /* Check the operation success in case of ECDSA signature */
  if (mode == PKA_MODE_ECDSA_SIGNATURE)
 8001d7a:	2924      	cmp	r1, #36	; 0x24
 8001d7c:	d104      	bne.n	8001d88 <PKA_CheckError+0x24>
  {
#define EDCSA_SIGN_NOERROR 0UL
    /* If error output result is different from no error, ecsa sign operation need to be repeated */
    if (hpka->Instance->RAM[PKA_ECDSA_SIGN_OUT_ERROR] != EDCSA_SIGN_NOERROR)
 8001d7e:	f8d3 3ee8 	ldr.w	r3, [r3, #3816]	; 0xee8
 8001d82:	b10b      	cbz	r3, 8001d88 <PKA_CheckError+0x24>
    {
      err |= HAL_PKA_ERROR_OPERATION;
 8001d84:	f040 0008 	orr.w	r0, r0, #8
    }
  }

  return err;
}
 8001d88:	4770      	bx	lr

08001d8a <PKA_GetOptBitSize_u8>:
  */
uint32_t PKA_GetOptBitSize_u8(uint32_t byteNumber, uint8_t msb)
{
  uint32_t position;

  position = 32UL - __CLZ(msb);
 8001d8a:	fab1 f181 	clz	r1, r1

  return (((byteNumber - 1UL) * 8UL) + position);
 8001d8e:	ebc1 00c0 	rsb	r0, r1, r0, lsl #3
}
 8001d92:	3018      	adds	r0, #24
 8001d94:	4770      	bx	lr

08001d96 <PKA_Memcpy_u8_to_u32>:
  * @param  src Pointer to source
  * @param  n Number of uint8_t to copy (must be multiple of 4)
  * @retval dst
  */
void PKA_Memcpy_u8_to_u32(__IO uint32_t dst[], const uint8_t src[], size_t n)
{
 8001d96:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (dst != NULL)
 8001d98:	b190      	cbz	r0, 8001dc0 <PKA_Memcpy_u8_to_u32+0x2a>
  {
    if (src != NULL)
 8001d9a:	b189      	cbz	r1, 8001dc0 <PKA_Memcpy_u8_to_u32+0x2a>
 8001d9c:	f022 0603 	bic.w	r6, r2, #3
 8001da0:	188d      	adds	r5, r1, r2
 8001da2:	4607      	mov	r7, r0
    {
      uint32_t index = 0UL; /* This index is used outside of the loop */

      for (; index < (n / 4UL); index++)
 8001da4:	0894      	lsrs	r4, r2, #2
 8001da6:	eb06 0c00 	add.w	ip, r6, r0
 8001daa:	4567      	cmp	r7, ip
 8001dac:	d109      	bne.n	8001dc2 <PKA_Memcpy_u8_to_u32+0x2c>
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
                     | ((uint32_t)src[(n - (index * 4UL) - 4UL)] << 24UL);
      }

      /* Manage the buffers not aligned on uint32_t */
      if ((n % 4UL) == 1UL)
 8001dae:	f002 0303 	and.w	r3, r2, #3
 8001db2:	2b01      	cmp	r3, #1
 8001db4:	d117      	bne.n	8001de6 <PKA_Memcpy_u8_to_u32+0x50>
      {
        dst[index] = (uint32_t)src[(n - (index * 4UL) - 1UL)];
 8001db6:	3a01      	subs	r2, #1
 8001db8:	1b92      	subs	r2, r2, r6
 8001dba:	5c8b      	ldrb	r3, [r1, r2]
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL);
      }
      else if ((n % 4UL) == 3UL)
      {
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 8001dbc:	f840 3024 	str.w	r3, [r0, r4, lsl #2]
      {
        /* The last element is already handle in the loop */
      }
    }
  }
}
 8001dc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
 8001dc2:	f815 3c03 	ldrb.w	r3, [r5, #-3]
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL) \
 8001dc6:	f815 ec02 	ldrb.w	lr, [r5, #-2]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
 8001dca:	041b      	lsls	r3, r3, #16
 8001dcc:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 8001dd0:	f815 ec01 	ldrb.w	lr, [r5, #-1]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
 8001dd4:	ea43 030e 	orr.w	r3, r3, lr
                     | ((uint32_t)src[(n - (index * 4UL) - 4UL)] << 24UL);
 8001dd8:	f815 ed04 	ldrb.w	lr, [r5, #-4]!
 8001ddc:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 8001de0:	f847 3b04 	str.w	r3, [r7], #4
      for (; index < (n / 4UL); index++)
 8001de4:	e7e1      	b.n	8001daa <PKA_Memcpy_u8_to_u32+0x14>
      else if ((n % 4UL) == 2UL)
 8001de6:	2b02      	cmp	r3, #2
 8001de8:	d108      	bne.n	8001dfc <PKA_Memcpy_u8_to_u32+0x66>
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 8001dea:	1b92      	subs	r2, r2, r6
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL);
 8001dec:	4411      	add	r1, r2
 8001dee:	f811 2c02 	ldrb.w	r2, [r1, #-2]
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 8001df2:	f811 3c01 	ldrb.w	r3, [r1, #-1]
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL);
 8001df6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001dfa:	e7df      	b.n	8001dbc <PKA_Memcpy_u8_to_u32+0x26>
      else if ((n % 4UL) == 3UL)
 8001dfc:	2b03      	cmp	r3, #3
 8001dfe:	d1df      	bne.n	8001dc0 <PKA_Memcpy_u8_to_u32+0x2a>
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 8001e00:	1b92      	subs	r2, r2, r6
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL) \
 8001e02:	440a      	add	r2, r1
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL);
 8001e04:	f812 3c03 	ldrb.w	r3, [r2, #-3]
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL) \
 8001e08:	f812 1c02 	ldrb.w	r1, [r2, #-2]
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 8001e0c:	f812 2c01 	ldrb.w	r2, [r2, #-1]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL);
 8001e10:	041b      	lsls	r3, r3, #16
 8001e12:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8001e16:	4313      	orrs	r3, r2
 8001e18:	e7d0      	b.n	8001dbc <PKA_Memcpy_u8_to_u32+0x26>

08001e1a <PKA_Process>:
  * @param  mode PKA operation
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef PKA_Process(PKA_HandleTypeDef *hpka, uint32_t mode, uint32_t Timeout)
{
 8001e1a:	b573      	push	{r0, r1, r4, r5, r6, lr}
  HAL_StatusTypeDef err = HAL_OK;
  uint32_t tickstart;

  if (hpka->State == HAL_PKA_STATE_READY)
 8001e1c:	7903      	ldrb	r3, [r0, #4]
 8001e1e:	2b01      	cmp	r3, #1
{
 8001e20:	4604      	mov	r4, r0
 8001e22:	460d      	mov	r5, r1
  if (hpka->State == HAL_PKA_STATE_READY)
 8001e24:	d13a      	bne.n	8001e9c <PKA_Process+0x82>
  {
    /* Set the state to busy */
    hpka->State = HAL_PKA_STATE_BUSY;
 8001e26:	2302      	movs	r3, #2
 8001e28:	7103      	strb	r3, [r0, #4]

    /* Clear any pending error */
    hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 8001e2a:	2300      	movs	r3, #0
 8001e2c:	6083      	str	r3, [r0, #8]
 8001e2e:	9201      	str	r2, [sp, #4]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 8001e30:	f000 fbe4 	bl	80025fc <HAL_GetTick>

    /* Set the mode and deactivate the interrupts */
    MODIFY_REG(hpka->Instance->CR, PKA_CR_MODE | PKA_CR_PROCENDIE | PKA_CR_RAMERRIE | PKA_CR_ADDRERRIE, mode << PKA_CR_MODE_Pos);
 8001e34:	6826      	ldr	r6, [r4, #0]

    /* Start the computation */
    hpka->Instance->CR |= PKA_CR_START;

    /* Wait for the end of operation or timeout */
    if (PKA_PollEndOfOperation(hpka, Timeout, tickstart) != HAL_OK)
 8001e36:	9901      	ldr	r1, [sp, #4]
    MODIFY_REG(hpka->Instance->CR, PKA_CR_MODE | PKA_CR_PROCENDIE | PKA_CR_RAMERRIE | PKA_CR_ADDRERRIE, mode << PKA_CR_MODE_Pos);
 8001e38:	6833      	ldr	r3, [r6, #0]
 8001e3a:	f423 13d1 	bic.w	r3, r3, #1712128	; 0x1a2000
 8001e3e:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8001e42:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8001e46:	6033      	str	r3, [r6, #0]
    hpka->Instance->CR |= PKA_CR_START;
 8001e48:	6833      	ldr	r3, [r6, #0]
 8001e4a:	f043 0302 	orr.w	r3, r3, #2
    tickstart = HAL_GetTick();
 8001e4e:	4602      	mov	r2, r0
    hpka->Instance->CR |= PKA_CR_START;
 8001e50:	6033      	str	r3, [r6, #0]
    if (PKA_PollEndOfOperation(hpka, Timeout, tickstart) != HAL_OK)
 8001e52:	4620      	mov	r0, r4
 8001e54:	f7ff ff71 	bl	8001d3a <PKA_PollEndOfOperation>
 8001e58:	b160      	cbz	r0, 8001e74 <PKA_Process+0x5a>
    {
      /* Abort any ongoing operation */
      CLEAR_BIT(hpka->Instance->CR, PKA_CR_EN);
 8001e5a:	6823      	ldr	r3, [r4, #0]
 8001e5c:	681a      	ldr	r2, [r3, #0]
 8001e5e:	f022 0201 	bic.w	r2, r2, #1
 8001e62:	601a      	str	r2, [r3, #0]

      hpka->ErrorCode |= HAL_PKA_ERROR_TIMEOUT;
 8001e64:	68a2      	ldr	r2, [r4, #8]
 8001e66:	f042 0204 	orr.w	r2, r2, #4
 8001e6a:	60a2      	str	r2, [r4, #8]

      /* Make ready for the next operation */
      SET_BIT(hpka->Instance->CR, PKA_CR_EN);
 8001e6c:	681a      	ldr	r2, [r3, #0]
 8001e6e:	f042 0201 	orr.w	r2, r2, #1
 8001e72:	601a      	str	r2, [r3, #0]
    }

    /* Check error */
    hpka->ErrorCode |= PKA_CheckError(hpka, mode);
 8001e74:	4629      	mov	r1, r5
 8001e76:	4620      	mov	r0, r4
 8001e78:	f7ff ff74 	bl	8001d64 <PKA_CheckError>
 8001e7c:	68a3      	ldr	r3, [r4, #8]

    /* Clear all flags */
    hpka->Instance->CLRFR |= (PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC);
 8001e7e:	6822      	ldr	r2, [r4, #0]
    hpka->ErrorCode |= PKA_CheckError(hpka, mode);
 8001e80:	4318      	orrs	r0, r3
 8001e82:	60a0      	str	r0, [r4, #8]
    hpka->Instance->CLRFR |= (PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC);
 8001e84:	6893      	ldr	r3, [r2, #8]
 8001e86:	f443 13d0 	orr.w	r3, r3, #1703936	; 0x1a0000
 8001e8a:	6093      	str	r3, [r2, #8]

    /* Set the state to ready */
    hpka->State = HAL_PKA_STATE_READY;
 8001e8c:	2301      	movs	r3, #1
 8001e8e:	7123      	strb	r3, [r4, #4]

    /* Manage the result based on encountered errors */
    if (hpka->ErrorCode != HAL_PKA_ERROR_NONE)
 8001e90:	68a0      	ldr	r0, [r4, #8]
    {
      err = HAL_ERROR;
 8001e92:	3800      	subs	r0, #0
 8001e94:	bf18      	it	ne
 8001e96:	2001      	movne	r0, #1
  else
  {
    err = HAL_ERROR;
  }
  return err;
}
 8001e98:	b002      	add	sp, #8
 8001e9a:	bd70      	pop	{r4, r5, r6, pc}
    err = HAL_ERROR;
 8001e9c:	2001      	movs	r0, #1
 8001e9e:	e7fb      	b.n	8001e98 <PKA_Process+0x7e>

08001ea0 <PKA_ECDSAVerif_Set>:
  * @brief  Set input parameters.
  * @param  hpka PKA handle
  * @param  in Input information
  */
void PKA_ECDSAVerif_Set(PKA_HandleTypeDef *hpka, PKA_ECDSAVerifInTypeDef *in)
{
 8001ea0:	b570      	push	{r4, r5, r6, lr}
  /* Get the prime order n length */
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_ORDER_NB_BITS] = PKA_GetOptBitSize_u8(in->primeOrderSize, *(in->primeOrder));
 8001ea2:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 8001ea4:	6803      	ldr	r3, [r0, #0]
{
 8001ea6:	460c      	mov	r4, r1
 8001ea8:	4605      	mov	r5, r0
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_ORDER_NB_BITS] = PKA_GetOptBitSize_u8(in->primeOrderSize, *(in->primeOrder));
 8001eaa:	7811      	ldrb	r1, [r2, #0]
 8001eac:	6820      	ldr	r0, [r4, #0]
 8001eae:	f7ff ff6c 	bl	8001d8a <PKA_GetOptBitSize_u8>

  /* Get the modulus p length */
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 8001eb2:	6862      	ldr	r2, [r4, #4]
 8001eb4:	6921      	ldr	r1, [r4, #16]
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_ORDER_NB_BITS] = PKA_GetOptBitSize_u8(in->primeOrderSize, *(in->primeOrder));
 8001eb6:	f8c3 0404 	str.w	r0, [r3, #1028]	; 0x404
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 8001eba:	7809      	ldrb	r1, [r1, #0]
 8001ebc:	4610      	mov	r0, r2
 8001ebe:	f7ff ff64 	bl	8001d8a <PKA_GetOptBitSize_u8>

  /* Get the coefficient a sign */
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_A_COEFF_SIGN] = in->coefSign;
 8001ec2:	68a1      	ldr	r1, [r4, #8]
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 8001ec4:	f8c3 04b4 	str.w	r0, [r3, #1204]	; 0x4b4
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_A_COEFF_SIGN] = in->coefSign;
 8001ec8:	f8c3 145c 	str.w	r1, [r3, #1116]	; 0x45c

  /* Move the input parameters coefficient |a| to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_A_COEFF], in->coef, in->modulusSize);
 8001ecc:	f503 608c 	add.w	r0, r3, #1120	; 0x460
 8001ed0:	68e1      	ldr	r1, [r4, #12]
 8001ed2:	f7ff ff60 	bl	8001d96 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 8001ed6:	6862      	ldr	r2, [r4, #4]
 8001ed8:	6828      	ldr	r0, [r5, #0]

  /* Move the input parameters modulus value p to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_GF], in->modulus, in->modulusSize);
 8001eda:	6921      	ldr	r1, [r4, #16]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 8001edc:	1cd3      	adds	r3, r2, #3
 8001ede:	089b      	lsrs	r3, r3, #2
 8001ee0:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8001ee4:	2600      	movs	r6, #0
 8001ee6:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_GF], in->modulus, in->modulusSize);
 8001eea:	f500 6097 	add.w	r0, r0, #1208	; 0x4b8
 8001eee:	f7ff ff52 	bl	8001d96 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 8001ef2:	6862      	ldr	r2, [r4, #4]
 8001ef4:	6828      	ldr	r0, [r5, #0]

  /* Move the input parameters base point G coordinate x to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_INITIAL_POINT_X], in->basePointX, in->modulusSize);
 8001ef6:	6961      	ldr	r1, [r4, #20]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 8001ef8:	1cd3      	adds	r3, r2, #3
 8001efa:	089b      	lsrs	r3, r3, #2
 8001efc:	f503 7397 	add.w	r3, r3, #302	; 0x12e
 8001f00:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_INITIAL_POINT_X], in->basePointX, in->modulusSize);
 8001f04:	f500 60bd 	add.w	r0, r0, #1512	; 0x5e8
 8001f08:	f7ff ff45 	bl	8001d96 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 8001f0c:	6862      	ldr	r2, [r4, #4]
 8001f0e:	6828      	ldr	r0, [r5, #0]

  /* Move the input parameters base point G coordinate y to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y], in->basePointY, in->modulusSize);
 8001f10:	69a1      	ldr	r1, [r4, #24]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 8001f12:	1cd3      	adds	r3, r2, #3
 8001f14:	089b      	lsrs	r3, r3, #2
 8001f16:	f503 73bd 	add.w	r3, r3, #378	; 0x17a
 8001f1a:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y], in->basePointY, in->modulusSize);
 8001f1e:	f200 603c 	addw	r0, r0, #1596	; 0x63c
 8001f22:	f7ff ff38 	bl	8001d96 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 8001f26:	6862      	ldr	r2, [r4, #4]
 8001f28:	6828      	ldr	r0, [r5, #0]

  /* Move the input parameters public-key curve point Q coordinate xQ to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X], in->pPubKeyCurvePtX, in->modulusSize);
 8001f2a:	69e1      	ldr	r1, [r4, #28]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 8001f2c:	1cd3      	adds	r3, r2, #3
 8001f2e:	089b      	lsrs	r3, r3, #2
 8001f30:	f203 138f 	addw	r3, r3, #399	; 0x18f
 8001f34:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X], in->pPubKeyCurvePtX, in->modulusSize);
 8001f38:	f500 6074 	add.w	r0, r0, #3904	; 0xf40
 8001f3c:	f7ff ff2b 	bl	8001d96 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 8001f40:	6862      	ldr	r2, [r4, #4]
 8001f42:	6828      	ldr	r0, [r5, #0]

  /* Move the input parameters public-key curve point Q coordinate xQ to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y], in->pPubKeyCurvePtY, in->modulusSize);
 8001f44:	6a21      	ldr	r1, [r4, #32]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 8001f46:	1cd3      	adds	r3, r2, #3
 8001f48:	089b      	lsrs	r3, r3, #2
 8001f4a:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
 8001f4e:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y], in->pPubKeyCurvePtY, in->modulusSize);
 8001f52:	f600 7094 	addw	r0, r0, #3988	; 0xf94
 8001f56:	f7ff ff1e 	bl	8001d96 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 8001f5a:	6863      	ldr	r3, [r4, #4]
 8001f5c:	6828      	ldr	r0, [r5, #0]

  /* Move the input parameters signature part r to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_SIGNATURE_R], in->RSign, in->primeOrderSize);
 8001f5e:	6822      	ldr	r2, [r4, #0]
 8001f60:	6a61      	ldr	r1, [r4, #36]	; 0x24
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 8001f62:	3303      	adds	r3, #3
 8001f64:	089b      	lsrs	r3, r3, #2
 8001f66:	f203 33e5 	addw	r3, r3, #997	; 0x3e5
 8001f6a:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_SIGNATURE_R], in->RSign, in->primeOrderSize);
 8001f6e:	f500 5084 	add.w	r0, r0, #4224	; 0x1080
 8001f72:	3018      	adds	r0, #24
 8001f74:	f7ff ff0f 	bl	8001d96 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_SIGNATURE_R + ((in->primeOrderSize + 3UL) / 4UL));
 8001f78:	6822      	ldr	r2, [r4, #0]
 8001f7a:	6828      	ldr	r0, [r5, #0]

  /* Move the input parameters signature part s to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_SIGNATURE_S], in->SSign, in->primeOrderSize);
 8001f7c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_SIGNATURE_R + ((in->primeOrderSize + 3UL) / 4UL));
 8001f7e:	1cd3      	adds	r3, r2, #3
 8001f80:	089b      	lsrs	r3, r3, #2
 8001f82:	f203 4326 	addw	r3, r3, #1062	; 0x426
 8001f86:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_SIGNATURE_S], in->SSign, in->primeOrderSize);
 8001f8a:	f600 2044 	addw	r0, r0, #2628	; 0xa44
 8001f8e:	f7ff ff02 	bl	8001d96 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_SIGNATURE_S + ((in->primeOrderSize + 3UL) / 4UL));
 8001f92:	6822      	ldr	r2, [r4, #0]
 8001f94:	6828      	ldr	r0, [r5, #0]

  /* Move the input parameters hash of message z to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_HASH_E], in->hash, in->primeOrderSize);
 8001f96:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_SIGNATURE_S + ((in->primeOrderSize + 3UL) / 4UL));
 8001f98:	1cd3      	adds	r3, r2, #3
 8001f9a:	089b      	lsrs	r3, r3, #2
 8001f9c:	f203 2391 	addw	r3, r3, #657	; 0x291
 8001fa0:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_HASH_E], in->hash, in->primeOrderSize);
 8001fa4:	f600 70e8 	addw	r0, r0, #4072	; 0xfe8
 8001fa8:	f7ff fef5 	bl	8001d96 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_HASH_E + ((in->primeOrderSize + 3UL) / 4UL));
 8001fac:	6822      	ldr	r2, [r4, #0]
 8001fae:	6828      	ldr	r0, [r5, #0]

  /* Move the input parameters curve prime order n to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_ORDER_N], in->primeOrder, in->primeOrderSize);
 8001fb0:	6b21      	ldr	r1, [r4, #48]	; 0x30
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_HASH_E + ((in->primeOrderSize + 3UL) / 4UL));
 8001fb2:	1cd3      	adds	r3, r2, #3
 8001fb4:	089b      	lsrs	r3, r3, #2
 8001fb6:	f203 33fa 	addw	r3, r3, #1018	; 0x3fa
 8001fba:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_ORDER_N], in->primeOrder, in->primeOrderSize);
 8001fbe:	f600 505c 	addw	r0, r0, #3420	; 0xd5c
 8001fc2:	f7ff fee8 	bl	8001d96 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_ORDER_N + ((in->primeOrderSize + 3UL) / 4UL));
 8001fc6:	6823      	ldr	r3, [r4, #0]
 8001fc8:	682a      	ldr	r2, [r5, #0]
 8001fca:	3303      	adds	r3, #3
 8001fcc:	089b      	lsrs	r3, r3, #2
 8001fce:	f203 3357 	addw	r3, r3, #855	; 0x357
 8001fd2:	f842 6023 	str.w	r6, [r2, r3, lsl #2]
}
 8001fd6:	bd70      	pop	{r4, r5, r6, pc}

08001fd8 <HAL_PKA_ECDSAVerif>:
{
 8001fd8:	b513      	push	{r0, r1, r4, lr}
 8001fda:	4604      	mov	r4, r0
 8001fdc:	9201      	str	r2, [sp, #4]
  PKA_ECDSAVerif_Set(hpka, in);
 8001fde:	f7ff ff5f 	bl	8001ea0 <PKA_ECDSAVerif_Set>
  return PKA_Process(hpka, PKA_MODE_ECDSA_VERIFICATION, Timeout);
 8001fe2:	9a01      	ldr	r2, [sp, #4]
 8001fe4:	2126      	movs	r1, #38	; 0x26
 8001fe6:	4620      	mov	r0, r4
}
 8001fe8:	b002      	add	sp, #8
 8001fea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return PKA_Process(hpka, PKA_MODE_ECDSA_VERIFICATION, Timeout);
 8001fee:	f7ff bf14 	b.w	8001e1a <PKA_Process>
	...

08001ff4 <SE_CallGateService>:
   */
  static SE_LockStatus SE_LockRestrictedServices = SE_UNLOCKED;

  SE_ErrorStatus e_ret_status = SE_ERROR;

  switch (eID)
 8001ff4:	2810      	cmp	r0, #16
{
 8001ff6:	e92d 4f73 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, lr}
 8001ffa:	460c      	mov	r4, r1
  switch (eID)
 8001ffc:	d815      	bhi.n	800202a <SE_CallGateService+0x36>
 8001ffe:	4dbd      	ldr	r5, [pc, #756]	; (80022f4 <SE_CallGateService+0x300>)
 8002000:	2810      	cmp	r0, #16
 8002002:	d821      	bhi.n	8002048 <SE_CallGateService+0x54>
 8002004:	e8df f010 	tbh	[pc, r0, lsl #1]
 8002008:	0020003f 	.word	0x0020003f
 800200c:	00200020 	.word	0x00200020
 8002010:	007f004e 	.word	0x007f004e
 8002014:	00f800c6 	.word	0x00f800c6
 8002018:	01820125 	.word	0x01820125
 800201c:	00200020 	.word	0x00200020
 8002020:	00200020 	.word	0x00200020
 8002024:	00200020 	.word	0x00200020
 8002028:	01b9      	.short	0x01b9
 800202a:	2894      	cmp	r0, #148	; 0x94
 800202c:	f000 821b 	beq.w	8002466 <SE_CallGateService+0x472>
 8002030:	d80c      	bhi.n	800204c <SE_CallGateService+0x58>
 8002032:	2892      	cmp	r0, #146	; 0x92
 8002034:	f8df 82c4 	ldr.w	r8, [pc, #708]	; 80022fc <SE_CallGateService+0x308>
 8002038:	f000 81c7 	beq.w	80023ca <SE_CallGateService+0x3d6>
 800203c:	2893      	cmp	r0, #147	; 0x93
 800203e:	f000 81eb 	beq.w	8002418 <SE_CallGateService+0x424>
 8002042:	2820      	cmp	r0, #32
 8002044:	f000 8223 	beq.w	800248e <SE_CallGateService+0x49a>
        }
        break;
      }
#endif /* KMS_ENABLED */
      /* Unspecified function ID -> Reset */
      NVIC_SystemReset();
 8002048:	f000 fa4c 	bl	80024e4 <__NVIC_SystemReset>
  switch (eID)
 800204c:	f5b0 7f90 	cmp.w	r0, #288	; 0x120
 8002050:	f000 8214 	beq.w	800247c <SE_CallGateService+0x488>
 8002054:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8002058:	d04d      	beq.n	80020f6 <SE_CallGateService+0x102>
 800205a:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 800205e:	d1f3      	bne.n	8002048 <SE_CallGateService+0x54>
      if (SE_LockRestrictedServices == SE_LOCKED)
 8002060:	4da4      	ldr	r5, [pc, #656]	; (80022f4 <SE_CallGateService+0x300>)
 8002062:	4ea5      	ldr	r6, [pc, #660]	; (80022f8 <SE_CallGateService+0x304>)
      SE_CRYPTO_Lock_CKS_Keys();
 8002064:	f7fe fe78 	bl	8000d58 <SE_CRYPTO_Lock_CKS_Keys>
      if (SE_LockRestrictedServices == SE_LOCKED)
 8002068:	682b      	ldr	r3, [r5, #0]
 800206a:	42b3      	cmp	r3, r6
 800206c:	d101      	bne.n	8002072 <SE_CallGateService+0x7e>
        CM0_DeInit();
 800206e:	f7fe fc39 	bl	80008e4 <CM0_DeInit>
      SE_LL_CORE_Cleanup();
 8002072:	f7fe ffe5 	bl	8001040 <SE_LL_CORE_Cleanup>
      SE_LockRestrictedServices = SE_LOCKED;
 8002076:	602e      	str	r6, [r5, #0]
      if (SE_LL_Lock_Keys() != SE_SUCCESS)
 8002078:	f7fe ffe4 	bl	8001044 <SE_LL_Lock_Keys>
 800207c:	4b9f      	ldr	r3, [pc, #636]	; (80022fc <SE_CallGateService+0x308>)
 800207e:	4298      	cmp	r0, r3
 8002080:	d139      	bne.n	80020f6 <SE_CallGateService+0x102>
      SE_LockRestrictedServices = SE_LOCKED;
 8002082:	602e      	str	r6, [r5, #0]

      break;
    }
  }
  if ((e_ret_status == SE_ERROR) && (*peSE_Status == SE_OK))
 8002084:	e00b      	b.n	800209e <SE_CallGateService+0xaa>
      IS_SE_LOCKED_SERVICES();
 8002086:	682b      	ldr	r3, [r5, #0]
 8002088:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 800208c:	d1dc      	bne.n	8002048 <SE_CallGateService+0x54>
      SE_SetSystemCoreClock(se_system_core_clock);
 800208e:	6810      	ldr	r0, [r2, #0]
 8002090:	f000 faae 	bl	80025f0 <SE_SetSystemCoreClock>
      CM0_Init();
 8002094:	f7fe fbe2 	bl	800085c <CM0_Init>
      *peSE_Status = SE_OK;
 8002098:	4b99      	ldr	r3, [pc, #612]	; (8002300 <SE_CallGateService+0x30c>)
      e_ret_status = SE_SUCCESS;
 800209a:	4898      	ldr	r0, [pc, #608]	; (80022fc <SE_CallGateService+0x308>)
      *peSE_Status = SE_OK;
 800209c:	6023      	str	r3, [r4, #0]
  {
    *peSE_Status = SE_KO;
  }
  return e_ret_status;
}
 800209e:	b002      	add	sp, #8
 80020a0:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
      IS_SE_LOCKED_SERVICES();
 80020a4:	682b      	ldr	r3, [r5, #0]
 80020a6:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 80020aa:	d1cd      	bne.n	8002048 <SE_CallGateService+0x54>
      se_FwType = va_arg(arguments, uint32_t);
 80020ac:	e9d2 8900 	ldrd	r8, r9, [r2]
      if (SE_LL_CRC_Config() == SE_ERROR)
 80020b0:	f7fe fe8e 	bl	8000dd0 <SE_LL_CRC_Config>
 80020b4:	4b93      	ldr	r3, [pc, #588]	; (8002304 <SE_CallGateService+0x310>)
 80020b6:	4298      	cmp	r0, r3
 80020b8:	d01d      	beq.n	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(p_x_se_Metadata, sizeof(*p_x_se_Metadata)) != SE_SUCCESS)
 80020ba:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80020be:	4640      	mov	r0, r8
 80020c0:	f7fe ff4c 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80020c4:	4b8d      	ldr	r3, [pc, #564]	; (80022fc <SE_CallGateService+0x308>)
 80020c6:	4298      	cmp	r0, r3
 80020c8:	4606      	mov	r6, r0
 80020ca:	d114      	bne.n	80020f6 <SE_CallGateService+0x102>
      if ((se_FwType != SE_FW_IMAGE_COMPLETE) && (se_FwType != SE_FW_IMAGE_PARTIAL))
 80020cc:	f1b9 0f01 	cmp.w	r9, #1
 80020d0:	d811      	bhi.n	80020f6 <SE_CallGateService+0x102>
      IS_SE_LOCKED_SERVICES();
 80020d2:	682b      	ldr	r3, [r5, #0]
 80020d4:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 80020d8:	d1b6      	bne.n	8002048 <SE_CallGateService+0x54>
      if (SE_LL_Buffer_in_SBSFU_ram(p_x_se_Metadata, sizeof(*p_x_se_Metadata)) != SE_SUCCESS)
 80020da:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80020de:	4640      	mov	r0, r8
 80020e0:	f7fe ff3c 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80020e4:	42b0      	cmp	r0, r6
 80020e6:	d106      	bne.n	80020f6 <SE_CallGateService+0x102>
      e_ret_status = SE_CRYPTO_Decrypt_Init(p_x_se_Metadata, se_FwType);
 80020e8:	4649      	mov	r1, r9
 80020ea:	4640      	mov	r0, r8
 80020ec:	f7fe fcaa 	bl	8000a44 <SE_CRYPTO_Decrypt_Init>
  if ((e_ret_status == SE_ERROR) && (*peSE_Status == SE_OK))
 80020f0:	4b84      	ldr	r3, [pc, #528]	; (8002304 <SE_CallGateService+0x310>)
 80020f2:	4298      	cmp	r0, r3
 80020f4:	d1d3      	bne.n	800209e <SE_CallGateService+0xaa>
 80020f6:	4b82      	ldr	r3, [pc, #520]	; (8002300 <SE_CallGateService+0x30c>)
 80020f8:	6822      	ldr	r2, [r4, #0]
 80020fa:	4882      	ldr	r0, [pc, #520]	; (8002304 <SE_CallGateService+0x310>)
 80020fc:	429a      	cmp	r2, r3
    *peSE_Status = SE_KO;
 80020fe:	bf04      	itt	eq
 8002100:	4b81      	ldreq	r3, [pc, #516]	; (8002308 <SE_CallGateService+0x314>)
 8002102:	6023      	streq	r3, [r4, #0]
  return e_ret_status;
 8002104:	e7cb      	b.n	800209e <SE_CallGateService+0xaa>
      IS_SE_LOCKED_SERVICES();
 8002106:	682b      	ldr	r3, [r5, #0]
 8002108:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 800210c:	d19c      	bne.n	8002048 <SE_CallGateService+0x54>
      input_size = va_arg(arguments, int32_t);
 800210e:	e9d2 8600 	ldrd	r8, r6, [r2]
      output_size = va_arg(arguments, int32_t *);
 8002112:	e9d2 9a02 	ldrd	r9, sl, [r2, #8]
      if (SE_LL_CRC_Config() == SE_ERROR)
 8002116:	f7fe fe5b 	bl	8000dd0 <SE_LL_CRC_Config>
 800211a:	4b7a      	ldr	r3, [pc, #488]	; (8002304 <SE_CallGateService+0x310>)
 800211c:	4298      	cmp	r0, r3
 800211e:	d0ea      	beq.n	80020f6 <SE_CallGateService+0x102>
      if (input_size <= 0)
 8002120:	2e00      	cmp	r6, #0
 8002122:	dde8      	ble.n	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(input_buffer, (uint32_t)input_size) != SE_SUCCESS)
 8002124:	4631      	mov	r1, r6
 8002126:	4640      	mov	r0, r8
 8002128:	f7fe ff18 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 800212c:	4a73      	ldr	r2, [pc, #460]	; (80022fc <SE_CallGateService+0x308>)
 800212e:	4290      	cmp	r0, r2
 8002130:	d1e1      	bne.n	80020f6 <SE_CallGateService+0x102>
 8002132:	9001      	str	r0, [sp, #4]
      if (SE_LL_Buffer_in_SBSFU_ram(output_size, sizeof(*output_size)) != SE_SUCCESS)
 8002134:	2104      	movs	r1, #4
 8002136:	4650      	mov	r0, sl
 8002138:	f7fe ff10 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 800213c:	9b01      	ldr	r3, [sp, #4]
 800213e:	4298      	cmp	r0, r3
 8002140:	4683      	mov	fp, r0
 8002142:	d1d8      	bne.n	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_buffer, (uint32_t)input_size) != SE_SUCCESS)
 8002144:	4631      	mov	r1, r6
 8002146:	4648      	mov	r0, r9
 8002148:	f7fe ff08 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 800214c:	4558      	cmp	r0, fp
 800214e:	d1d2      	bne.n	80020f6 <SE_CallGateService+0x102>
      IS_SE_LOCKED_SERVICES();
 8002150:	682a      	ldr	r2, [r5, #0]
 8002152:	9001      	str	r0, [sp, #4]
 8002154:	f1b2 3f55 	cmp.w	r2, #1431655765	; 0x55555555
 8002158:	f47f af76 	bne.w	8002048 <SE_CallGateService+0x54>
      if (SE_LL_Buffer_in_SBSFU_ram(input_buffer, (uint32_t)input_size) != SE_SUCCESS)
 800215c:	4631      	mov	r1, r6
 800215e:	4640      	mov	r0, r8
 8002160:	f7fe fefc 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 8002164:	9b01      	ldr	r3, [sp, #4]
 8002166:	4298      	cmp	r0, r3
 8002168:	4683      	mov	fp, r0
 800216a:	d1c4      	bne.n	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_size, sizeof(*output_size)) != SE_SUCCESS)
 800216c:	2104      	movs	r1, #4
 800216e:	4650      	mov	r0, sl
 8002170:	f7fe fef4 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 8002174:	4558      	cmp	r0, fp
 8002176:	4605      	mov	r5, r0
 8002178:	d1bd      	bne.n	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_buffer, (uint32_t)input_size) != SE_SUCCESS)
 800217a:	4631      	mov	r1, r6
 800217c:	4648      	mov	r0, r9
 800217e:	f7fe feed 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 8002182:	42a8      	cmp	r0, r5
 8002184:	d1b7      	bne.n	80020f6 <SE_CallGateService+0x102>
      e_ret_status = SE_CRYPTO_Decrypt_Append(input_buffer, input_size, output_buffer, output_size);
 8002186:	4653      	mov	r3, sl
 8002188:	464a      	mov	r2, r9
 800218a:	4631      	mov	r1, r6
 800218c:	4640      	mov	r0, r8
 800218e:	f7fe fcaf 	bl	8000af0 <SE_CRYPTO_Decrypt_Append>
      break;
 8002192:	e7ad      	b.n	80020f0 <SE_CallGateService+0xfc>
      IS_SE_LOCKED_SERVICES();
 8002194:	682b      	ldr	r3, [r5, #0]
 8002196:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 800219a:	f47f af55 	bne.w	8002048 <SE_CallGateService+0x54>
      output_size = va_arg(arguments, int32_t *);
 800219e:	e9d2 8900 	ldrd	r8, r9, [r2]
      if (SE_LL_CRC_Config() == SE_ERROR)
 80021a2:	f7fe fe15 	bl	8000dd0 <SE_LL_CRC_Config>
 80021a6:	4b57      	ldr	r3, [pc, #348]	; (8002304 <SE_CallGateService+0x310>)
 80021a8:	4298      	cmp	r0, r3
 80021aa:	d0a4      	beq.n	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_size, sizeof(*output_size)) != SE_SUCCESS)
 80021ac:	2104      	movs	r1, #4
 80021ae:	4648      	mov	r0, r9
 80021b0:	f7fe fed4 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80021b4:	4b51      	ldr	r3, [pc, #324]	; (80022fc <SE_CallGateService+0x308>)
 80021b6:	4298      	cmp	r0, r3
 80021b8:	4682      	mov	sl, r0
 80021ba:	d19c      	bne.n	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_buffer, (uint32_t)16U) != SE_SUCCESS)
 80021bc:	2110      	movs	r1, #16
 80021be:	4640      	mov	r0, r8
 80021c0:	f7fe fecc 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80021c4:	4550      	cmp	r0, sl
 80021c6:	4606      	mov	r6, r0
 80021c8:	d195      	bne.n	80020f6 <SE_CallGateService+0x102>
      IS_SE_LOCKED_SERVICES();
 80021ca:	682b      	ldr	r3, [r5, #0]
 80021cc:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 80021d0:	f47f af3a 	bne.w	8002048 <SE_CallGateService+0x54>
      if (SE_LL_Buffer_in_SBSFU_ram(output_size, sizeof(*output_size)) != SE_SUCCESS)
 80021d4:	2104      	movs	r1, #4
 80021d6:	4648      	mov	r0, r9
 80021d8:	f7fe fec0 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80021dc:	42b0      	cmp	r0, r6
 80021de:	4605      	mov	r5, r0
 80021e0:	d189      	bne.n	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_buffer, (uint32_t)16U) != SE_SUCCESS)
 80021e2:	2110      	movs	r1, #16
 80021e4:	4640      	mov	r0, r8
 80021e6:	f7fe feb9 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80021ea:	42a8      	cmp	r0, r5
 80021ec:	d183      	bne.n	80020f6 <SE_CallGateService+0x102>
      e_ret_status =  SE_CRYPTO_Decrypt_Finish(output_buffer, output_size);
 80021ee:	4649      	mov	r1, r9
 80021f0:	4640      	mov	r0, r8
 80021f2:	f7fe fc9b 	bl	8000b2c <SE_CRYPTO_Decrypt_Finish>
      break;
 80021f6:	e77b      	b.n	80020f0 <SE_CallGateService+0xfc>
      IS_SE_LOCKED_SERVICES();
 80021f8:	682b      	ldr	r3, [r5, #0]
 80021fa:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 80021fe:	f47f af23 	bne.w	8002048 <SE_CallGateService+0x54>
      se_FwType = va_arg(arguments, uint32_t);
 8002202:	e9d2 8900 	ldrd	r8, r9, [r2]
      if (SE_LL_CRC_Config() == SE_ERROR)
 8002206:	f7fe fde3 	bl	8000dd0 <SE_LL_CRC_Config>
 800220a:	4b3e      	ldr	r3, [pc, #248]	; (8002304 <SE_CallGateService+0x310>)
 800220c:	4298      	cmp	r0, r3
 800220e:	f43f af72 	beq.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(p_x_se_Metadata, sizeof(*p_x_se_Metadata)) != SE_SUCCESS)
 8002212:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8002216:	4640      	mov	r0, r8
 8002218:	f7fe fea0 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 800221c:	4b37      	ldr	r3, [pc, #220]	; (80022fc <SE_CallGateService+0x308>)
 800221e:	4298      	cmp	r0, r3
 8002220:	4606      	mov	r6, r0
 8002222:	f47f af68 	bne.w	80020f6 <SE_CallGateService+0x102>
      if ((se_FwType != SE_FW_IMAGE_COMPLETE) && (se_FwType != SE_FW_IMAGE_PARTIAL))
 8002226:	f1b9 0f01 	cmp.w	r9, #1
 800222a:	f63f af64 	bhi.w	80020f6 <SE_CallGateService+0x102>
      IS_SE_LOCKED_SERVICES();
 800222e:	682b      	ldr	r3, [r5, #0]
 8002230:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 8002234:	f47f af08 	bne.w	8002048 <SE_CallGateService+0x54>
      if (SE_LL_Buffer_in_SBSFU_ram(p_x_se_Metadata, sizeof(*p_x_se_Metadata)) != SE_SUCCESS)
 8002238:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800223c:	4640      	mov	r0, r8
 800223e:	f7fe fe8d 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 8002242:	42b0      	cmp	r0, r6
 8002244:	f47f af57 	bne.w	80020f6 <SE_CallGateService+0x102>
      e_ret_status = SE_CRYPTO_AuthenticateFW_Init(p_x_se_Metadata, se_FwType);
 8002248:	4649      	mov	r1, r9
 800224a:	4640      	mov	r0, r8
 800224c:	f7fe fc7e 	bl	8000b4c <SE_CRYPTO_AuthenticateFW_Init>
      break;
 8002250:	e74e      	b.n	80020f0 <SE_CallGateService+0xfc>
      IS_SE_LOCKED_SERVICES();
 8002252:	682b      	ldr	r3, [r5, #0]
 8002254:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 8002258:	f47f aef6 	bne.w	8002048 <SE_CallGateService+0x54>
      input_size = va_arg(arguments, int32_t);
 800225c:	e9d2 8600 	ldrd	r8, r6, [r2]
      output_size = va_arg(arguments, int32_t *);
 8002260:	e9d2 9a02 	ldrd	r9, sl, [r2, #8]
      if (SE_LL_CRC_Config() == SE_ERROR)
 8002264:	f7fe fdb4 	bl	8000dd0 <SE_LL_CRC_Config>
 8002268:	4b26      	ldr	r3, [pc, #152]	; (8002304 <SE_CallGateService+0x310>)
 800226a:	4298      	cmp	r0, r3
 800226c:	f43f af43 	beq.w	80020f6 <SE_CallGateService+0x102>
      if (input_size <= 0)
 8002270:	2e00      	cmp	r6, #0
 8002272:	f77f af40 	ble.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(input_buffer, (uint32_t)input_size) != SE_SUCCESS)
 8002276:	4631      	mov	r1, r6
 8002278:	4640      	mov	r0, r8
 800227a:	f7fe fe6f 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 800227e:	4a1f      	ldr	r2, [pc, #124]	; (80022fc <SE_CallGateService+0x308>)
 8002280:	4290      	cmp	r0, r2
 8002282:	f47f af38 	bne.w	80020f6 <SE_CallGateService+0x102>
 8002286:	9001      	str	r0, [sp, #4]
      if (SE_LL_Buffer_in_SBSFU_ram(output_size, sizeof(*output_size)) != SE_SUCCESS)
 8002288:	2104      	movs	r1, #4
 800228a:	4650      	mov	r0, sl
 800228c:	f7fe fe66 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 8002290:	9b01      	ldr	r3, [sp, #4]
 8002292:	4298      	cmp	r0, r3
 8002294:	4683      	mov	fp, r0
 8002296:	f47f af2e 	bne.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_buffer, (uint32_t)input_size) != SE_SUCCESS)
 800229a:	4631      	mov	r1, r6
 800229c:	4648      	mov	r0, r9
 800229e:	f7fe fe5d 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80022a2:	4558      	cmp	r0, fp
 80022a4:	f47f af27 	bne.w	80020f6 <SE_CallGateService+0x102>
      IS_SE_LOCKED_SERVICES();
 80022a8:	682a      	ldr	r2, [r5, #0]
 80022aa:	9001      	str	r0, [sp, #4]
 80022ac:	f1b2 3f55 	cmp.w	r2, #1431655765	; 0x55555555
 80022b0:	f47f aeca 	bne.w	8002048 <SE_CallGateService+0x54>
      if (SE_LL_Buffer_in_SBSFU_ram(input_buffer, (uint32_t)input_size) != SE_SUCCESS)
 80022b4:	4631      	mov	r1, r6
 80022b6:	4640      	mov	r0, r8
 80022b8:	f7fe fe50 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80022bc:	9b01      	ldr	r3, [sp, #4]
 80022be:	4298      	cmp	r0, r3
 80022c0:	4683      	mov	fp, r0
 80022c2:	f47f af18 	bne.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_size, sizeof(*output_size)) != SE_SUCCESS)
 80022c6:	2104      	movs	r1, #4
 80022c8:	4650      	mov	r0, sl
 80022ca:	f7fe fe47 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80022ce:	4558      	cmp	r0, fp
 80022d0:	4605      	mov	r5, r0
 80022d2:	f47f af10 	bne.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_buffer, (uint32_t)input_size) != SE_SUCCESS)
 80022d6:	4631      	mov	r1, r6
 80022d8:	4648      	mov	r0, r9
 80022da:	f7fe fe3f 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80022de:	42a8      	cmp	r0, r5
 80022e0:	f47f af09 	bne.w	80020f6 <SE_CallGateService+0x102>
      e_ret_status = SE_CRYPTO_AuthenticateFW_Append(input_buffer, input_size, output_buffer, output_size);
 80022e4:	4653      	mov	r3, sl
 80022e6:	464a      	mov	r2, r9
 80022e8:	4631      	mov	r1, r6
 80022ea:	4640      	mov	r0, r8
 80022ec:	f7fe fc46 	bl	8000b7c <SE_CRYPTO_AuthenticateFW_Append>
      break;
 80022f0:	e6fe      	b.n	80020f0 <SE_CallGateService+0xfc>
 80022f2:	bf00      	nop
 80022f4:	20000404 	.word	0x20000404
 80022f8:	7aaaaaaa 	.word	0x7aaaaaaa
 80022fc:	0012310f 	.word	0x0012310f
 8002300:	0012e223 	.word	0x0012e223
 8002304:	00018799 	.word	0x00018799
 8002308:	0013023d 	.word	0x0013023d
      IS_SE_LOCKED_SERVICES();
 800230c:	682b      	ldr	r3, [r5, #0]
 800230e:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 8002312:	f47f ae99 	bne.w	8002048 <SE_CallGateService+0x54>
      output_size = va_arg(arguments, int32_t *);
 8002316:	e9d2 8900 	ldrd	r8, r9, [r2]
      if (SE_LL_CRC_Config() == SE_ERROR)
 800231a:	f7fe fd59 	bl	8000dd0 <SE_LL_CRC_Config>
 800231e:	4b6e      	ldr	r3, [pc, #440]	; (80024d8 <SE_CallGateService+0x4e4>)
 8002320:	4298      	cmp	r0, r3
 8002322:	f43f aee8 	beq.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_size, sizeof(*output_size)) != SE_SUCCESS)
 8002326:	2104      	movs	r1, #4
 8002328:	4648      	mov	r0, r9
 800232a:	f7fe fe17 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 800232e:	4b6b      	ldr	r3, [pc, #428]	; (80024dc <SE_CallGateService+0x4e8>)
 8002330:	4298      	cmp	r0, r3
 8002332:	4682      	mov	sl, r0
 8002334:	f47f aedf 	bne.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_buffer, (uint32_t)16U) != SE_SUCCESS)
 8002338:	2110      	movs	r1, #16
 800233a:	4640      	mov	r0, r8
 800233c:	f7fe fe0e 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 8002340:	4550      	cmp	r0, sl
 8002342:	4606      	mov	r6, r0
 8002344:	f47f aed7 	bne.w	80020f6 <SE_CallGateService+0x102>
      IS_SE_LOCKED_SERVICES();
 8002348:	682b      	ldr	r3, [r5, #0]
 800234a:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 800234e:	f47f ae7b 	bne.w	8002048 <SE_CallGateService+0x54>
      if (SE_LL_Buffer_in_SBSFU_ram(output_size, sizeof(*output_size)) != SE_SUCCESS)
 8002352:	2104      	movs	r1, #4
 8002354:	4648      	mov	r0, r9
 8002356:	f7fe fe01 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 800235a:	42b0      	cmp	r0, r6
 800235c:	4605      	mov	r5, r0
 800235e:	f47f aeca 	bne.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(output_buffer, (uint32_t)16U) != SE_SUCCESS)
 8002362:	2110      	movs	r1, #16
 8002364:	4640      	mov	r0, r8
 8002366:	f7fe fdf9 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 800236a:	42a8      	cmp	r0, r5
 800236c:	f47f aec3 	bne.w	80020f6 <SE_CallGateService+0x102>
      e_ret_status = SE_CRYPTO_AuthenticateFW_Finish(output_buffer, output_size);
 8002370:	4649      	mov	r1, r9
 8002372:	4640      	mov	r0, r8
 8002374:	f7fe fc16 	bl	8000ba4 <SE_CRYPTO_AuthenticateFW_Finish>
      break;
 8002378:	e6ba      	b.n	80020f0 <SE_CallGateService+0xfc>
      IS_SE_LOCKED_SERVICES();
 800237a:	682b      	ldr	r3, [r5, #0]
 800237c:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 8002380:	f47f ae62 	bne.w	8002048 <SE_CallGateService+0x54>
      p_x_se_Metadata = va_arg(arguments, SE_FwRawHeaderTypeDef *);
 8002384:	f8d2 8000 	ldr.w	r8, [r2]
      if (SE_LL_CRC_Config() == SE_ERROR)
 8002388:	f7fe fd22 	bl	8000dd0 <SE_LL_CRC_Config>
 800238c:	4b52      	ldr	r3, [pc, #328]	; (80024d8 <SE_CallGateService+0x4e4>)
 800238e:	4298      	cmp	r0, r3
 8002390:	f43f aeb1 	beq.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_SBSFU_ram(p_x_se_Metadata, sizeof(*p_x_se_Metadata)) != SE_SUCCESS)
 8002394:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8002398:	4640      	mov	r0, r8
 800239a:	f7fe fddf 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 800239e:	4b4f      	ldr	r3, [pc, #316]	; (80024dc <SE_CallGateService+0x4e8>)
 80023a0:	4298      	cmp	r0, r3
 80023a2:	4606      	mov	r6, r0
 80023a4:	f47f aea7 	bne.w	80020f6 <SE_CallGateService+0x102>
      IS_SE_LOCKED_SERVICES();
 80023a8:	682b      	ldr	r3, [r5, #0]
 80023aa:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 80023ae:	f47f ae4b 	bne.w	8002048 <SE_CallGateService+0x54>
      if (SE_LL_Buffer_in_SBSFU_ram(p_x_se_Metadata, sizeof(*p_x_se_Metadata)) != SE_SUCCESS)
 80023b2:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80023b6:	4640      	mov	r0, r8
 80023b8:	f7fe fdd0 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80023bc:	42b0      	cmp	r0, r6
 80023be:	f47f ae9a 	bne.w	80020f6 <SE_CallGateService+0x102>
      e_ret_status = SE_CRYPTO_Authenticate_Metadata(p_x_se_Metadata);
 80023c2:	4640      	mov	r0, r8
 80023c4:	f7fe fc02 	bl	8000bcc <SE_CRYPTO_Authenticate_Metadata>
      break;
 80023c8:	e692      	b.n	80020f0 <SE_CallGateService+0xfc>
      IS_SE_LOCKED_SERVICES();
 80023ca:	f8df b114 	ldr.w	fp, [pc, #276]	; 80024e0 <SE_CallGateService+0x4ec>
 80023ce:	f8db 3000 	ldr.w	r3, [fp]
 80023d2:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 80023d6:	f47f ae37 	bne.w	8002048 <SE_CallGateService+0x54>
      p_source = va_arg(arguments, const uint8_t *);
 80023da:	e9d2 6900 	ldrd	r6, r9, [r2]
      length = va_arg(arguments, uint32_t);
 80023de:	f8d2 a008 	ldr.w	sl, [r2, #8]
      if (SE_LL_Buffer_in_SBSFU_ram(p_destination, length) != SE_SUCCESS)
 80023e2:	4630      	mov	r0, r6
 80023e4:	4651      	mov	r1, sl
 80023e6:	f7fe fdb9 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 80023ea:	4540      	cmp	r0, r8
 80023ec:	4605      	mov	r5, r0
 80023ee:	f47f ae82 	bne.w	80020f6 <SE_CallGateService+0x102>
      IS_SE_LOCKED_SERVICES();
 80023f2:	f8db 3000 	ldr.w	r3, [fp]
 80023f6:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 80023fa:	f47f ae25 	bne.w	8002048 <SE_CallGateService+0x54>
      if (SE_LL_Buffer_in_SBSFU_ram(p_destination, length) != SE_SUCCESS)
 80023fe:	4651      	mov	r1, sl
 8002400:	4630      	mov	r0, r6
 8002402:	f7fe fdab 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 8002406:	42a8      	cmp	r0, r5
 8002408:	f47f ae75 	bne.w	80020f6 <SE_CallGateService+0x102>
      e_ret_status = SE_IMG_Read(p_destination, p_source, length);
 800240c:	4652      	mov	r2, sl
 800240e:	4649      	mov	r1, r9
 8002410:	4630      	mov	r0, r6
 8002412:	f000 f8a1 	bl	8002558 <SE_IMG_Read>
      break;
 8002416:	e66b      	b.n	80020f0 <SE_CallGateService+0xfc>
      IS_SE_LOCKED_SERVICES();
 8002418:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 80024e0 <SE_CallGateService+0x4ec>
 800241c:	f8db 3000 	ldr.w	r3, [fp]
 8002420:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 8002424:	f47f ae10 	bne.w	8002048 <SE_CallGateService+0x54>
      p_source = va_arg(arguments, const uint8_t *);
 8002428:	e9d2 9600 	ldrd	r9, r6, [r2]
      length = va_arg(arguments, uint32_t);
 800242c:	f8d2 a008 	ldr.w	sl, [r2, #8]
      if (SE_LL_Buffer_in_SBSFU_ram(p_source, length) != SE_SUCCESS)
 8002430:	4630      	mov	r0, r6
 8002432:	4651      	mov	r1, sl
 8002434:	f7fe fd92 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 8002438:	4540      	cmp	r0, r8
 800243a:	4605      	mov	r5, r0
 800243c:	f47f ae5b 	bne.w	80020f6 <SE_CallGateService+0x102>
      IS_SE_LOCKED_SERVICES();
 8002440:	f8db 3000 	ldr.w	r3, [fp]
 8002444:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 8002448:	f47f adfe 	bne.w	8002048 <SE_CallGateService+0x54>
      if (SE_LL_Buffer_in_SBSFU_ram(p_source, length) != SE_SUCCESS)
 800244c:	4651      	mov	r1, sl
 800244e:	4630      	mov	r0, r6
 8002450:	f7fe fd84 	bl	8000f5c <SE_LL_Buffer_in_SBSFU_ram>
 8002454:	42a8      	cmp	r0, r5
 8002456:	f47f ae4e 	bne.w	80020f6 <SE_CallGateService+0x102>
      e_ret_status = SE_IMG_Write(p_destination, p_source, length);
 800245a:	4652      	mov	r2, sl
 800245c:	4631      	mov	r1, r6
 800245e:	4648      	mov	r0, r9
 8002460:	f000 f864 	bl	800252c <SE_IMG_Write>
      break;
 8002464:	e644      	b.n	80020f0 <SE_CallGateService+0xfc>
      IS_SE_LOCKED_SERVICES();
 8002466:	4b1e      	ldr	r3, [pc, #120]	; (80024e0 <SE_CallGateService+0x4ec>)
 8002468:	681b      	ldr	r3, [r3, #0]
 800246a:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 800246e:	f47f adeb 	bne.w	8002048 <SE_CallGateService+0x54>
      e_ret_status = SE_IMG_Erase(p_destination, length);
 8002472:	e9d2 0100 	ldrd	r0, r1, [r2]
 8002476:	f000 f885 	bl	8002584 <SE_IMG_Erase>
      break;
 800247a:	e639      	b.n	80020f0 <SE_CallGateService+0xfc>
      IS_SE_LOCKED_SERVICES();
 800247c:	4b18      	ldr	r3, [pc, #96]	; (80024e0 <SE_CallGateService+0x4ec>)
 800247e:	681b      	ldr	r3, [r3, #0]
 8002480:	f1b3 3f55 	cmp.w	r3, #1431655765	; 0x55555555
 8002484:	f47f ade0 	bne.w	8002048 <SE_CallGateService+0x54>
      e_ret_status = CM0_Update();
 8002488:	f7fe fa52 	bl	8000930 <CM0_Update>
      break;
 800248c:	e630      	b.n	80020f0 <SE_CallGateService+0xfc>
      p_FwInfo = va_arg(arguments, SE_APP_ActiveFwInfo_t *);
 800248e:	e9d2 9500 	ldrd	r9, r5, [r2]
      if (SE_LL_Buffer_in_ram((void *)p_FwInfo, sizeof(*p_FwInfo)) != SE_SUCCESS)
 8002492:	2108      	movs	r1, #8
 8002494:	4628      	mov	r0, r5
 8002496:	f7fe fd49 	bl	8000f2c <SE_LL_Buffer_in_ram>
 800249a:	4540      	cmp	r0, r8
 800249c:	4606      	mov	r6, r0
 800249e:	f47f ae2a 	bne.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_part_of_SE_ram((void *)p_FwInfo, sizeof(*p_FwInfo)) == SE_SUCCESS)
 80024a2:	2108      	movs	r1, #8
 80024a4:	4628      	mov	r0, r5
 80024a6:	f7fe fd71 	bl	8000f8c <SE_LL_Buffer_part_of_SE_ram>
 80024aa:	42b0      	cmp	r0, r6
 80024ac:	f43f ae23 	beq.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_in_ram((void *)p_FwInfo, sizeof(*p_FwInfo)) != SE_SUCCESS)
 80024b0:	2108      	movs	r1, #8
 80024b2:	4628      	mov	r0, r5
 80024b4:	f7fe fd3a 	bl	8000f2c <SE_LL_Buffer_in_ram>
 80024b8:	42b0      	cmp	r0, r6
 80024ba:	4680      	mov	r8, r0
 80024bc:	f47f ae1b 	bne.w	80020f6 <SE_CallGateService+0x102>
      if (SE_LL_Buffer_part_of_SE_ram((void *)p_FwInfo, sizeof(*p_FwInfo)) == SE_SUCCESS)
 80024c0:	2108      	movs	r1, #8
 80024c2:	4628      	mov	r0, r5
 80024c4:	f7fe fd62 	bl	8000f8c <SE_LL_Buffer_part_of_SE_ram>
 80024c8:	4540      	cmp	r0, r8
 80024ca:	f43f ae14 	beq.w	80020f6 <SE_CallGateService+0x102>
      e_ret_status = SE_APPLI_GetActiveFwInfo(slot_number, p_FwInfo);
 80024ce:	4629      	mov	r1, r5
 80024d0:	4648      	mov	r0, r9
 80024d2:	f000 f86f 	bl	80025b4 <SE_APPLI_GetActiveFwInfo>
      break;
 80024d6:	e60b      	b.n	80020f0 <SE_CallGateService+0xfc>
 80024d8:	00018799 	.word	0x00018799
 80024dc:	0012310f 	.word	0x0012310f
 80024e0:	20000404 	.word	0x20000404

080024e4 <__NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 80024e4:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80024e8:	4905      	ldr	r1, [pc, #20]	; (8002500 <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80024ea:	4b06      	ldr	r3, [pc, #24]	; (8002504 <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80024ec:	68ca      	ldr	r2, [r1, #12]
 80024ee:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80024f2:	4313      	orrs	r3, r2
 80024f4:	60cb      	str	r3, [r1, #12]
 80024f6:	f3bf 8f4f 	dsb	sy
    __NOP();
 80024fa:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 80024fc:	e7fd      	b.n	80024fa <__NVIC_SystemReset+0x16>
 80024fe:	bf00      	nop
 8002500:	e000ed00 	.word	0xe000ed00
 8002504:	05fa0004 	.word	0x05fa0004

08002508 <SE_NMI_ExceptionHandler>:
 8002508:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800250c:	4905      	ldr	r1, [pc, #20]	; (8002524 <SE_NMI_ExceptionHandler+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800250e:	4b06      	ldr	r3, [pc, #24]	; (8002528 <SE_NMI_ExceptionHandler+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8002510:	68ca      	ldr	r2, [r1, #12]
 8002512:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8002516:	4313      	orrs	r3, r2
 8002518:	60cb      	str	r3, [r1, #12]
 800251a:	f3bf 8f4f 	dsb	sy
    __NOP();
 800251e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8002520:	e7fd      	b.n	800251e <SE_NMI_ExceptionHandler+0x16>
 8002522:	bf00      	nop
 8002524:	e000ed00 	.word	0xe000ed00
 8002528:	05fa0004 	.word	0x05fa0004

0800252c <SE_IMG_Write>:
  * @param  Length number of bytes to be written
  * @retval SE_SUCCESS if successful, otherwise SE_ERROR
  */

SE_ErrorStatus SE_IMG_Write(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
{
 800252c:	b430      	push	{r4, r5}

  /* Is destination area part of 1 of the firmware image headers ?
     Headers are located inside protected memory   */
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800252e:	4c08      	ldr	r4, [pc, #32]	; (8002550 <SE_IMG_Write+0x24>)
 8002530:	6864      	ldr	r4, [r4, #4]
  uint32_t areaend = areabegin + Length - 1U;
 8002532:	1e53      	subs	r3, r2, #1
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8002534:	4284      	cmp	r4, r0
  uint32_t areaend = areabegin + Length - 1U;
 8002536:	4403      	add	r3, r0
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8002538:	d803      	bhi.n	8002542 <SE_IMG_Write+0x16>
        (areaend < (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800253a:	f504 7400 	add.w	r4, r4, #512	; 0x200
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800253e:	429c      	cmp	r4, r3
 8002540:	d802      	bhi.n	8002548 <SE_IMG_Write+0x1c>
    ret = SE_LL_FLASH_Write(pDestination, pSource, Length);
  }
  else
  {
    /* Abnormal case: this primitive should not be used to access this address */
    ret = SE_ERROR;
 8002542:	4804      	ldr	r0, [pc, #16]	; (8002554 <SE_IMG_Write+0x28>)
  }
  return ret;
}
 8002544:	bc30      	pop	{r4, r5}
 8002546:	4770      	bx	lr
 8002548:	bc30      	pop	{r4, r5}
    ret = SE_LL_FLASH_Write(pDestination, pSource, Length);
 800254a:	f7fe bc87 	b.w	8000e5c <SE_LL_FLASH_Write>
 800254e:	bf00      	nop
 8002550:	08003220 	.word	0x08003220
 8002554:	00018799 	.word	0x00018799

08002558 <SE_IMG_Read>:
  * @param  Length number of bytes to be read
  * @retval SE_SUCCESS if successful, otherwise SE_ERROR
  */

SE_ErrorStatus SE_IMG_Read(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
{
 8002558:	b430      	push	{r4, r5}

  /* Is destination area part of 1 of the firmware image headers ?
     Headers are located inside protected memory   */
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800255a:	4c08      	ldr	r4, [pc, #32]	; (800257c <SE_IMG_Read+0x24>)
 800255c:	6864      	ldr	r4, [r4, #4]
  uint32_t areaend = areabegin + Length - 1U;
 800255e:	1e53      	subs	r3, r2, #1
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8002560:	428c      	cmp	r4, r1
  uint32_t areaend = areabegin + Length - 1U;
 8002562:	440b      	add	r3, r1
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8002564:	d803      	bhi.n	800256e <SE_IMG_Read+0x16>
        (areaend < (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 8002566:	f504 7400 	add.w	r4, r4, #512	; 0x200
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800256a:	429c      	cmp	r4, r3
 800256c:	d802      	bhi.n	8002574 <SE_IMG_Read+0x1c>
    ret = SE_LL_FLASH_Read(pDestination, pSource, Length);
  }
  else
  {
    /* Abnormal case: this primitive should not be used to access this address */
    ret = SE_ERROR;
 800256e:	4804      	ldr	r0, [pc, #16]	; (8002580 <SE_IMG_Read+0x28>)
  }
  return ret;
}
 8002570:	bc30      	pop	{r4, r5}
 8002572:	4770      	bx	lr
 8002574:	bc30      	pop	{r4, r5}
    ret = SE_LL_FLASH_Read(pDestination, pSource, Length);
 8002576:	f7fe bc9f 	b.w	8000eb8 <SE_LL_FLASH_Read>
 800257a:	bf00      	nop
 800257c:	08003220 	.word	0x08003220
 8002580:	00018799 	.word	0x00018799

08002584 <SE_IMG_Erase>:

  /* Is destination area part of 1 of the firmware image headers ?
     Headers are located inside protected memory   */
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8002584:	4a09      	ldr	r2, [pc, #36]	; (80025ac <SE_IMG_Erase+0x28>)
 8002586:	6852      	ldr	r2, [r2, #4]
  uint32_t areaend = areabegin + Length - 1U;
 8002588:	1e4b      	subs	r3, r1, #1
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800258a:	4282      	cmp	r2, r0
{
 800258c:	b410      	push	{r4}
  uint32_t areaend = areabegin + Length - 1U;
 800258e:	4403      	add	r3, r0
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8002590:	d803      	bhi.n	800259a <SE_IMG_Erase+0x16>
        (areaend < (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 8002592:	f502 7200 	add.w	r2, r2, #512	; 0x200
    if ((areabegin >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 8002596:	429a      	cmp	r2, r3
 8002598:	d803      	bhi.n	80025a2 <SE_IMG_Erase+0x1e>
    ret = SE_LL_FLASH_Erase(pDestination, Length);
  }
  else
  {
    /* Abnormal case: this primitive should not be used to access this address */
    ret = SE_ERROR;
 800259a:	4805      	ldr	r0, [pc, #20]	; (80025b0 <SE_IMG_Erase+0x2c>)
  }
  return ret;
}
 800259c:	f85d 4b04 	ldr.w	r4, [sp], #4
 80025a0:	4770      	bx	lr
 80025a2:	f85d 4b04 	ldr.w	r4, [sp], #4
    ret = SE_LL_FLASH_Erase(pDestination, Length);
 80025a6:	f7fe bc2f 	b.w	8000e08 <SE_LL_FLASH_Erase>
 80025aa:	bf00      	nop
 80025ac:	08003220 	.word	0x08003220
 80025b0:	00018799 	.word	0x00018799

080025b4 <SE_APPLI_GetActiveFwInfo>:
  * @param  SlotNumber index of the slot in the list
  * @param p_FwInfo Active Firmware Info structure that will be filled.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_APPLI_GetActiveFwInfo(uint32_t SlotNumber, SE_APP_ActiveFwInfo_t *p_FwInfo)
{
 80025b4:	b510      	push	{r4, lr}
  SE_ErrorStatus e_ret_status;
  uint8_t buffer[SE_FW_HEADER_TOT_LEN];     /* to read FW metadata from FLASH */
  SE_FwRawHeaderTypeDef *pfw_image_header;  /* FW metadata */

  /* Check the pointer allocation */
  if (NULL == p_FwInfo)
 80025b6:	460c      	mov	r4, r1
{
 80025b8:	b0d0      	sub	sp, #320	; 0x140
  if (NULL == p_FwInfo)
 80025ba:	b199      	cbz	r1, 80025e4 <SE_APPLI_GetActiveFwInfo+0x30>
  {
    return SE_ERROR;
  }

  /* Check Slot_Number value */
  if (SlotNumber > SFU_NB_MAX_ACTIVE_IMAGE)
 80025bc:	2801      	cmp	r0, #1
 80025be:	d811      	bhi.n	80025e4 <SE_APPLI_GetActiveFwInfo+0x30>
    return SE_ERROR;
  }
  /*
   * The Firmware Information is available in the header of the active slot.
   */
  e_ret_status = SE_LL_FLASH_Read(buffer, (uint8_t *) SlotHeaderAdd[SlotNumber], sizeof(buffer));
 80025c0:	4b09      	ldr	r3, [pc, #36]	; (80025e8 <SE_APPLI_GetActiveFwInfo+0x34>)
 80025c2:	f44f 72a0 	mov.w	r2, #320	; 0x140
 80025c6:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 80025ca:	4668      	mov	r0, sp
 80025cc:	f7fe fc74 	bl	8000eb8 <SE_LL_FLASH_Read>
  if (e_ret_status != SE_ERROR)
 80025d0:	4b06      	ldr	r3, [pc, #24]	; (80025ec <SE_APPLI_GetActiveFwInfo+0x38>)
 80025d2:	4298      	cmp	r0, r3
 80025d4:	d004      	beq.n	80025e0 <SE_APPLI_GetActiveFwInfo+0x2c>

    /*
     * We do not check the header validity.
     * We just copy the information.
     */
    p_FwInfo->ActiveFwVersion = pfw_image_header->FwVersion;
 80025d6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80025da:	8023      	strh	r3, [r4, #0]
    p_FwInfo->ActiveFwSize = pfw_image_header->FwSize;
 80025dc:	9b02      	ldr	r3, [sp, #8]
 80025de:	6063      	str	r3, [r4, #4]
  }

  return e_ret_status;
}
 80025e0:	b050      	add	sp, #320	; 0x140
 80025e2:	bd10      	pop	{r4, pc}
    return SE_ERROR;
 80025e4:	4801      	ldr	r0, [pc, #4]	; (80025ec <SE_APPLI_GetActiveFwInfo+0x38>)
 80025e6:	e7fb      	b.n	80025e0 <SE_APPLI_GetActiveFwInfo+0x2c>
 80025e8:	08003220 	.word	0x08003220
 80025ec:	00018799 	.word	0x00018799

080025f0 <SE_SetSystemCoreClock>:
  * @param uSystemCoreClock Secure Engine SystemCoreClock variable.
  * @retval None.
  */
void SE_SetSystemCoreClock(uint32_t uSystemCoreClock)
{
  m_uSE_SystemCoreClock = uSystemCoreClock;
 80025f0:	4b01      	ldr	r3, [pc, #4]	; (80025f8 <SE_SetSystemCoreClock+0x8>)
 80025f2:	6018      	str	r0, [r3, #0]
}
 80025f4:	4770      	bx	lr
 80025f6:	bf00      	nop
 80025f8:	200005b0 	.word	0x200005b0

080025fc <HAL_GetTick>:
  static uint32_t t1 = 0U, tdelta = 0U;
  uint32_t t2;

  t2 =  SysTick->VAL;

  if (t2 <= t1)
 80025fc:	4b0e      	ldr	r3, [pc, #56]	; (8002638 <HAL_GetTick+0x3c>)
  t2 =  SysTick->VAL;
 80025fe:	490f      	ldr	r1, [pc, #60]	; (800263c <HAL_GetTick+0x40>)
{
 8002600:	b510      	push	{r4, lr}
 8002602:	e9d3 2401 	ldrd	r2, r4, [r3, #4]
  t2 =  SysTick->VAL;
 8002606:	6888      	ldr	r0, [r1, #8]
  if (t2 <= t1)
 8002608:	4282      	cmp	r2, r0
  {
    tdelta += t1 - t2;
  }
  else
  {
    tdelta += t1 + SysTick->LOAD - t2;
 800260a:	bf38      	it	cc
 800260c:	6849      	ldrcc	r1, [r1, #4]
 800260e:	4422      	add	r2, r4
 8002610:	bf38      	it	cc
 8002612:	1852      	addcc	r2, r2, r1
 8002614:	1a12      	subs	r2, r2, r0
  }

  if (tdelta > (m_uSE_SystemCoreClock / 1000U))
 8002616:	6819      	ldr	r1, [r3, #0]
 8002618:	609a      	str	r2, [r3, #8]
 800261a:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 800261e:	fbb1 f1f4 	udiv	r1, r1, r4
 8002622:	4291      	cmp	r1, r2
 8002624:	d204      	bcs.n	8002630 <HAL_GetTick+0x34>
 8002626:	68da      	ldr	r2, [r3, #12]
  {
    tdelta = 0U;
 8002628:	2100      	movs	r1, #0
    m_uTick ++;
 800262a:	3201      	adds	r2, #1
    tdelta = 0U;
 800262c:	6099      	str	r1, [r3, #8]
    m_uTick ++;
 800262e:	60da      	str	r2, [r3, #12]
  }

  t1 = t2;
 8002630:	6058      	str	r0, [r3, #4]
  return m_uTick;
}
 8002632:	68d8      	ldr	r0, [r3, #12]
 8002634:	bd10      	pop	{r4, pc}
 8002636:	bf00      	nop
 8002638:	200005b0 	.word	0x200005b0
 800263c:	e000e010 	.word	0xe000e010

08002640 <HAL_Delay>:
  *        on variable incremented.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
void HAL_Delay(uint32_t Delay)
{
 8002640:	b538      	push	{r3, r4, r5, lr}
 8002642:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8002644:	f7ff ffda 	bl	80025fc <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8002648:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 800264a:	4605      	mov	r5, r0
  {
    wait++;
 800264c:	bf18      	it	ne
 800264e:	3401      	addne	r4, #1
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8002650:	f7ff ffd4 	bl	80025fc <HAL_GetTick>
 8002654:	1b43      	subs	r3, r0, r5
 8002656:	42a3      	cmp	r3, r4
 8002658:	d3fa      	bcc.n	8002650 <HAL_Delay+0x10>
  {
  }
}
 800265a:	bd38      	pop	{r3, r4, r5, pc}

0800265c <SHCI_C2_FUS_GetState>:
/**
 *  C2 COMMAND
 *  These commands are sent to the CPU2
 */
uint8_t SHCI_C2_FUS_GetState( SHCI_FUS_GetState_ErrorCode_t *p_error_code )
{
 800265c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint8_t local_buffer[TL_BLEEVT_CS_BUFFER_SIZE + 1];
  TL_EvtPacket_t * p_rsp;

  p_rsp = (TL_EvtPacket_t *)local_buffer;

  shci_send( SHCI_OPCODE_C2_FUS_GET_STATE,
 800265e:	2200      	movs	r2, #0
{
 8002660:	4604      	mov	r4, r0
  shci_send( SHCI_OPCODE_C2_FUS_GET_STATE,
 8002662:	466b      	mov	r3, sp
 8002664:	4611      	mov	r1, r2
 8002666:	f64f 4052 	movw	r0, #64594	; 0xfc52
 800266a:	f000 f893 	bl	8002794 <shci_send>
             0,
             0,
             p_rsp );

  if(p_error_code != 0)
 800266e:	b114      	cbz	r4, 8002676 <SHCI_C2_FUS_GetState+0x1a>
  {
    *p_error_code = (SHCI_FUS_GetState_ErrorCode_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[1]);
 8002670:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002674:	7023      	strb	r3, [r4, #0]
  }

  return (((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}
 8002676:	f89d 000e 	ldrb.w	r0, [sp, #14]
 800267a:	b004      	add	sp, #16
 800267c:	bd10      	pop	{r4, pc}

0800267e <SHCI_C2_FUS_FwUpgrade>:

SHCI_CmdStatus_t SHCI_C2_FUS_FwUpgrade( uint32_t fw_src_add,  uint32_t fw_dest_add )
{
 800267e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint8_t cmd_length;

  p_cmd = (uint32_t*)local_buffer;
  cmd_length = 0;

  if(fw_src_add != 0)
 8002680:	b108      	cbz	r0, 8002686 <SHCI_C2_FUS_FwUpgrade+0x8>
  {
    *p_cmd = fw_src_add;
 8002682:	9000      	str	r0, [sp, #0]
    cmd_length += 4;
 8002684:	2004      	movs	r0, #4
  }

  if(fw_dest_add != 0)
 8002686:	b111      	cbz	r1, 800268e <SHCI_C2_FUS_FwUpgrade+0x10>
  {
    *(p_cmd+1) = fw_dest_add;
    cmd_length += 4;
 8002688:	3004      	adds	r0, #4
    *(p_cmd+1) = fw_dest_add;
 800268a:	9101      	str	r1, [sp, #4]
    cmd_length += 4;
 800268c:	b2c0      	uxtb	r0, r0
  }

  p_rsp = (TL_EvtPacket_t *)local_buffer;

  shci_send( SHCI_OPCODE_C2_FUS_FW_UPGRADE,
 800268e:	466b      	mov	r3, sp
 8002690:	4601      	mov	r1, r0
 8002692:	461a      	mov	r2, r3
 8002694:	f64f 4054 	movw	r0, #64596	; 0xfc54
 8002698:	f000 f87c 	bl	8002794 <shci_send>
             cmd_length,
             local_buffer,
             p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}
 800269c:	f89d 000e 	ldrb.w	r0, [sp, #14]
 80026a0:	b005      	add	sp, #20
 80026a2:	f85d fb04 	ldr.w	pc, [sp], #4

080026a6 <SHCI_C2_FUS_LoadUsrKey>:

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}

SHCI_CmdStatus_t SHCI_C2_FUS_LoadUsrKey( uint8_t key_index )
{
 80026a6:	b51f      	push	{r0, r1, r2, r3, r4, lr}

  p_rsp = (TL_EvtPacket_t *)local_buffer;

  local_buffer[0] = key_index;

  shci_send( SHCI_OPCODE_C2_FUS_LOAD_USR_KEY,
 80026a8:	466b      	mov	r3, sp
  local_buffer[0] = key_index;
 80026aa:	f88d 0000 	strb.w	r0, [sp]
  shci_send( SHCI_OPCODE_C2_FUS_LOAD_USR_KEY,
 80026ae:	461a      	mov	r2, r3
 80026b0:	2101      	movs	r1, #1
 80026b2:	f64f 4059 	movw	r0, #64601	; 0xfc59
 80026b6:	f000 f86d 	bl	8002794 <shci_send>
             1,
             local_buffer,
             p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}
 80026ba:	f89d 000e 	ldrb.w	r0, [sp, #14]
 80026be:	b005      	add	sp, #20
 80026c0:	f85d fb04 	ldr.w	pc, [sp], #4

080026c4 <SHCI_C2_FUS_StartWs>:

SHCI_CmdStatus_t SHCI_C2_FUS_StartWs( void )
{
 80026c4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint8_t local_buffer[TL_BLEEVT_CS_BUFFER_SIZE];
  TL_EvtPacket_t * p_rsp;

  p_rsp = (TL_EvtPacket_t *)local_buffer;

  shci_send( SHCI_OPCODE_C2_FUS_START_WS,
 80026c6:	2200      	movs	r2, #0
 80026c8:	466b      	mov	r3, sp
 80026ca:	4611      	mov	r1, r2
 80026cc:	f64f 405a 	movw	r0, #64602	; 0xfc5a
 80026d0:	f000 f860 	bl	8002794 <shci_send>
             0,
             0,
             p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}
 80026d4:	f89d 000e 	ldrb.w	r0, [sp, #14]
 80026d8:	b005      	add	sp, #20
 80026da:	f85d fb04 	ldr.w	pc, [sp], #4

080026de <SHCI_C2_FUS_LockUsrKey>:

SHCI_CmdStatus_t SHCI_C2_FUS_LockUsrKey( uint8_t key_index )
{
 80026de:	b51f      	push	{r0, r1, r2, r3, r4, lr}

  p_rsp = (TL_EvtPacket_t *)local_buffer;

  local_buffer[0] = key_index;

  shci_send( SHCI_OPCODE_C2_FUS_LOCK_USR_KEY,
 80026e0:	466b      	mov	r3, sp
  local_buffer[0] = key_index;
 80026e2:	f88d 0000 	strb.w	r0, [sp]
  shci_send( SHCI_OPCODE_C2_FUS_LOCK_USR_KEY,
 80026e6:	461a      	mov	r2, r3
 80026e8:	2101      	movs	r1, #1
 80026ea:	f64f 405d 	movw	r0, #64605	; 0xfc5d
 80026ee:	f000 f851 	bl	8002794 <shci_send>
             1,
             local_buffer,
             p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}
 80026f2:	f89d 000e 	ldrb.w	r0, [sp, #14]
 80026f6:	b005      	add	sp, #20
 80026f8:	f85d fb04 	ldr.w	pc, [sp], #4

080026fc <SHCI_C2_Reinit>:

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}

SHCI_CmdStatus_t SHCI_C2_Reinit( void )
{
 80026fc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint8_t local_buffer[TL_BLEEVT_CS_BUFFER_SIZE];
  TL_EvtPacket_t * p_rsp;

  p_rsp = (TL_EvtPacket_t *)local_buffer;

  shci_send( SHCI_OPCODE_C2_REINIT,
 80026fe:	2200      	movs	r2, #0
 8002700:	466b      	mov	r3, sp
 8002702:	4611      	mov	r1, r2
 8002704:	f64f 406f 	movw	r0, #64623	; 0xfc6f
 8002708:	f000 f844 	bl	8002794 <shci_send>
             0,
             0,
             p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}
 800270c:	f89d 000e 	ldrb.w	r0, [sp, #14]
 8002710:	b005      	add	sp, #20
 8002712:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002718 <TlUserEvtReceived>:

  return;
}

static void TlUserEvtReceived(TL_EvtPacket_t *shcievt)
{
 8002718:	b508      	push	{r3, lr}
 800271a:	4601      	mov	r1, r0
  LST_insert_tail(&SHciAsynchEventQueue, (tListNode *)shcievt);
 800271c:	4803      	ldr	r0, [pc, #12]	; (800272c <TlUserEvtReceived+0x14>)
 800271e:	f000 f888 	bl	8002832 <LST_insert_tail>
  shci_notify_asynch_evt((void*) &SHciAsynchEventQueue); /**< Notify the application a full HCI event has been received */

  return;
}
 8002722:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  shci_notify_asynch_evt((void*) &SHciAsynchEventQueue); /**< Notify the application a full HCI event has been received */
 8002726:	4801      	ldr	r0, [pc, #4]	; (800272c <TlUserEvtReceived+0x14>)
 8002728:	f7fe b8ec 	b.w	8000904 <shci_notify_asynch_evt>
 800272c:	20000408 	.word	0x20000408

08002730 <Cmd_SetStatus.constprop.0>:
    SHCICmdStatus = SHCI_TL_CmdAvailable;
 8002730:	4b03      	ldr	r3, [pc, #12]	; (8002740 <Cmd_SetStatus.constprop.0+0x10>)
 8002732:	2001      	movs	r0, #1
 8002734:	7218      	strb	r0, [r3, #8]
    if(StatusNotCallBackFunction != 0)
 8002736:	4b03      	ldr	r3, [pc, #12]	; (8002744 <Cmd_SetStatus.constprop.0+0x14>)
 8002738:	681b      	ldr	r3, [r3, #0]
 800273a:	b103      	cbz	r3, 800273e <Cmd_SetStatus.constprop.0+0xe>
      StatusNotCallBackFunction( SHCI_TL_CmdAvailable );
 800273c:	4718      	bx	r3
}
 800273e:	4770      	bx	lr
 8002740:	20000408 	.word	0x20000408
 8002744:	200005c0 	.word	0x200005c0

08002748 <shci_init>:
{
 8002748:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  StatusNotCallBackFunction = ((SHCI_TL_HciInitConf_t *)pConf)->StatusNotCallBack;
 800274a:	4c0e      	ldr	r4, [pc, #56]	; (8002784 <shci_init+0x3c>)
 800274c:	684b      	ldr	r3, [r1, #4]
  shciContext.UserEvtRx = UserEvtRx;
 800274e:	6220      	str	r0, [r4, #32]
{
 8002750:	460d      	mov	r5, r1
  shci_register_io_bus (&shciContext.io);
 8002752:	1d20      	adds	r0, r4, #4
  StatusNotCallBackFunction = ((SHCI_TL_HciInitConf_t *)pConf)->StatusNotCallBack;
 8002754:	6023      	str	r3, [r4, #0]
  shci_register_io_bus (&shciContext.io);
 8002756:	f000 f855 	bl	8002804 <shci_register_io_bus>
  TlInit((TL_CmdPacket_t *)(((SHCI_TL_HciInitConf_t *)pConf)->p_cmdbuffer));
 800275a:	682e      	ldr	r6, [r5, #0]
  pCmdBuffer = p_cmdbuffer;
 800275c:	4d0a      	ldr	r5, [pc, #40]	; (8002788 <shci_init+0x40>)
  LST_init_head (&SHciAsynchEventQueue);
 800275e:	4628      	mov	r0, r5
  pCmdBuffer = p_cmdbuffer;
 8002760:	60ee      	str	r6, [r5, #12]
  LST_init_head (&SHciAsynchEventQueue);
 8002762:	f000 f859 	bl	8002818 <LST_init_head>
  Cmd_SetStatus(SHCI_TL_CmdAvailable);
 8002766:	f7ff ffe3 	bl	8002730 <Cmd_SetStatus.constprop.0>
  SHCI_TL_UserEventFlow = SHCI_TL_UserEventFlow_Enable;
 800276a:	2301      	movs	r3, #1
 800276c:	742b      	strb	r3, [r5, #16]
  if (shciContext.io.Init)
 800276e:	6863      	ldr	r3, [r4, #4]
 8002770:	b133      	cbz	r3, 8002780 <shci_init+0x38>
    Conf.IoBusCallBackCmdEvt = TlCmdEvtReceived;
 8002772:	4a06      	ldr	r2, [pc, #24]	; (800278c <shci_init+0x44>)
 8002774:	9201      	str	r2, [sp, #4]
    Conf.IoBusCallBackUserEvt = TlUserEvtReceived;
 8002776:	4a06      	ldr	r2, [pc, #24]	; (8002790 <shci_init+0x48>)
    Conf.p_cmdbuffer = (uint8_t *)p_cmdbuffer;
 8002778:	9603      	str	r6, [sp, #12]
    Conf.IoBusCallBackUserEvt = TlUserEvtReceived;
 800277a:	9202      	str	r2, [sp, #8]
    shciContext.io.Init(&Conf);
 800277c:	a801      	add	r0, sp, #4
 800277e:	4798      	blx	r3
}
 8002780:	b004      	add	sp, #16
 8002782:	bd70      	pop	{r4, r5, r6, pc}
 8002784:	200005c0 	.word	0x200005c0
 8002788:	20000408 	.word	0x20000408
 800278c:	080027f9 	.word	0x080027f9
 8002790:	08002719 	.word	0x08002719

08002794 <shci_send>:
{
 8002794:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    if(StatusNotCallBackFunction != 0)
 8002798:	4c15      	ldr	r4, [pc, #84]	; (80027f0 <shci_send+0x5c>)
{
 800279a:	461e      	mov	r6, r3
    if(StatusNotCallBackFunction != 0)
 800279c:	6823      	ldr	r3, [r4, #0]
{
 800279e:	460d      	mov	r5, r1
 80027a0:	4680      	mov	r8, r0
 80027a2:	4611      	mov	r1, r2
    if(StatusNotCallBackFunction != 0)
 80027a4:	b11b      	cbz	r3, 80027ae <shci_send+0x1a>
      StatusNotCallBackFunction( SHCI_TL_CmdBusy );
 80027a6:	2000      	movs	r0, #0
 80027a8:	9201      	str	r2, [sp, #4]
 80027aa:	4798      	blx	r3
 80027ac:	9901      	ldr	r1, [sp, #4]
    SHCICmdStatus = SHCI_TL_CmdBusy;
 80027ae:	4f11      	ldr	r7, [pc, #68]	; (80027f4 <shci_send+0x60>)
  pCmdBuffer->cmdserial.cmd.cmdcode = cmd_code;
 80027b0:	68f8      	ldr	r0, [r7, #12]
  memcpy(pCmdBuffer->cmdserial.cmd.payload, p_cmd_payload, len_cmd_payload );
 80027b2:	462a      	mov	r2, r5
    SHCICmdStatus = SHCI_TL_CmdBusy;
 80027b4:	f04f 0900 	mov.w	r9, #0
  pCmdBuffer->cmdserial.cmd.cmdcode = cmd_code;
 80027b8:	f8a0 8009 	strh.w	r8, [r0, #9]
  pCmdBuffer->cmdserial.cmd.plen = len_cmd_payload;
 80027bc:	72c5      	strb	r5, [r0, #11]
  memcpy(pCmdBuffer->cmdserial.cmd.payload, p_cmd_payload, len_cmd_payload );
 80027be:	300c      	adds	r0, #12
    SHCICmdStatus = SHCI_TL_CmdBusy;
 80027c0:	f887 9008 	strb.w	r9, [r7, #8]
  memcpy(pCmdBuffer->cmdserial.cmd.payload, p_cmd_payload, len_cmd_payload );
 80027c4:	f000 fba2 	bl	8002f0c <memcpy>
  shciContext.io.Send(0,0);
 80027c8:	6963      	ldr	r3, [r4, #20]
 80027ca:	4649      	mov	r1, r9
 80027cc:	4648      	mov	r0, r9
 80027ce:	4798      	blx	r3
  shci_cmd_resp_wait(SHCI_TL_DEFAULT_TIMEOUT);
 80027d0:	f248 00e8 	movw	r0, #33000	; 0x80e8
 80027d4:	f7fe f8a2 	bl	800091c <shci_cmd_resp_wait>
  memcpy( &(p_rsp->evtserial), pCmdBuffer, ((TL_EvtSerial_t*)pCmdBuffer)->evt.plen + TL_EVT_HDR_SIZE );
 80027d8:	68f9      	ldr	r1, [r7, #12]
 80027da:	788a      	ldrb	r2, [r1, #2]
 80027dc:	f106 0008 	add.w	r0, r6, #8
 80027e0:	3203      	adds	r2, #3
 80027e2:	f000 fb93 	bl	8002f0c <memcpy>
}
 80027e6:	b003      	add	sp, #12
 80027e8:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  Cmd_SetStatus(SHCI_TL_CmdAvailable);
 80027ec:	f7ff bfa0 	b.w	8002730 <Cmd_SetStatus.constprop.0>
 80027f0:	200005c0 	.word	0x200005c0
 80027f4:	20000408 	.word	0x20000408

080027f8 <TlCmdEvtReceived>:
{
 80027f8:	b508      	push	{r3, lr}
  shci_cmd_resp_release(0); /**< Notify the application the Cmd response has been received */
 80027fa:	2000      	movs	r0, #0
 80027fc:	f7fe f888 	bl	8000910 <shci_cmd_resp_release>
}
 8002800:	bd08      	pop	{r3, pc}
	...

08002804 <shci_register_io_bus>:


void shci_register_io_bus(tSHciIO* fops)
{
  /* Register IO bus services */
  fops->Init    = TL_SYS_Init;
 8002804:	4b02      	ldr	r3, [pc, #8]	; (8002810 <shci_register_io_bus+0xc>)
 8002806:	6003      	str	r3, [r0, #0]
  fops->Send    = TL_SYS_SendCmd;
 8002808:	4b02      	ldr	r3, [pc, #8]	; (8002814 <shci_register_io_bus+0x10>)
 800280a:	6103      	str	r3, [r0, #16]

  return;
}
 800280c:	4770      	bx	lr
 800280e:	bf00      	nop
 8002810:	080028fd 	.word	0x080028fd
 8002814:	08002931 	.word	0x08002931

08002818 <LST_init_head>:
/******************************************************************************
 * Function Definitions 
 ******************************************************************************/
void LST_init_head (tListNode * listHead)
{
  listHead->next = listHead;
 8002818:	6000      	str	r0, [r0, #0]
  listHead->prev = listHead;
 800281a:	6040      	str	r0, [r0, #4]
}
 800281c:	4770      	bx	lr

0800281e <LST_is_empty>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800281e:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8002822:	b672      	cpsid	i
  uint32_t primask_bit;
  uint8_t return_value;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  if(listHead->next == listHead)
 8002824:	6802      	ldr	r2, [r0, #0]
  {
    return_value = TRUE;
 8002826:	1a82      	subs	r2, r0, r2
 8002828:	4250      	negs	r0, r2
 800282a:	4150      	adcs	r0, r2
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800282c:	f383 8810 	msr	PRIMASK, r3
    return_value = FALSE;
  }
  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/

  return return_value;
}
 8002830:	4770      	bx	lr

08002832 <LST_insert_tail>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8002832:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8002836:	b672      	cpsid	i
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  node->next = listHead;
 8002838:	6008      	str	r0, [r1, #0]
  node->prev = listHead->prev;
 800283a:	6842      	ldr	r2, [r0, #4]
 800283c:	604a      	str	r2, [r1, #4]
  listHead->prev = node;
 800283e:	6041      	str	r1, [r0, #4]
  (node->prev)->next = node;
 8002840:	684a      	ldr	r2, [r1, #4]
 8002842:	6011      	str	r1, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002844:	f383 8810 	msr	PRIMASK, r3

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 8002848:	4770      	bx	lr

0800284a <LST_remove_node>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800284a:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800284e:	b672      	cpsid	i
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  (node->prev)->next = node->next;
 8002850:	6843      	ldr	r3, [r0, #4]
 8002852:	6801      	ldr	r1, [r0, #0]
 8002854:	6019      	str	r1, [r3, #0]
  (node->next)->prev = node->prev;
 8002856:	6801      	ldr	r1, [r0, #0]
 8002858:	604b      	str	r3, [r1, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800285a:	f382 8810 	msr	PRIMASK, r2

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 800285e:	4770      	bx	lr

08002860 <LST_remove_head>:


void LST_remove_head (tListNode * listHead, tListNode ** node )
{
 8002860:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8002862:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8002866:	b672      	cpsid	i
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  *node = listHead->next;
 8002868:	6803      	ldr	r3, [r0, #0]
 800286a:	600b      	str	r3, [r1, #0]
  LST_remove_node (listHead->next);
 800286c:	6800      	ldr	r0, [r0, #0]
 800286e:	f7ff ffec 	bl	800284a <LST_remove_node>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002872:	f384 8810 	msr	PRIMASK, r4

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 8002876:	bd10      	pop	{r4, pc}

08002878 <TL_Enable>:
/******************************************************************************
 * GENERAL
 ******************************************************************************/
void TL_Enable( void )
{
  HW_IPCC_Enable();
 8002878:	f7fd bf2a 	b.w	80006d0 <HW_IPCC_Enable>

0800287c <TL_Init>:
}


void TL_Init( void )
{
  TL_RefTable.p_device_info_table = &TL_DeviceInfoTable;
 800287c:	4b0f      	ldr	r3, [pc, #60]	; (80028bc <TL_Init+0x40>)
 800287e:	4a10      	ldr	r2, [pc, #64]	; (80028c0 <TL_Init+0x44>)
  TL_RefTable.p_ble_table = &TL_BleTable;
 8002880:	f103 0120 	add.w	r1, r3, #32
  TL_RefTable.p_device_info_table = &TL_DeviceInfoTable;
 8002884:	6013      	str	r3, [r2, #0]
  TL_RefTable.p_ble_table = &TL_BleTable;
 8002886:	6051      	str	r1, [r2, #4]
  TL_RefTable.p_thread_table = &TL_ThreadTable;
 8002888:	f103 0130 	add.w	r1, r3, #48	; 0x30
 800288c:	6091      	str	r1, [r2, #8]
  TL_RefTable.p_lld_tests_table = &TL_LldTestsTable;
 800288e:	f103 013c 	add.w	r1, r3, #60	; 0x3c
 8002892:	6211      	str	r1, [r2, #32]
  TL_RefTable.p_ble_lld_table = &TL_BleLldTable;
 8002894:	f103 0144 	add.w	r1, r3, #68	; 0x44
 8002898:	6251      	str	r1, [r2, #36]	; 0x24
  TL_RefTable.p_sys_table = &TL_SysTable;
 800289a:	f103 014c 	add.w	r1, r3, #76	; 0x4c
 800289e:	60d1      	str	r1, [r2, #12]
  TL_RefTable.p_mem_manager_table = &TL_MemManagerTable;
 80028a0:	f103 0154 	add.w	r1, r3, #84	; 0x54
 80028a4:	6111      	str	r1, [r2, #16]
  TL_RefTable.p_traces_table = &TL_TracesTable;
 80028a6:	f103 0170 	add.w	r1, r3, #112	; 0x70
 80028aa:	6151      	str	r1, [r2, #20]
  TL_RefTable.p_mac_802_15_4_table = &TL_Mac_802_15_4_Table;
 80028ac:	f103 0174 	add.w	r1, r3, #116	; 0x74
  TL_RefTable.p_zigbee_table = &TL_Zigbee_Table;
 80028b0:	3380      	adds	r3, #128	; 0x80
  TL_RefTable.p_mac_802_15_4_table = &TL_Mac_802_15_4_Table;
 80028b2:	6191      	str	r1, [r2, #24]
  TL_RefTable.p_zigbee_table = &TL_Zigbee_Table;
 80028b4:	61d3      	str	r3, [r2, #28]
  HW_IPCC_Init();
 80028b6:	f7fd bf33 	b.w	8000720 <HW_IPCC_Init>
 80028ba:	bf00      	nop
 80028bc:	20030028 	.word	0x20030028
 80028c0:	20030000 	.word	0x20030000

080028c4 <HW_IPCC_BLE_RxEvtNot>:

  return 0;
}

void HW_IPCC_BLE_RxEvtNot(void)
{
 80028c4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  TL_EvtPacket_t *phcievt;

  while(LST_is_empty(&EvtQueue) == FALSE)
 80028c6:	4c08      	ldr	r4, [pc, #32]	; (80028e8 <HW_IPCC_BLE_RxEvtNot+0x24>)
    else
    {
      OutputDbgTrace(TL_MB_BLE_ASYNCH_EVT, (uint8_t*)phcievt);
    }

    BLE_IoBusEvtCallBackFunction(phcievt);
 80028c8:	4d08      	ldr	r5, [pc, #32]	; (80028ec <HW_IPCC_BLE_RxEvtNot+0x28>)
  while(LST_is_empty(&EvtQueue) == FALSE)
 80028ca:	4807      	ldr	r0, [pc, #28]	; (80028e8 <HW_IPCC_BLE_RxEvtNot+0x24>)
 80028cc:	f7ff ffa7 	bl	800281e <LST_is_empty>
 80028d0:	b108      	cbz	r0, 80028d6 <HW_IPCC_BLE_RxEvtNot+0x12>
  }

  return;
}
 80028d2:	b003      	add	sp, #12
 80028d4:	bd30      	pop	{r4, r5, pc}
    LST_remove_head (&EvtQueue, (tListNode **)&phcievt);
 80028d6:	4620      	mov	r0, r4
 80028d8:	a901      	add	r1, sp, #4
 80028da:	f7ff ffc1 	bl	8002860 <LST_remove_head>
    BLE_IoBusEvtCallBackFunction(phcievt);
 80028de:	68ab      	ldr	r3, [r5, #8]
 80028e0:	9801      	ldr	r0, [sp, #4]
 80028e2:	4798      	blx	r3
 80028e4:	e7f1      	b.n	80028ca <HW_IPCC_BLE_RxEvtNot+0x6>
 80028e6:	bf00      	nop
 80028e8:	200300b4 	.word	0x200300b4
 80028ec:	200005e8 	.word	0x200005e8

080028f0 <HW_IPCC_BLE_AclDataAckNot>:
  return 0;
}

void HW_IPCC_BLE_AclDataAckNot(void)
{
  BLE_IoBusAclDataTxAck( );
 80028f0:	4b01      	ldr	r3, [pc, #4]	; (80028f8 <HW_IPCC_BLE_AclDataAckNot+0x8>)
 80028f2:	68db      	ldr	r3, [r3, #12]
 80028f4:	4718      	bx	r3
 80028f6:	bf00      	nop
 80028f8:	200005e8 	.word	0x200005e8

080028fc <TL_SYS_Init>:

/******************************************************************************
 * SYSTEM
 ******************************************************************************/
int32_t TL_SYS_Init( void* pConf  )
{
 80028fc:	b538      	push	{r3, r4, r5, lr}
  MB_SysTable_t  * p_systable;

  TL_SYS_InitConf_t *pInitHciConf = (TL_SYS_InitConf_t *) pConf;

  LST_init_head (&SystemEvtQueue);
 80028fe:	4d09      	ldr	r5, [pc, #36]	; (8002924 <TL_SYS_Init+0x28>)
{
 8002900:	4604      	mov	r4, r0
  LST_init_head (&SystemEvtQueue);
 8002902:	4628      	mov	r0, r5
 8002904:	f7ff ff88 	bl	8002818 <LST_init_head>
  p_systable = TL_RefTable.p_sys_table;
 8002908:	4b07      	ldr	r3, [pc, #28]	; (8002928 <TL_SYS_Init+0x2c>)
  p_systable->pcmd_buffer = pInitHciConf->p_cmdbuffer;
 800290a:	68a2      	ldr	r2, [r4, #8]
  p_systable = TL_RefTable.p_sys_table;
 800290c:	68db      	ldr	r3, [r3, #12]
  p_systable->sys_queue = (uint8_t*)&SystemEvtQueue;
 800290e:	e9c3 2500 	strd	r2, r5, [r3]

  HW_IPCC_SYS_Init();
 8002912:	f7fd ff25 	bl	8000760 <HW_IPCC_SYS_Init>

  SYS_CMD_IoBusCallBackFunction = pInitHciConf->IoBusCallBackCmdEvt;
 8002916:	4b05      	ldr	r3, [pc, #20]	; (800292c <TL_SYS_Init+0x30>)
 8002918:	6822      	ldr	r2, [r4, #0]
 800291a:	611a      	str	r2, [r3, #16]
  SYS_EVT_IoBusCallBackFunction = pInitHciConf->IoBusCallBackUserEvt;
 800291c:	6862      	ldr	r2, [r4, #4]
 800291e:	615a      	str	r2, [r3, #20]

  return 0;
}
 8002920:	2000      	movs	r0, #0
 8002922:	bd38      	pop	{r3, r4, r5, pc}
 8002924:	200300bc 	.word	0x200300bc
 8002928:	20030000 	.word	0x20030000
 800292c:	200005e8 	.word	0x200005e8

08002930 <TL_SYS_SendCmd>:

int32_t TL_SYS_SendCmd( uint8_t* buffer, uint16_t size )
{
 8002930:	b508      	push	{r3, lr}
  (void)(buffer);
  (void)(size);

  ((TL_CmdPacket_t *)(TL_RefTable.p_sys_table->pcmd_buffer))->cmdserial.type = TL_SYSCMD_PKT_TYPE;
 8002932:	4b05      	ldr	r3, [pc, #20]	; (8002948 <TL_SYS_SendCmd+0x18>)
 8002934:	68da      	ldr	r2, [r3, #12]

  OutputDbgTrace(TL_MB_SYS_CMD, TL_RefTable.p_sys_table->pcmd_buffer);
 8002936:	68db      	ldr	r3, [r3, #12]
  ((TL_CmdPacket_t *)(TL_RefTable.p_sys_table->pcmd_buffer))->cmdserial.type = TL_SYSCMD_PKT_TYPE;
 8002938:	6812      	ldr	r2, [r2, #0]
 800293a:	2110      	movs	r1, #16
 800293c:	7211      	strb	r1, [r2, #8]

  HW_IPCC_SYS_SendCmd();
 800293e:	f7fd ff17 	bl	8000770 <HW_IPCC_SYS_SendCmd>

  return 0;
}
 8002942:	2000      	movs	r0, #0
 8002944:	bd08      	pop	{r3, pc}
 8002946:	bf00      	nop
 8002948:	20030000 	.word	0x20030000

0800294c <HW_IPCC_SYS_CmdEvtNot>:

void HW_IPCC_SYS_CmdEvtNot(void)
{
  OutputDbgTrace(TL_MB_SYS_CMD_RSP, (uint8_t*)(TL_RefTable.p_sys_table->pcmd_buffer) );
 800294c:	4b03      	ldr	r3, [pc, #12]	; (800295c <HW_IPCC_SYS_CmdEvtNot+0x10>)
 800294e:	68da      	ldr	r2, [r3, #12]

  SYS_CMD_IoBusCallBackFunction( (TL_EvtPacket_t*)(TL_RefTable.p_sys_table->pcmd_buffer) );
 8002950:	68da      	ldr	r2, [r3, #12]
 8002952:	4b03      	ldr	r3, [pc, #12]	; (8002960 <HW_IPCC_SYS_CmdEvtNot+0x14>)
 8002954:	6810      	ldr	r0, [r2, #0]
 8002956:	691b      	ldr	r3, [r3, #16]
 8002958:	4718      	bx	r3
 800295a:	bf00      	nop
 800295c:	20030000 	.word	0x20030000
 8002960:	200005e8 	.word	0x200005e8

08002964 <HW_IPCC_SYS_EvtNot>:

  return;
}

void HW_IPCC_SYS_EvtNot( void )
{
 8002964:	b537      	push	{r0, r1, r2, r4, r5, lr}
  TL_EvtPacket_t *p_evt;

  while(LST_is_empty(&SystemEvtQueue) == FALSE)
 8002966:	4c08      	ldr	r4, [pc, #32]	; (8002988 <HW_IPCC_SYS_EvtNot+0x24>)
  {
    LST_remove_head (&SystemEvtQueue, (tListNode **)&p_evt);

    OutputDbgTrace(TL_MB_SYS_ASYNCH_EVT, (uint8_t*)p_evt );

    SYS_EVT_IoBusCallBackFunction( p_evt );
 8002968:	4d08      	ldr	r5, [pc, #32]	; (800298c <HW_IPCC_SYS_EvtNot+0x28>)
  while(LST_is_empty(&SystemEvtQueue) == FALSE)
 800296a:	4807      	ldr	r0, [pc, #28]	; (8002988 <HW_IPCC_SYS_EvtNot+0x24>)
 800296c:	f7ff ff57 	bl	800281e <LST_is_empty>
 8002970:	b108      	cbz	r0, 8002976 <HW_IPCC_SYS_EvtNot+0x12>
  }

  return;
}
 8002972:	b003      	add	sp, #12
 8002974:	bd30      	pop	{r4, r5, pc}
    LST_remove_head (&SystemEvtQueue, (tListNode **)&p_evt);
 8002976:	4620      	mov	r0, r4
 8002978:	a901      	add	r1, sp, #4
 800297a:	f7ff ff71 	bl	8002860 <LST_remove_head>
    SYS_EVT_IoBusCallBackFunction( p_evt );
 800297e:	696b      	ldr	r3, [r5, #20]
 8002980:	9801      	ldr	r0, [sp, #4]
 8002982:	4798      	blx	r3
 8002984:	e7f1      	b.n	800296a <HW_IPCC_SYS_EvtNot+0x6>
 8002986:	bf00      	nop
 8002988:	200300bc 	.word	0x200300bc
 800298c:	200005e8 	.word	0x200005e8

08002990 <TL_MM_Init>:

/******************************************************************************
 * MEMORY MANAGER
 ******************************************************************************/
void TL_MM_Init( TL_MM_Config_t *p_Config )
{
 8002990:	b538      	push	{r3, r4, r5, lr}
  static MB_MemManagerTable_t  * p_mem_manager_table;

  LST_init_head (&FreeBufQueue);
 8002992:	4d0c      	ldr	r5, [pc, #48]	; (80029c4 <TL_MM_Init+0x34>)
{
 8002994:	4604      	mov	r4, r0
  LST_init_head (&FreeBufQueue);
 8002996:	4628      	mov	r0, r5
 8002998:	f7ff ff3e 	bl	8002818 <LST_init_head>
  LST_init_head (&LocalFreeBufQueue);
 800299c:	480a      	ldr	r0, [pc, #40]	; (80029c8 <TL_MM_Init+0x38>)
 800299e:	f7ff ff3b 	bl	8002818 <LST_init_head>

  p_mem_manager_table = TL_RefTable.p_mem_manager_table;
 80029a2:	4b0a      	ldr	r3, [pc, #40]	; (80029cc <TL_MM_Init+0x3c>)

  p_mem_manager_table->blepool = p_Config->p_AsynchEvtPool;
 80029a4:	68a2      	ldr	r2, [r4, #8]
  p_mem_manager_table = TL_RefTable.p_mem_manager_table;
 80029a6:	691b      	ldr	r3, [r3, #16]
  p_mem_manager_table->blepool = p_Config->p_AsynchEvtPool;
 80029a8:	609a      	str	r2, [r3, #8]
  p_mem_manager_table->blepoolsize = p_Config->AsynchEvtPoolSize;
 80029aa:	68e2      	ldr	r2, [r4, #12]
  p_mem_manager_table->pevt_free_buffer_queue = (uint8_t*)&FreeBufQueue;
 80029ac:	e9c3 2503 	strd	r2, r5, [r3, #12]
  p_mem_manager_table->spare_ble_buffer = p_Config->p_BleSpareEvtBuffer;
 80029b0:	6822      	ldr	r2, [r4, #0]
 80029b2:	601a      	str	r2, [r3, #0]
  p_mem_manager_table->spare_sys_buffer = p_Config->p_SystemSpareEvtBuffer;
 80029b4:	6862      	ldr	r2, [r4, #4]
 80029b6:	605a      	str	r2, [r3, #4]
  p_mem_manager_table->traces_evt_pool = p_Config->p_TracesEvtPool;
 80029b8:	6922      	ldr	r2, [r4, #16]
 80029ba:	615a      	str	r2, [r3, #20]
  p_mem_manager_table->tracespoolsize = p_Config->TracesEvtPoolSize;
 80029bc:	6962      	ldr	r2, [r4, #20]
 80029be:	619a      	str	r2, [r3, #24]

  return;
}
 80029c0:	bd38      	pop	{r3, r4, r5, pc}
 80029c2:	bf00      	nop
 80029c4:	200300c4 	.word	0x200300c4
 80029c8:	200005e8 	.word	0x200005e8
 80029cc:	20030000 	.word	0x20030000

080029d0 <TL_TRACES_EvtReceived>:
}

__WEAK void TL_TRACES_EvtReceived( TL_EvtPacket_t * hcievt )
{
  (void)(hcievt);
}
 80029d0:	4770      	bx	lr
	...

080029d4 <HW_IPCC_TRACES_EvtNot>:
{
 80029d4:	b513      	push	{r0, r1, r4, lr}
  while(LST_is_empty(&TracesEvtQueue) == FALSE)
 80029d6:	4c07      	ldr	r4, [pc, #28]	; (80029f4 <HW_IPCC_TRACES_EvtNot+0x20>)
 80029d8:	4806      	ldr	r0, [pc, #24]	; (80029f4 <HW_IPCC_TRACES_EvtNot+0x20>)
 80029da:	f7ff ff20 	bl	800281e <LST_is_empty>
 80029de:	b108      	cbz	r0, 80029e4 <HW_IPCC_TRACES_EvtNot+0x10>
}
 80029e0:	b002      	add	sp, #8
 80029e2:	bd10      	pop	{r4, pc}
    LST_remove_head (&TracesEvtQueue, (tListNode **)&phcievt);
 80029e4:	4620      	mov	r0, r4
 80029e6:	a901      	add	r1, sp, #4
 80029e8:	f7ff ff3a 	bl	8002860 <LST_remove_head>
    TL_TRACES_EvtReceived( phcievt );
 80029ec:	9801      	ldr	r0, [sp, #4]
 80029ee:	f7ff ffef 	bl	80029d0 <TL_TRACES_EvtReceived>
 80029f2:	e7f1      	b.n	80029d8 <HW_IPCC_TRACES_EvtNot+0x4>
 80029f4:	200300cc 	.word	0x200300cc

080029f8 <SHA256Transform>:
 80029f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80029fc:	b0c5      	sub	sp, #276	; 0x114
 80029fe:	2300      	movs	r3, #0
 8002a00:	9303      	str	r3, [sp, #12]
 8002a02:	680b      	ldr	r3, [r1, #0]
 8002a04:	ba1b      	rev	r3, r3
 8002a06:	9304      	str	r3, [sp, #16]
 8002a08:	684b      	ldr	r3, [r1, #4]
 8002a0a:	ba1b      	rev	r3, r3
 8002a0c:	9305      	str	r3, [sp, #20]
 8002a0e:	688b      	ldr	r3, [r1, #8]
 8002a10:	ba1b      	rev	r3, r3
 8002a12:	9306      	str	r3, [sp, #24]
 8002a14:	68cb      	ldr	r3, [r1, #12]
 8002a16:	ba1b      	rev	r3, r3
 8002a18:	9307      	str	r3, [sp, #28]
 8002a1a:	690b      	ldr	r3, [r1, #16]
 8002a1c:	ba1b      	rev	r3, r3
 8002a1e:	9308      	str	r3, [sp, #32]
 8002a20:	694b      	ldr	r3, [r1, #20]
 8002a22:	ba1b      	rev	r3, r3
 8002a24:	9309      	str	r3, [sp, #36]	; 0x24
 8002a26:	698b      	ldr	r3, [r1, #24]
 8002a28:	ba1b      	rev	r3, r3
 8002a2a:	930a      	str	r3, [sp, #40]	; 0x28
 8002a2c:	69cb      	ldr	r3, [r1, #28]
 8002a2e:	ba1b      	rev	r3, r3
 8002a30:	930b      	str	r3, [sp, #44]	; 0x2c
 8002a32:	6a0b      	ldr	r3, [r1, #32]
 8002a34:	ba1b      	rev	r3, r3
 8002a36:	930c      	str	r3, [sp, #48]	; 0x30
 8002a38:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8002a3a:	ba1b      	rev	r3, r3
 8002a3c:	930d      	str	r3, [sp, #52]	; 0x34
 8002a3e:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8002a40:	ba1b      	rev	r3, r3
 8002a42:	930e      	str	r3, [sp, #56]	; 0x38
 8002a44:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8002a46:	ba1b      	rev	r3, r3
 8002a48:	930f      	str	r3, [sp, #60]	; 0x3c
 8002a4a:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8002a4c:	ba1b      	rev	r3, r3
 8002a4e:	9310      	str	r3, [sp, #64]	; 0x40
 8002a50:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8002a52:	ba1b      	rev	r3, r3
 8002a54:	9311      	str	r3, [sp, #68]	; 0x44
 8002a56:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8002a58:	ba1b      	rev	r3, r3
 8002a5a:	9312      	str	r3, [sp, #72]	; 0x48
 8002a5c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8002a5e:	ba1b      	rev	r3, r3
 8002a60:	9313      	str	r3, [sp, #76]	; 0x4c
 8002a62:	ad34      	add	r5, sp, #208	; 0xd0
 8002a64:	ab04      	add	r3, sp, #16
 8002a66:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002a68:	681e      	ldr	r6, [r3, #0]
 8002a6a:	685c      	ldr	r4, [r3, #4]
 8002a6c:	ea4f 4172 	mov.w	r1, r2, ror #17
 8002a70:	ea81 41f2 	eor.w	r1, r1, r2, ror #19
 8002a74:	ea81 2192 	eor.w	r1, r1, r2, lsr #10
 8002a78:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002a7a:	4432      	add	r2, r6
 8002a7c:	4411      	add	r1, r2
 8002a7e:	ea4f 42b4 	mov.w	r2, r4, ror #18
 8002a82:	ea82 12f4 	eor.w	r2, r2, r4, ror #7
 8002a86:	ea82 02d4 	eor.w	r2, r2, r4, lsr #3
 8002a8a:	4411      	add	r1, r2
 8002a8c:	6419      	str	r1, [r3, #64]	; 0x40
 8002a8e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8002a90:	689e      	ldr	r6, [r3, #8]
 8002a92:	ea4f 42f1 	mov.w	r2, r1, ror #19
 8002a96:	ea82 4271 	eor.w	r2, r2, r1, ror #17
 8002a9a:	ea82 2291 	eor.w	r2, r2, r1, lsr #10
 8002a9e:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8002aa0:	440c      	add	r4, r1
 8002aa2:	ea4f 41b6 	mov.w	r1, r6, ror #18
 8002aa6:	ea81 11f6 	eor.w	r1, r1, r6, ror #7
 8002aaa:	4422      	add	r2, r4
 8002aac:	ea81 01d6 	eor.w	r1, r1, r6, lsr #3
 8002ab0:	440a      	add	r2, r1
 8002ab2:	645a      	str	r2, [r3, #68]	; 0x44
 8002ab4:	3308      	adds	r3, #8
 8002ab6:	429d      	cmp	r5, r3
 8002ab8:	d1d5      	bne.n	8002a66 <SHA256Transform+0x6e>
 8002aba:	4b67      	ldr	r3, [pc, #412]	; (8002c58 <SHA256Transform+0x260>)
 8002abc:	6805      	ldr	r5, [r0, #0]
 8002abe:	6901      	ldr	r1, [r0, #16]
 8002ac0:	f8d0 e004 	ldr.w	lr, [r0, #4]
 8002ac4:	6944      	ldr	r4, [r0, #20]
 8002ac6:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8002aca:	f8d0 c018 	ldr.w	ip, [r0, #24]
 8002ace:	68c6      	ldr	r6, [r0, #12]
 8002ad0:	69c7      	ldr	r7, [r0, #28]
 8002ad2:	2201      	movs	r2, #1
 8002ad4:	601a      	str	r2, [r3, #0]
 8002ad6:	681b      	ldr	r3, [r3, #0]
 8002ad8:	9303      	str	r3, [sp, #12]
 8002ada:	4b60      	ldr	r3, [pc, #384]	; (8002c5c <SHA256Transform+0x264>)
 8002adc:	681a      	ldr	r2, [r3, #0]
 8002ade:	9203      	str	r2, [sp, #12]
 8002ae0:	9a03      	ldr	r2, [sp, #12]
 8002ae2:	3201      	adds	r2, #1
 8002ae4:	f040 8099 	bne.w	8002c1a <SHA256Transform+0x222>
 8002ae8:	9a03      	ldr	r2, [sp, #12]
 8002aea:	601a      	str	r2, [r3, #0]
 8002aec:	681b      	ldr	r3, [r3, #0]
 8002aee:	9303      	str	r3, [sp, #12]
 8002af0:	9b03      	ldr	r3, [sp, #12]
 8002af2:	b1db      	cbz	r3, 8002b2c <SHA256Transform+0x134>
 8002af4:	6903      	ldr	r3, [r0, #16]
 8002af6:	4e5a      	ldr	r6, [pc, #360]	; (8002c60 <SHA256Transform+0x268>)
 8002af8:	6807      	ldr	r7, [r0, #0]
 8002afa:	f8d0 901c 	ldr.w	r9, [r0, #28]
 8002afe:	f8d0 c018 	ldr.w	ip, [r0, #24]
 8002b02:	68c1      	ldr	r1, [r0, #12]
 8002b04:	6884      	ldr	r4, [r0, #8]
 8002b06:	6842      	ldr	r2, [r0, #4]
 8002b08:	4077      	eors	r7, r6
 8002b0a:	405e      	eors	r6, r3
 8002b0c:	6943      	ldr	r3, [r0, #20]
 8002b0e:	6007      	str	r7, [r0, #0]
 8002b10:	ea8c 0e01 	eor.w	lr, ip, r1
 8002b14:	6106      	str	r6, [r0, #16]
 8002b16:	ea86 0509 	eor.w	r5, r6, r9
 8002b1a:	ea83 0804 	eor.w	r8, r3, r4
 8002b1e:	4079      	eors	r1, r7
 8002b20:	4056      	eors	r6, r2
 8002b22:	ea89 0404 	eor.w	r4, r9, r4
 8002b26:	ea8c 0c02 	eor.w	ip, ip, r2
 8002b2a:	405f      	eors	r7, r3
 8002b2c:	f04f 0900 	mov.w	r9, #0
 8002b30:	f10d 0b10 	add.w	fp, sp, #16
 8002b34:	4b4b      	ldr	r3, [pc, #300]	; (8002c64 <SHA256Transform+0x26c>)
 8002b36:	f859 2003 	ldr.w	r2, [r9, r3]
 8002b3a:	f859 300b 	ldr.w	r3, [r9, fp]
 8002b3e:	ea4f 1ab1 	mov.w	sl, r1, ror #6
 8002b42:	441a      	add	r2, r3
 8002b44:	ea8a 2af1 	eor.w	sl, sl, r1, ror #11
 8002b48:	ea84 030c 	eor.w	r3, r4, ip
 8002b4c:	ea8a 6a71 	eor.w	sl, sl, r1, ror #25
 8002b50:	400b      	ands	r3, r1
 8002b52:	4492      	add	sl, r2
 8002b54:	ea83 030c 	eor.w	r3, r3, ip
 8002b58:	4453      	add	r3, sl
 8002b5a:	441f      	add	r7, r3
 8002b5c:	ea45 020e 	orr.w	r2, r5, lr
 8002b60:	ea4f 03b5 	mov.w	r3, r5, ror #2
 8002b64:	ea02 0208 	and.w	r2, r2, r8
 8002b68:	ea05 0a0e 	and.w	sl, r5, lr
 8002b6c:	ea83 3375 	eor.w	r3, r3, r5, ror #13
 8002b70:	ea42 020a 	orr.w	r2, r2, sl
 8002b74:	ea83 53b5 	eor.w	r3, r3, r5, ror #22
 8002b78:	4413      	add	r3, r2
 8002b7a:	4a3a      	ldr	r2, [pc, #232]	; (8002c64 <SHA256Transform+0x26c>)
 8002b7c:	eb07 0a06 	add.w	sl, r7, r6
 8002b80:	444a      	add	r2, r9
 8002b82:	eb0b 0609 	add.w	r6, fp, r9
 8002b86:	6852      	ldr	r2, [r2, #4]
 8002b88:	6876      	ldr	r6, [r6, #4]
 8002b8a:	4432      	add	r2, r6
 8002b8c:	4494      	add	ip, r2
 8002b8e:	ea81 0204 	eor.w	r2, r1, r4
 8002b92:	ea02 020a 	and.w	r2, r2, sl
 8002b96:	4062      	eors	r2, r4
 8002b98:	4462      	add	r2, ip
 8002b9a:	ea4f 1cba 	mov.w	ip, sl, ror #6
 8002b9e:	443b      	add	r3, r7
 8002ba0:	ea8c 2cfa 	eor.w	ip, ip, sl, ror #11
 8002ba4:	ea8c 6c7a 	eor.w	ip, ip, sl, ror #25
 8002ba8:	ea4f 06b3 	mov.w	r6, r3, ror #2
 8002bac:	ea43 0705 	orr.w	r7, r3, r5
 8002bb0:	4462      	add	r2, ip
 8002bb2:	ea86 3673 	eor.w	r6, r6, r3, ror #13
 8002bb6:	ea03 0c05 	and.w	ip, r3, r5
 8002bba:	ea07 070e 	and.w	r7, r7, lr
 8002bbe:	ea47 070c 	orr.w	r7, r7, ip
 8002bc2:	ea86 56b3 	eor.w	r6, r6, r3, ror #22
 8002bc6:	f109 0908 	add.w	r9, r9, #8
 8002bca:	443e      	add	r6, r7
 8002bcc:	f5b9 7f80 	cmp.w	r9, #256	; 0x100
 8002bd0:	eb02 0708 	add.w	r7, r2, r8
 8002bd4:	9701      	str	r7, [sp, #4]
 8002bd6:	4432      	add	r2, r6
 8002bd8:	46a8      	mov	r8, r5
 8002bda:	4676      	mov	r6, lr
 8002bdc:	468c      	mov	ip, r1
 8002bde:	4627      	mov	r7, r4
 8002be0:	d135      	bne.n	8002c4e <SHA256Transform+0x256>
 8002be2:	6806      	ldr	r6, [r0, #0]
 8002be4:	4432      	add	r2, r6
 8002be6:	6002      	str	r2, [r0, #0]
 8002be8:	6842      	ldr	r2, [r0, #4]
 8002bea:	4413      	add	r3, r2
 8002bec:	6043      	str	r3, [r0, #4]
 8002bee:	6883      	ldr	r3, [r0, #8]
 8002bf0:	9a01      	ldr	r2, [sp, #4]
 8002bf2:	441d      	add	r5, r3
 8002bf4:	68c3      	ldr	r3, [r0, #12]
 8002bf6:	6085      	str	r5, [r0, #8]
 8002bf8:	4473      	add	r3, lr
 8002bfa:	60c3      	str	r3, [r0, #12]
 8002bfc:	6903      	ldr	r3, [r0, #16]
 8002bfe:	4413      	add	r3, r2
 8002c00:	6103      	str	r3, [r0, #16]
 8002c02:	6943      	ldr	r3, [r0, #20]
 8002c04:	4453      	add	r3, sl
 8002c06:	6143      	str	r3, [r0, #20]
 8002c08:	6983      	ldr	r3, [r0, #24]
 8002c0a:	4419      	add	r1, r3
 8002c0c:	69c3      	ldr	r3, [r0, #28]
 8002c0e:	6181      	str	r1, [r0, #24]
 8002c10:	441c      	add	r4, r3
 8002c12:	61c4      	str	r4, [r0, #28]
 8002c14:	b045      	add	sp, #276	; 0x114
 8002c16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002c1a:	4b11      	ldr	r3, [pc, #68]	; (8002c60 <SHA256Transform+0x268>)
 8002c1c:	ea8c 0906 	eor.w	r9, ip, r6
 8002c20:	ea85 0203 	eor.w	r2, r5, r3
 8002c24:	ea84 0a08 	eor.w	sl, r4, r8
 8002c28:	404b      	eors	r3, r1
 8002c2a:	ea88 0807 	eor.w	r8, r8, r7
 8002c2e:	ea83 0507 	eor.w	r5, r3, r7
 8002c32:	ea82 0106 	eor.w	r1, r2, r6
 8002c36:	ea8c 0c0e 	eor.w	ip, ip, lr
 8002c3a:	ea82 0704 	eor.w	r7, r2, r4
 8002c3e:	ea83 060e 	eor.w	r6, r3, lr
 8002c42:	4644      	mov	r4, r8
 8002c44:	6002      	str	r2, [r0, #0]
 8002c46:	6103      	str	r3, [r0, #16]
 8002c48:	46d0      	mov	r8, sl
 8002c4a:	46ce      	mov	lr, r9
 8002c4c:	e76e      	b.n	8002b2c <SHA256Transform+0x134>
 8002c4e:	4654      	mov	r4, sl
 8002c50:	9901      	ldr	r1, [sp, #4]
 8002c52:	469e      	mov	lr, r3
 8002c54:	4615      	mov	r5, r2
 8002c56:	e76d      	b.n	8002b34 <SHA256Transform+0x13c>
 8002c58:	40023008 	.word	0x40023008
 8002c5c:	40023000 	.word	0x40023000
 8002c60:	a5a5f0f0 	.word	0xa5a5f0f0
 8002c64:	08003278 	.word	0x08003278

08002c68 <SHA256Update>:
 8002c68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002c6c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8002c6e:	4604      	mov	r4, r0
 8002c70:	4617      	mov	r7, r2
 8002c72:	00d2      	lsls	r2, r2, #3
 8002c74:	f3c3 00c5 	ubfx	r0, r3, #3, #6
 8002c78:	189b      	adds	r3, r3, r2
 8002c7a:	64e3      	str	r3, [r4, #76]	; 0x4c
 8002c7c:	bf22      	ittt	cs
 8002c7e:	6d23      	ldrcs	r3, [r4, #80]	; 0x50
 8002c80:	3301      	addcs	r3, #1
 8002c82:	6523      	strcs	r3, [r4, #80]	; 0x50
 8002c84:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8002c86:	eb03 7357 	add.w	r3, r3, r7, lsr #29
 8002c8a:	6523      	str	r3, [r4, #80]	; 0x50
 8002c8c:	19c3      	adds	r3, r0, r7
 8002c8e:	2b3f      	cmp	r3, #63	; 0x3f
 8002c90:	460e      	mov	r6, r1
 8002c92:	d92f      	bls.n	8002cf4 <SHA256Update+0x8c>
 8002c94:	f1c0 0540 	rsb	r5, r0, #64	; 0x40
 8002c98:	300c      	adds	r0, #12
 8002c9a:	462a      	mov	r2, r5
 8002c9c:	4420      	add	r0, r4
 8002c9e:	f104 0854 	add.w	r8, r4, #84	; 0x54
 8002ca2:	f104 090c 	add.w	r9, r4, #12
 8002ca6:	f000 f931 	bl	8002f0c <memcpy>
 8002caa:	4649      	mov	r1, r9
 8002cac:	4640      	mov	r0, r8
 8002cae:	f7ff fea3 	bl	80029f8 <SHA256Transform>
 8002cb2:	f105 033f 	add.w	r3, r5, #63	; 0x3f
 8002cb6:	429f      	cmp	r7, r3
 8002cb8:	eb06 0105 	add.w	r1, r6, r5
 8002cbc:	d808      	bhi.n	8002cd0 <SHA256Update+0x68>
 8002cbe:	2000      	movs	r0, #0
 8002cc0:	300c      	adds	r0, #12
 8002cc2:	1b7a      	subs	r2, r7, r5
 8002cc4:	1971      	adds	r1, r6, r5
 8002cc6:	4420      	add	r0, r4
 8002cc8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002ccc:	f000 b91e 	b.w	8002f0c <memcpy>
 8002cd0:	078b      	lsls	r3, r1, #30
 8002cd2:	d004      	beq.n	8002cde <SHA256Update+0x76>
 8002cd4:	4640      	mov	r0, r8
 8002cd6:	f7ff fe8f 	bl	80029f8 <SHA256Transform>
 8002cda:	3540      	adds	r5, #64	; 0x40
 8002cdc:	e7e9      	b.n	8002cb2 <SHA256Update+0x4a>
 8002cde:	464b      	mov	r3, r9
 8002ce0:	f101 0240 	add.w	r2, r1, #64	; 0x40
 8002ce4:	f851 0b04 	ldr.w	r0, [r1], #4
 8002ce8:	f843 0b04 	str.w	r0, [r3], #4
 8002cec:	4291      	cmp	r1, r2
 8002cee:	d1f9      	bne.n	8002ce4 <SHA256Update+0x7c>
 8002cf0:	4649      	mov	r1, r9
 8002cf2:	e7ef      	b.n	8002cd4 <SHA256Update+0x6c>
 8002cf4:	2500      	movs	r5, #0
 8002cf6:	e7e3      	b.n	8002cc0 <SHA256Update+0x58>

08002cf8 <SHA256_Append>:
 8002cf8:	b538      	push	{r3, r4, r5, lr}
 8002cfa:	b150      	cbz	r0, 8002d12 <SHA256_Append+0x1a>
 8002cfc:	b149      	cbz	r1, 8002d12 <SHA256_Append+0x1a>
 8002cfe:	2a00      	cmp	r2, #0
 8002d00:	db07      	blt.n	8002d12 <SHA256_Append+0x1a>
 8002d02:	7903      	ldrb	r3, [r0, #4]
 8002d04:	f013 0404 	ands.w	r4, r3, #4
 8002d08:	d106      	bne.n	8002d18 <SHA256_Append+0x20>
 8002d0a:	f7ff ffad 	bl	8002c68 <SHA256Update>
 8002d0e:	4620      	mov	r0, r4
 8002d10:	bd38      	pop	{r3, r4, r5, pc}
 8002d12:	f640 70a3 	movw	r0, #4003	; 0xfa3
 8002d16:	e7fb      	b.n	8002d10 <SHA256_Append+0x18>
 8002d18:	f640 70a1 	movw	r0, #4001	; 0xfa1
 8002d1c:	e7f8      	b.n	8002d10 <SHA256_Append+0x18>
	...

08002d20 <SHA256Init>:
 8002d20:	4b0c      	ldr	r3, [pc, #48]	; (8002d54 <SHA256Init+0x34>)
 8002d22:	4a0d      	ldr	r2, [pc, #52]	; (8002d58 <SHA256Init+0x38>)
 8002d24:	490d      	ldr	r1, [pc, #52]	; (8002d5c <SHA256Init+0x3c>)
 8002d26:	f8df c044 	ldr.w	ip, [pc, #68]	; 8002d6c <SHA256Init+0x4c>
 8002d2a:	e9c0 2315 	strd	r2, r3, [r0, #84]	; 0x54
 8002d2e:	4b0c      	ldr	r3, [pc, #48]	; (8002d60 <SHA256Init+0x40>)
 8002d30:	e9c0 1317 	strd	r1, r3, [r0, #92]	; 0x5c
 8002d34:	4b0b      	ldr	r3, [pc, #44]	; (8002d64 <SHA256Init+0x44>)
 8002d36:	e9c0 c319 	strd	ip, r3, [r0, #100]	; 0x64
 8002d3a:	4b0b      	ldr	r3, [pc, #44]	; (8002d68 <SHA256Init+0x48>)
 8002d3c:	66c3      	str	r3, [r0, #108]	; 0x6c
 8002d3e:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
 8002d42:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
 8002d46:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
 8002d4a:	6703      	str	r3, [r0, #112]	; 0x70
 8002d4c:	2300      	movs	r3, #0
 8002d4e:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
 8002d52:	4770      	bx	lr
 8002d54:	bb67ae85 	.word	0xbb67ae85
 8002d58:	6a09e667 	.word	0x6a09e667
 8002d5c:	3c6ef372 	.word	0x3c6ef372
 8002d60:	a54ff53a 	.word	0xa54ff53a
 8002d64:	9b05688c 	.word	0x9b05688c
 8002d68:	1f83d9ab 	.word	0x1f83d9ab
 8002d6c:	510e527f 	.word	0x510e527f

08002d70 <SHA256_Init>:
 8002d70:	b508      	push	{r3, lr}
 8002d72:	b138      	cbz	r0, 8002d84 <SHA256_Init+0x14>
 8002d74:	7903      	ldrb	r3, [r0, #4]
 8002d76:	f023 0306 	bic.w	r3, r3, #6
 8002d7a:	7103      	strb	r3, [r0, #4]
 8002d7c:	f7ff ffd0 	bl	8002d20 <SHA256Init>
 8002d80:	2000      	movs	r0, #0
 8002d82:	bd08      	pop	{r3, pc}
 8002d84:	f640 70a3 	movw	r0, #4003	; 0xfa3
 8002d88:	e7fb      	b.n	8002d82 <SHA256_Init+0x12>

08002d8a <SHA256Final>:
 8002d8a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8002d8e:	2300      	movs	r3, #0
 8002d90:	4604      	mov	r4, r0
 8002d92:	460d      	mov	r5, r1
 8002d94:	2b03      	cmp	r3, #3
 8002d96:	bfd4      	ite	le
 8002d98:	214c      	movle	r1, #76	; 0x4c
 8002d9a:	2148      	movgt	r1, #72	; 0x48
 8002d9c:	4421      	add	r1, r4
 8002d9e:	43da      	mvns	r2, r3
 8002da0:	f002 0203 	and.w	r2, r2, #3
 8002da4:	6849      	ldr	r1, [r1, #4]
 8002da6:	00d2      	lsls	r2, r2, #3
 8002da8:	fa21 f202 	lsr.w	r2, r1, r2
 8002dac:	f80d 2003 	strb.w	r2, [sp, r3]
 8002db0:	3301      	adds	r3, #1
 8002db2:	2b08      	cmp	r3, #8
 8002db4:	d1ee      	bne.n	8002d94 <SHA256Final+0xa>
 8002db6:	e9d4 0113 	ldrd	r0, r1, [r4, #76]	; 0x4c
 8002dba:	08c2      	lsrs	r2, r0, #3
 8002dbc:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
 8002dc0:	2100      	movs	r1, #0
 8002dc2:	f002 003f 	and.w	r0, r2, #63	; 0x3f
 8002dc6:	2900      	cmp	r1, #0
 8002dc8:	bf08      	it	eq
 8002dca:	2838      	cmpeq	r0, #56	; 0x38
 8002dcc:	4420      	add	r0, r4
 8002dce:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8002dd2:	f04f 0180 	mov.w	r1, #128	; 0x80
 8002dd6:	f104 064c 	add.w	r6, r4, #76	; 0x4c
 8002dda:	f102 0301 	add.w	r3, r2, #1
 8002dde:	7301      	strb	r1, [r0, #12]
 8002de0:	d23b      	bcs.n	8002e5a <SHA256Final+0xd0>
 8002de2:	2200      	movs	r2, #0
 8002de4:	2b37      	cmp	r3, #55	; 0x37
 8002de6:	dd34      	ble.n	8002e52 <SHA256Final+0xc8>
 8002de8:	f104 0244 	add.w	r2, r4, #68	; 0x44
 8002dec:	2300      	movs	r3, #0
 8002dee:	f81d 1003 	ldrb.w	r1, [sp, r3]
 8002df2:	f802 1b01 	strb.w	r1, [r2], #1
 8002df6:	3301      	adds	r3, #1
 8002df8:	2b08      	cmp	r3, #8
 8002dfa:	d1f8      	bne.n	8002dee <SHA256Final+0x64>
 8002dfc:	f104 010c 	add.w	r1, r4, #12
 8002e00:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8002e04:	f7ff fdf8 	bl	80029f8 <SHA256Transform>
 8002e08:	f104 0354 	add.w	r3, r4, #84	; 0x54
 8002e0c:	f104 0174 	add.w	r1, r4, #116	; 0x74
 8002e10:	461f      	mov	r7, r3
 8002e12:	681a      	ldr	r2, [r3, #0]
 8002e14:	70ea      	strb	r2, [r5, #3]
 8002e16:	681a      	ldr	r2, [r3, #0]
 8002e18:	0a12      	lsrs	r2, r2, #8
 8002e1a:	70aa      	strb	r2, [r5, #2]
 8002e1c:	f853 2b04 	ldr.w	r2, [r3], #4
 8002e20:	0c12      	lsrs	r2, r2, #16
 8002e22:	706a      	strb	r2, [r5, #1]
 8002e24:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 8002e28:	f805 2b04 	strb.w	r2, [r5], #4
 8002e2c:	4299      	cmp	r1, r3
 8002e2e:	d1f0      	bne.n	8002e12 <SHA256Final+0x88>
 8002e30:	2240      	movs	r2, #64	; 0x40
 8002e32:	2100      	movs	r1, #0
 8002e34:	f104 000c 	add.w	r0, r4, #12
 8002e38:	f000 f876 	bl	8002f28 <memset>
 8002e3c:	2220      	movs	r2, #32
 8002e3e:	2100      	movs	r1, #0
 8002e40:	4638      	mov	r0, r7
 8002e42:	f000 f871 	bl	8002f28 <memset>
 8002e46:	2300      	movs	r3, #0
 8002e48:	64e3      	str	r3, [r4, #76]	; 0x4c
 8002e4a:	6073      	str	r3, [r6, #4]
 8002e4c:	b002      	add	sp, #8
 8002e4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002e52:	18e1      	adds	r1, r4, r3
 8002e54:	3301      	adds	r3, #1
 8002e56:	730a      	strb	r2, [r1, #12]
 8002e58:	e7c4      	b.n	8002de4 <SHA256Final+0x5a>
 8002e5a:	320c      	adds	r2, #12
 8002e5c:	4422      	add	r2, r4
 8002e5e:	f104 034b 	add.w	r3, r4, #75	; 0x4b
 8002e62:	2100      	movs	r1, #0
 8002e64:	429a      	cmp	r2, r3
 8002e66:	d11a      	bne.n	8002e9e <SHA256Final+0x114>
 8002e68:	f104 070c 	add.w	r7, r4, #12
 8002e6c:	f104 0854 	add.w	r8, r4, #84	; 0x54
 8002e70:	4639      	mov	r1, r7
 8002e72:	4640      	mov	r0, r8
 8002e74:	f7ff fdc0 	bl	80029f8 <SHA256Transform>
 8002e78:	463b      	mov	r3, r7
 8002e7a:	f104 0244 	add.w	r2, r4, #68	; 0x44
 8002e7e:	2100      	movs	r1, #0
 8002e80:	f803 1b01 	strb.w	r1, [r3], #1
 8002e84:	4293      	cmp	r3, r2
 8002e86:	d1fb      	bne.n	8002e80 <SHA256Final+0xf6>
 8002e88:	2200      	movs	r2, #0
 8002e8a:	f81d 1002 	ldrb.w	r1, [sp, r2]
 8002e8e:	f803 1b01 	strb.w	r1, [r3], #1
 8002e92:	3201      	adds	r2, #1
 8002e94:	2a08      	cmp	r2, #8
 8002e96:	d1f8      	bne.n	8002e8a <SHA256Final+0x100>
 8002e98:	4639      	mov	r1, r7
 8002e9a:	4640      	mov	r0, r8
 8002e9c:	e7b2      	b.n	8002e04 <SHA256Final+0x7a>
 8002e9e:	f802 1f01 	strb.w	r1, [r2, #1]!
 8002ea2:	e7df      	b.n	8002e64 <SHA256Final+0xda>

08002ea4 <SHA256_Finish>:
 8002ea4:	b570      	push	{r4, r5, r6, lr}
 8002ea6:	460e      	mov	r6, r1
 8002ea8:	b088      	sub	sp, #32
 8002eaa:	4615      	mov	r5, r2
 8002eac:	4604      	mov	r4, r0
 8002eae:	b1c8      	cbz	r0, 8002ee4 <SHA256_Finish+0x40>
 8002eb0:	b1c1      	cbz	r1, 8002ee4 <SHA256_Finish+0x40>
 8002eb2:	b1ba      	cbz	r2, 8002ee4 <SHA256_Finish+0x40>
 8002eb4:	6883      	ldr	r3, [r0, #8]
 8002eb6:	3b01      	subs	r3, #1
 8002eb8:	2b1f      	cmp	r3, #31
 8002eba:	d816      	bhi.n	8002eea <SHA256_Finish+0x46>
 8002ebc:	7903      	ldrb	r3, [r0, #4]
 8002ebe:	f043 0304 	orr.w	r3, r3, #4
 8002ec2:	7103      	strb	r3, [r0, #4]
 8002ec4:	4669      	mov	r1, sp
 8002ec6:	f7ff ff60 	bl	8002d8a <SHA256Final>
 8002eca:	2300      	movs	r3, #0
 8002ecc:	68a2      	ldr	r2, [r4, #8]
 8002ece:	4293      	cmp	r3, r2
 8002ed0:	db03      	blt.n	8002eda <SHA256_Finish+0x36>
 8002ed2:	602a      	str	r2, [r5, #0]
 8002ed4:	2000      	movs	r0, #0
 8002ed6:	b008      	add	sp, #32
 8002ed8:	bd70      	pop	{r4, r5, r6, pc}
 8002eda:	f81d 2003 	ldrb.w	r2, [sp, r3]
 8002ede:	54f2      	strb	r2, [r6, r3]
 8002ee0:	3301      	adds	r3, #1
 8002ee2:	e7f3      	b.n	8002ecc <SHA256_Finish+0x28>
 8002ee4:	f640 70a3 	movw	r0, #4003	; 0xfa3
 8002ee8:	e7f5      	b.n	8002ed6 <SHA256_Finish+0x32>
 8002eea:	f640 70a2 	movw	r0, #4002	; 0xfa2
 8002eee:	e7f2      	b.n	8002ed6 <SHA256_Finish+0x32>

08002ef0 <memcmp>:
 8002ef0:	b530      	push	{r4, r5, lr}
 8002ef2:	3901      	subs	r1, #1
 8002ef4:	2400      	movs	r4, #0
 8002ef6:	42a2      	cmp	r2, r4
 8002ef8:	d101      	bne.n	8002efe <memcmp+0xe>
 8002efa:	2000      	movs	r0, #0
 8002efc:	e005      	b.n	8002f0a <memcmp+0x1a>
 8002efe:	5d03      	ldrb	r3, [r0, r4]
 8002f00:	3401      	adds	r4, #1
 8002f02:	5d0d      	ldrb	r5, [r1, r4]
 8002f04:	42ab      	cmp	r3, r5
 8002f06:	d0f6      	beq.n	8002ef6 <memcmp+0x6>
 8002f08:	1b58      	subs	r0, r3, r5
 8002f0a:	bd30      	pop	{r4, r5, pc}

08002f0c <memcpy>:
 8002f0c:	440a      	add	r2, r1
 8002f0e:	4291      	cmp	r1, r2
 8002f10:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8002f14:	d100      	bne.n	8002f18 <memcpy+0xc>
 8002f16:	4770      	bx	lr
 8002f18:	b510      	push	{r4, lr}
 8002f1a:	f811 4b01 	ldrb.w	r4, [r1], #1
 8002f1e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8002f22:	4291      	cmp	r1, r2
 8002f24:	d1f9      	bne.n	8002f1a <memcpy+0xe>
 8002f26:	bd10      	pop	{r4, pc}

08002f28 <memset>:
 8002f28:	4402      	add	r2, r0
 8002f2a:	4603      	mov	r3, r0
 8002f2c:	4293      	cmp	r3, r2
 8002f2e:	d100      	bne.n	8002f32 <memset+0xa>
 8002f30:	4770      	bx	lr
 8002f32:	f803 1b01 	strb.w	r1, [r3], #1
 8002f36:	e7f9      	b.n	8002f2c <memset+0x4>

08002f38 <_init>:
 8002f38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002f3a:	bf00      	nop
 8002f3c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002f3e:	bc08      	pop	{r3}
 8002f40:	469e      	mov	lr, r3
 8002f42:	4770      	bx	lr

08002f44 <_fini>:
 8002f44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002f46:	bf00      	nop
 8002f48:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002f4a:	bc08      	pop	{r3}
 8002f4c:	469e      	mov	lr, r3
 8002f4e:	4770      	bx	lr

Disassembly of section .RamFunc:

08002f50 <FLASH_Program_Fast>:
  __IO uint32_t *dest_addr = (__IO uint32_t *)Address;
  __IO uint32_t *src_addr = (__IO uint32_t *)DataAddress;
  uint32_t primask_bit;

  /* Set FSTPG bit */
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 8002f50:	4b0a      	ldr	r3, [pc, #40]	; (8002f7c <FLASH_Program_Fast+0x2c>)
 8002f52:	695a      	ldr	r2, [r3, #20]
 8002f54:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
{
 8002f58:	b530      	push	{r4, r5, lr}
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 8002f5a:	615a      	str	r2, [r3, #20]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8002f5c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8002f60:	b672      	cpsid	i
}
 8002f62:	2200      	movs	r2, #0
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
 8002f64:	588d      	ldr	r5, [r1, r2]
 8002f66:	5085      	str	r5, [r0, r2]
    dest_addr++;
    src_addr++;
    row_index--;
  }
  while (row_index != 0U);
 8002f68:	3204      	adds	r2, #4
 8002f6a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8002f6e:	d1f9      	bne.n	8002f64 <FLASH_Program_Fast+0x14>

  /* wait for BSY in order to be sure that flash operation is ended before
     allowing prefetch in flash. Timeout does not return status, as it will
     be anyway done later */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != 0U)
 8002f70:	691a      	ldr	r2, [r3, #16]
 8002f72:	03d2      	lsls	r2, r2, #15
 8002f74:	d4fc      	bmi.n	8002f70 <FLASH_Program_Fast+0x20>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002f76:	f384 8810 	msr	PRIMASK, r4
  {
  }

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 8002f7a:	bd30      	pop	{r4, r5, pc}
 8002f7c:	58004000 	.word	0x58004000
